<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芷兰旧梦</title>
  
  <subtitle>偶尔记一些东西</subtitle>
  <link href="http://tanqidong1992.github.io/atom.xml" rel="self"/>
  
  <link href="http://tanqidong1992.github.io/"/>
  <updated>2023-02-13T13:30:13.913Z</updated>
  <id>http://tanqidong1992.github.io/</id>
  
  <author>
    <name>芷兰旧梦</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Maven远程仓库服务器证书验证失败解决</title>
    <link href="http://tanqidong1992.github.io/2022/08/25/2022/08/23/maven-ssl-error/"/>
    <id>http://tanqidong1992.github.io/2022/08/25/2022/08/23/maven-ssl-error/</id>
    <published>2022-08-25T06:15:33.000Z</published>
    <updated>2023-02-13T13:30:13.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven远程仓库服务器证书验证失败解决"><a href="#Maven远程仓库服务器证书验证失败解决" class="headerlink" title="Maven远程仓库服务器证书验证失败解决"></a>Maven远程仓库服务器证书验证失败解决</h1><h2 id="错误信息"><a href="#错误信息" class="headerlink" title="错误信息"></a>错误信息</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: PKIX path validation failed: java.security.cert.CertPathValidatorException: validity check failed</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li>导入证书链</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -importcert -keystore $&#123;JAVA_HOME&#125;/lib/security/cacerts -file &lt;crt&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>添加环境变量</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_OPTS=&quot;-Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Maven远程仓库服务器证书验证失败解决.</summary>
    
    
    
    
    <category term="Maven" scheme="http://tanqidong1992.github.io/tags/Maven/"/>
    
    <category term="SSL" scheme="http://tanqidong1992.github.io/tags/SSL/"/>
    
  </entry>
  
  <entry>
    <title>发布NPM包</title>
    <link href="http://tanqidong1992.github.io/2022/08/22/2022/08/22/publish-npm-package/"/>
    <id>http://tanqidong1992.github.io/2022/08/22/2022/08/22/publish-npm-package/</id>
    <published>2022-08-22T03:15:33.000Z</published>
    <updated>2023-02-13T13:30:13.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="发布NPM包"><a href="#发布NPM包" class="headerlink" title="发布NPM包"></a>发布NPM包</h1><ol><li>在Nexus 3新建一个hosted类型的NPM包仓库,取名为hosted-npm</li><li>分配一个专门用于部署NPM包的用户</li><li>激活Nexus3中安全域 npm Bearer Token Realm</li><li>发布</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd $&#123;YourProjectBaseDir&#125;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">登录</span></span><br><span class="line">npm login --registry=http://$&#123;YourNexusHost&#125;/repository/hosted-npm/ </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">发布</span></span><br><span class="line">npm publish --registry=http://$&#123;YourNexusHost&#125;/repository/hosted-npm/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">发布NPM包.</summary>
    
    
    
    
    <category term="NPM" scheme="http://tanqidong1992.github.io/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>WSL配置</title>
    <link href="http://tanqidong1992.github.io/2022/07/15/2022/07/15/config-wsl/"/>
    <id>http://tanqidong1992.github.io/2022/07/15/2022/07/15/config-wsl/</id>
    <published>2022-07-15T12:15:00.000Z</published>
    <updated>2023-02-13T13:30:13.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WSL配置"><a href="#WSL配置" class="headerlink" title="WSL配置"></a>WSL配置</h1><h2 id="安装WSL"><a href="#安装WSL" class="headerlink" title="安装WSL"></a>安装WSL</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure><h2 id="安装发行版本"><a href="#安装发行版本" class="headerlink" title="安装发行版本"></a>安装发行版本</h2><ol><li>查看可以安装的Linux发行版</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\wanazi&gt; wsl <span class="literal">--list</span> <span class="literal">--online</span></span><br><span class="line">以下是可安装的有效分发的列表。</span><br><span class="line">请使用“wsl <span class="literal">--install</span> <span class="literal">-d</span> &lt;分发&gt;”安装。</span><br><span class="line"></span><br><span class="line">NAME            FRIENDLY NAME</span><br><span class="line">Ubuntu          Ubuntu</span><br><span class="line">Debian          Debian GNU/Linux</span><br><span class="line">kali<span class="literal">-linux</span>      Kali Linux Rolling</span><br><span class="line">openS<span class="built_in">USE-42</span>     openSUSE Leap <span class="number">42</span></span><br><span class="line">SLES<span class="literal">-12</span>         SUSE Linux Enterprise Server v12</span><br><span class="line">Ubuntu<span class="literal">-16</span>.<span class="number">04</span>    Ubuntu <span class="number">16.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-18</span>.<span class="number">04</span>    Ubuntu <span class="number">18.04</span> LTS</span><br><span class="line">Ubuntu<span class="literal">-20</span>.<span class="number">04</span>    Ubuntu <span class="number">20.04</span> LTS</span><br></pre></td></tr></table></figure><ol start="2"><li>启用WSL 2</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--set-default-version</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><ol start="3"><li>安装Ubuntu-20.04</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl <span class="literal">--install</span> <span class="literal">-d</span> Ubuntu<span class="literal">-20</span>.<span class="number">04</span></span><br></pre></td></tr></table></figure><ol start="4"><li>启动Ubuntu-20.04</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl</span><br></pre></td></tr></table></figure><ol start="5"><li>配置WSL<br> vim &#x2F;etc&#x2F;wsl.conf</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[automount]</span></span><br><span class="line"><span class="attr">root</span>= /</span><br><span class="line"><span class="attr">options</span> = <span class="string">&quot;metadata&quot;</span></span><br><span class="line"><span class="section">[network]</span></span><br><span class="line"><span class="attr">hostname</span> = valina</span><br><span class="line"><span class="section">[interop]</span></span><br><span class="line"><span class="attr">appendWindowsPath</span> = <span class="literal">false</span></span><br><span class="line"><span class="section">[boot]</span></span><br><span class="line"><span class="attr">systemd</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install">安装WSL</a></li><li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/wsl-config">配置WSL</a></li></ol>]]></content>
    
    
    <summary type="html">WSL配置.</summary>
    
    
    
    
    <category term="WSL" scheme="http://tanqidong1992.github.io/tags/WSL/"/>
    
    <category term="Ubuntu" scheme="http://tanqidong1992.github.io/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>中国移动宽带IPV6配置</title>
    <link href="http://tanqidong1992.github.io/2022/07/01/2022/07/01/ipv6-config/"/>
    <id>http://tanqidong1992.github.io/2022/07/01/2022/07/01/ipv6-config/</id>
    <published>2022-07-01T12:14:33.000Z</published>
    <updated>2023-02-13T13:30:14.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中国移动宽带IPV6配置"><a href="#中国移动宽带IPV6配置" class="headerlink" title="中国移动宽带IPV6配置"></a>中国移动宽带IPV6配置</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>昨天自己在手机上发现手机上竟然自动分配了IPV6地址,可以访问IPV6网站,最近了解到IPV6的地址可以被全局访问,所以想尝试配置一下自己的路由器.</p><h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>中国移动的宽带默认的网络拓扑如下图所示</p><p><img src="http://tanqidong1992.github.io/2022/07/01/2022/07/01/ipv6-config/5c770d90764d3f5ac0611bf2eedc15f9431fdd43e630b9ccfd210a8943ddeda8.svg"></p><p>在这个网络中,启动IPv6配置后,只有路由器被分配了全局的IPV6地址.修改路由器的上网方式为桥接后,房间局域网的设备都被分配了全局的IPV6地址.<br>修改后的网络拓扑如下图所示</p><p><img src="http://tanqidong1992.github.io/2022/07/01/2022/07/01/ipv6-config/4715115acace1f8c9a74a419d4108c10e033f773f39ac88aa54f14542cb83580.svg"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.luyouwang.net/8778.html">移动光猫开启IPv6教程</a></li></ol>]]></content>
    
    
    <summary type="html">中国移动宽带IPV6配置.</summary>
    
    
    
    
    <category term="中国移动宽带" scheme="http://tanqidong1992.github.io/tags/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E5%AE%BD%E5%B8%A6/"/>
    
    <category term="IPV6，路由器" scheme="http://tanqidong1992.github.io/tags/IPV6%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>离线安装Docker</title>
    <link href="http://tanqidong1992.github.io/2022/06/09/2022/08/docker-install-centos-offline/"/>
    <id>http://tanqidong1992.github.io/2022/06/09/2022/08/docker-install-centos-offline/</id>
    <published>2022-06-09T07:15:33.000Z</published>
    <updated>2023-02-13T13:30:14.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="离线安装Docker"><a href="#离线安装Docker" class="headerlink" title="离线安装Docker"></a>离线安装Docker</h1><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /etc/centos-release</span></span><br><span class="line">CentOS Linux release 7.6.1810 (Core)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">cat</span> /etc/os-release</span></span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><ul><li>containerd.io-1.5.11-3.1.el7.x86_64.rpm</li><li>container-selinux-2.119.1-1.c57a6f9.el7.noarch.rpm</li><li>docker-ce-20.10.9-3.el7.x86_64.rpm</li><li>docker-ce-cli-20.10.9-3.el7.x86_64.rpm</li><li>docker-ce-rootless-extras-20.10.9-3.el7.x86_64.rpm</li><li>docker-ce-selinux-17.03.3.ce-1.el7.noarch.rpm</li><li>docker-compose-plugin-2.3.3-3.el7.x86_64.rpm</li><li>docker-scan-plugin-0.9.0-3.el7.x86_64.rpm</li><li>fuse3-libs-3.6.1-4.el7.x86_64.rpm</li><li>fuse-overlayfs-0.7.2-6.el7_8.x86_64.rpm</li><li>slirp4netns-0.4.3-4.el7_8.x86_64.rpm</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -i *.rpm</span><br></pre></td></tr></table></figure><h2 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h2><p>vim &#x2F;etc&#x2F;docker&#x2F;daemon.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;data-root&quot;</span><span class="punctuation">:</span><span class="string">&quot;/data/app-data/docker&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;insecure-registries&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;192.168.0.149:8082&quot;</span><span class="punctuation">,</span><span class="string">&quot;192.168.0.149:8084&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line"><span class="string">&quot;http://192.168.0.149:8084&quot;</span></span><br><span class="line"><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;log-driver&quot;</span><span class="punctuation">:</span> <span class="string">&quot;json-file&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;log-opts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;max-size&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10g&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;max-file&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>重启docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h2 id="配置当前用户访问权限"><a href="#配置当前用户访问权限" class="headerlink" title="配置当前用户访问权限"></a>配置当前用户访问权限</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line">newgrp docker</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">docker info</span></span><br><span class="line">Client:</span><br><span class="line">Context:    default</span><br><span class="line">Debug Mode: false</span><br><span class="line">Plugins:</span><br><span class="line">app: Docker App (Docker Inc., v0.9.1-beta3)</span><br><span class="line">buildx: Build with BuildKit (Docker Inc., v0.6.3-docker)</span><br><span class="line">compose: Docker Compose (Docker Inc., v2.3.3)</span><br><span class="line">scan: Docker Scan (Docker Inc., v0.9.0)</span><br><span class="line"></span><br><span class="line">Server:</span><br><span class="line">Containers: 0</span><br><span class="line">Running: 0</span><br><span class="line">Paused: 0</span><br><span class="line">Stopped: 0</span><br><span class="line">Images: 0</span><br><span class="line">Server Version: 20.10.9</span><br><span class="line">Storage Driver: overlay2</span><br><span class="line">Backing Filesystem: extfs</span><br><span class="line">Supports d_type: true</span><br><span class="line">Native Overlay Diff: true</span><br><span class="line">userxattr: false</span><br><span class="line">Logging Driver: json-file</span><br><span class="line">Cgroup Driver: cgroupfs</span><br><span class="line">Cgroup Version: 1</span><br><span class="line">Plugins:</span><br><span class="line">Volume: local</span><br><span class="line">Network: bridge host ipvlan macvlan null overlay</span><br><span class="line">Log: awslogs fluentd gcplogs gelf journald json-file local logentries splunk syslog</span><br><span class="line">Swarm: inactive</span><br><span class="line">Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</span><br><span class="line">Default Runtime: runc</span><br><span class="line">Init Binary: docker-init</span><br><span class="line">containerd version: 3df54a852345ae127d1fa3092b95168e4a88e2f8</span><br><span class="line">runc version: v1.0.3-0-gf46b6ba</span><br><span class="line">init version: de40ad0</span><br><span class="line">Security Options:</span><br><span class="line">seccomp</span><br><span class="line">Profile: default</span><br><span class="line">Kernel Version: 3.10.0-957.el7.x86_64</span><br><span class="line">Operating System: CentOS Linux 7 (Core)</span><br><span class="line">OSType: linux</span><br><span class="line">Architecture: x86_64</span><br><span class="line">CPUs: 48</span><br><span class="line">Total Memory: 62.51GiB</span><br><span class="line">Name: localhost.localdomain</span><br><span class="line">ID: KYKT:JPKP:4LEE:THJ4:RXUG:LNDT:CZQL:4O5I:VUXP:VRXI:3B5O:6E5D</span><br><span class="line">Docker Root Dir: /data/app-data/docker</span><br><span class="line">Debug Mode: false</span><br><span class="line">Registry: https://index.docker.io/v1/</span><br><span class="line">Labels:</span><br><span class="line">Experimental: false</span><br><span class="line">Insecure Registries:</span><br><span class="line">192.168.0.149:8082</span><br><span class="line">192.168.0.149:8084</span><br><span class="line">127.0.0.0/8</span><br><span class="line">Registry Mirrors:</span><br><span class="line">http://192.168.0.149:8084/</span><br><span class="line">Live Restore Enabled: false</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://download.docker.com/linux/">Docker 安装包下载地址</a></li><li><a href="https://pkgs.org/">Docker 安装包依赖下载地址</a></li></ol>]]></content>
    
    
    <summary type="html">离线安装Docker.</summary>
    
    
    
    
    <category term="Docker" scheme="http://tanqidong1992.github.io/tags/Docker/"/>
    
    <category term="CentOS" scheme="http://tanqidong1992.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>CAS单点登录测试环境配置</title>
    <link href="http://tanqidong1992.github.io/2022/06/09/2022/06/09/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <id>http://tanqidong1992.github.io/2022/06/09/2022/06/09/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</id>
    <published>2022-06-09T07:15:33.000Z</published>
    <updated>2023-02-13T13:30:14.200Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS单点登录测试环境配置"><a href="#CAS单点登录测试环境配置" class="headerlink" title="CAS单点登录测试环境配置"></a>CAS单点登录测试环境配置</h1><h2 id="生成服务端SSL证书"><a href="#生成服务端SSL证书" class="headerlink" title="生成服务端SSL证书"></a>生成服务端SSL证书</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keyalg RSA -keystore ./keystore.jks -storetype jks</span><br></pre></td></tr></table></figure><p>备注: 秘钥库密码为changeit,common name为localhost</p><h2 id="配置CAS"><a href="#配置CAS" class="headerlink" title="配置CAS"></a>配置CAS</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim cas.properties</span></span><br><span class="line">cas.serviceRegistry.json.location=file:/etc/cas/services</span><br><span class="line">cas.serviceRegistry.core.initFromJson=true</span><br><span class="line">cas.ticket.st.timeToKillInSeconds=1800</span><br></pre></td></tr></table></figure><h2 id="注册服务Json配置文件"><a href="#注册服务Json配置文件" class="headerlink" title="注册服务Json配置文件"></a>注册服务Json配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">vim Pointservice-10000002.json</span></span><br><span class="line">&#123;</span><br><span class="line">&quot;@class&quot;: &quot;org.apereo.cas.services.RegexRegisteredService&quot;,</span><br><span class="line">&quot;serviceId&quot;: &quot;^(https|imaps|http)://.*&quot;,</span><br><span class="line">&quot;name&quot;: &quot;测试服务&quot;,</span><br><span class="line">&quot;id&quot;: 10000002,</span><br><span class="line">&quot;description&quot;: &quot;测试服务&quot;,</span><br><span class="line">&quot;evaluationOrder&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="启动CAS服务"><a href="#启动CAS服务" class="headerlink" title="启动CAS服务"></a>启动CAS服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -ti --rm --name=cas \</span><br><span class="line">-p 8443:8443 \</span><br><span class="line">-v $(pwd)/keystore.jks:/etc/cas/thekeystore \</span><br><span class="line">-v $(pwd)/Pointservice-10000002.json:/etc/cas/services/Pointservice-10000002.json \</span><br><span class="line">-v $(pwd)/cas.properties:/etc/cas/config/cas.properties \</span><br><span class="line">-e TZ=Asia/Shanghai \</span><br><span class="line">apereo/cas:6.5.5</span><br></pre></td></tr></table></figure><h2 id="登录测试"><a href="#登录测试" class="headerlink" title="登录测试"></a>登录测试</h2><p>访问 <a href="https://localhost:8443/cas/login?service=https://localhost:8080">https://localhost:8443/cas/login?service=https://localhost:8080</a><br>输入</p><ul><li>用户名: casuser</li><li>密码: Mellon</li></ul>]]></content>
    
    
    <summary type="html">CAS单点登录测试环境配置.</summary>
    
    
    
    
    <category term="CAS" scheme="http://tanqidong1992.github.io/tags/CAS/"/>
    
    <category term="测试" scheme="http://tanqidong1992.github.io/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring Cloud配置服务</title>
    <link href="http://tanqidong1992.github.io/2022/05/17/2022/08/spring-config-server/"/>
    <id>http://tanqidong1992.github.io/2022/05/17/2022/08/spring-config-server/</id>
    <published>2022-05-17T02:15:33.000Z</published>
    <updated>2023-02-13T13:30:14.120Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Cloud配置服务"><a href="#Spring-Cloud配置服务" class="headerlink" title="Spring Cloud配置服务"></a>Spring Cloud配置服务</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>2019年项目启动初,由于时间节点非常紧迫,也没有看到引入配置服务的好处,我们没有引入配置服务.这导致了各个服务的配置文件存在大量重复内容,不便于维护.我们在部署的时候,通过容器环境变量以及Docker Compose本身引用环境变量进行配置(当时采用Docker Compose部署),解决了对各个服务的集中配置问题.2020年上半年开发了服务配置模块,但是各个服务没有集成.</p><p>2021年底,系统需要适配信创环境,不能部署在Docker容器中,只能通过RPM包的形式安装部署到物理机上.由于RPM包安装时不能指定安装参数,信创环境对程序包有严格要求,我们通过Maven插件的方式在系统编译过程中为不同项目注入不同配置参数,结合Systemd的环境变量配置,解决了系统统一配置问题,但是也导致不同实施项目需要特制的安装包.</p><h2 id="为何引入"><a href="#为何引入" class="headerlink" title="为何引入"></a>为何引入</h2><ul><li>解决了服务配置文件冗余,提高系统的可维护性.</li><li>信创环境,相同架构下可以共享部分安装包.</li><li>集中管理服务配置文件,可拓展GUI方式配置服务.</li><li>仅仅是改变服务配置文件读取方式,对系统改动不大.</li></ul><h2 id="不利影响"><a href="#不利影响" class="headerlink" title="不利影响"></a>不利影响</h2><ul><li>服务本地调试开发,不能直接看到服务配置文件.</li><li>各个服务依赖于配置服务模块.</li></ul><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><h3 id="配置文件设计"><a href="#配置文件设计" class="headerlink" title="配置文件设计"></a>配置文件设计</h3><h4 id="Spring配置文件"><a href="#Spring配置文件" class="headerlink" title="Spring配置文件"></a>Spring配置文件</h4><p>我们对Spring配置文件根据运行环境,配置所属功能进行拆分,对公共配置进行提取,形成了模块化的配置文件,如下图所示.</p><p><img src="http://tanqidong1992.github.io/2022/05/17/2022/08/spring-config-server/d4fe534a62ca8de020a61f03aca1b3f5c522b23f04672ed559accb8396f37d0c.svg"></p><h4 id="普通配置文件"><a href="#普通配置文件" class="headerlink" title="普通配置文件"></a>普通配置文件</h4><p>我们对普通配置文件根据运行环境进行划分,服务实例可根据运行环境加载特定运行环境的普通配置文件.</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><h4 id="配置服务的安全性"><a href="#配置服务的安全性" class="headerlink" title="配置服务的安全性"></a>配置服务的安全性</h4><p>待实现.</p><h4 id="配置项加密"><a href="#配置项加密" class="headerlink" title="配置项加密"></a>配置项加密</h4><p>待实现.</p><h4 id="秘钥管理"><a href="#秘钥管理" class="headerlink" title="秘钥管理"></a>秘钥管理</h4><p>待实现.</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>配置服务基于Spring Cloud Config Server实现,采用文件系统作为存储后端.<br>配置参考</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">$&#123;APPLICATION_NAME:config-server&#125;</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">native:</span></span><br><span class="line"><span class="attr">search-locations:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">file:repo</span></span><br><span class="line"><span class="attr">bootstrap:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">native</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">client:</span></span><br><span class="line"><span class="attr">service-url:</span></span><br><span class="line"><span class="attr">defaultZone:</span> <span class="string">$&#123;REGISTER_CENTER:http://localhost:12331/eureka&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">dev</span>   </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">profiles:</span> <span class="string">prod</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">instance:</span></span><br><span class="line"><span class="attr">prefer-ip-address:</span> <span class="literal">true</span>  </span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>客户端引入Spring Cloud Config接入配置服务.<br>配置参考</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">application:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">profiles:</span></span><br><span class="line"><span class="attr">active:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">eureka</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">db</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">druid</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">kafka</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"><span class="attr">cloud:</span></span><br><span class="line"><span class="attr">config:</span></span><br><span class="line"><span class="attr">uri:</span> <span class="string">$&#123;CONFIG_SERVER:http://localhost:12333&#125;</span></span><br><span class="line"><span class="attr">logging:</span> </span><br><span class="line"><span class="attr">config:</span> <span class="string">$&#123;spring.cloud.config.uri&#125;/$&#123;spring.application.name&#125;/$&#123;spring.profiles.active[0]&#125;/main/log4j2.xml</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="如何集成新的服务"><a href="#如何集成新的服务" class="headerlink" title="如何集成新的服务"></a>如何集成新的服务</h2><h3 id="配置服务端"><a href="#配置服务端" class="headerlink" title="配置服务端"></a>配置服务端</h3><ol><li>在配置文件仓库中,新建一个文件夹(名称与待接入服务名称保持一致${spring.application.name}),用于保存待接入服务的配置文件,将该文件夹加入到配置服务配置文件搜索路径列表中.</li><li>将待接入服务的配置文件保存到给目录下,服务公共配置文件的名称须与服务名称保持一致,为${spring.application.name}.yml,特定运行环境的配置文件命名必须为${spring.application.name}-${profile}.yml,当然你也可以使用一个内部分区的文件保存所有运行环境的配置.</li><li>将服务配置文件中的公共部分剔除掉,仅保留服务特有的配置项即可.</li></ol><h3 id="配置客户端配置"><a href="#配置客户端配置" class="headerlink" title="配置客户端配置"></a>配置客户端配置</h3><ol><li>加入Spring Cloud Config依赖项</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>删除以前的配置文件,新建bootstrap.yml配置文件,内容参考,客户端的配置文件.</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li>对于普通配置文件,其路径需要改成URI网络路径.</li><li>客户端的spring.profiles.active配置项的第一项必须是指定运行环境,其他组合项,根据服务的实际需要进行配置.</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1.<a href="https://docs.spring.io/spring-cloud-config/docs/current/reference/html/">Spring Cloud Config Reference</a></p>]]></content>
    
    
    <summary type="html">Spring Cloud配置服务.</summary>
    
    
    
    
    <category term="Spring" scheme="http://tanqidong1992.github.io/tags/Spring/"/>
    
    <category term="配置服务" scheme="http://tanqidong1992.github.io/tags/%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Fedora下RPM包制作</title>
    <link href="http://tanqidong1992.github.io/2021/12/28/2021/12/28/rpm/"/>
    <id>http://tanqidong1992.github.io/2021/12/28/2021/12/28/rpm/</id>
    <published>2021-12-28T15:14:33.000Z</published>
    <updated>2023-02-13T13:30:14.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Fedora下RPM包制作"><a href="#Fedora下RPM包制作" class="headerlink" title="Fedora下RPM包制作"></a>Fedora下RPM包制作</h1><h2 id="RPM术语"><a href="#RPM术语" class="headerlink" title="RPM术语"></a>RPM术语</h2><h3 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h3><p>RPM包管理器被Fedora,Red Hat Enterprise Linux,Mageia,OpenSUSE以及其他Linux发行版本使用.最初RPM代表”Red Hat Package Manager”,<br>然而现在它是一个递归的缩写”RPM Package Manager”.</p><h3 id="规格文件"><a href="#规格文件" class="headerlink" title="规格文件"></a>规格文件</h3><p>一个纯文本文件,包含了包的信息以及RPM用来编译包中软件的指令.使用包的名字+后缀”.spec”作为这个文件的名字.</p><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>一个字符串,通常大写,后接一个冒号,位于规格文件的顶部,用来提供一些有关RPM包的重要数据,例如Name:,Version:,Summary:.</p><h3 id="节"><a href="#节" class="headerlink" title="节"></a>节</h3><p>规格文件中的一段,告诉RPM如何执行包构造过程的某些部分.绝大部分节包含只传递给Shell的代码,虽然这一方面RPM极具灵活性,但超出本文的范围,不多阐述.</p><h3 id="节头"><a href="#节头" class="headerlink" title="节头"></a>节头</h3><p>一个短字符串,在行首以%开头,用于引入节.例如:%description,%prep,%files.</p><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><p>一个短字符串,以’%’作为前缀,,通常以花括号包”{}”围起来,RPM将其转化为一个不同的,通常更长的字符串.有些宏可以接受参数,有些参数非常复杂.有些宏由RPM提供,有些是redhat-rpm-config以及fedora-rpm-macros包的一部分,其他的包也提供宏.你可以使用rpm –showrc 来查看当前系统中所有可用的宏,但是你不需要去运行绝不大部分你看到的宏.</p><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>用于在自己的Fedora安装中本地构建RPM的系统,这就避免需要在你的操作系统中安装构建所需的所有依赖,同时也允许你为不同版本的Fedora构建包.</p><h3 id="koji"><a href="#koji" class="headerlink" title="koji"></a>koji</h3><p>主要的Fedora构建系统.</p><h2 id="准备你的系统进行RPM包创建"><a href="#准备你的系统进行RPM包创建" class="headerlink" title="准备你的系统进行RPM包创建"></a>准备你的系统进行RPM包创建</h2><h3 id="安装必要的构建工具"><a href="#安装必要的构建工具" class="headerlink" title="安装必要的构建工具"></a>安装必要的构建工具</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo dnf install fedora-packager fedora-review</span><br></pre></td></tr></table></figure><h3 id="准备模拟环境"><a href="#准备模拟环境" class="headerlink" title="准备模拟环境"></a>准备模拟环境</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd packager</span><br><span class="line">sudo usermod -a -G mock packager</span><br><span class="line">su packager</span><br></pre></td></tr></table></figure><h3 id="准备源代码"><a href="#准备源代码" class="headerlink" title="准备源代码"></a>准备源代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/workspaces/hello</span><br><span class="line">cd ~/workspaces/hello</span><br><span class="line">cat &lt;&lt; EOF &gt; hello.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">printf &quot;Hello!\n&quot;</span><br><span class="line">EOF</span><br><span class="line">chmod 644 hello.sh</span><br></pre></td></tr></table></figure><h3 id="准备规格文件hello-spec"><a href="#准备规格文件hello-spec" class="headerlink" title="准备规格文件hello.spec"></a>准备规格文件hello.spec</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Name: hello</span><br><span class="line">Version: 1</span><br><span class="line">Release: 1%&#123;?dist&#125;</span><br><span class="line">Summary: Say Hello, Texas style</span><br><span class="line"></span><br><span class="line">License: Public Domain</span><br><span class="line">Source0: hello.sh</span><br><span class="line">BuildArch: noarch</span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line">A simple program to greet the user Texas style</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">mkdir -p %&#123;buildroot&#125;%&#123;_bindir&#125;</span><br><span class="line">install -p -m 755 %&#123;SOURCE0&#125; %&#123;buildroot&#125;%&#123;_bindir&#125;</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%&#123;_bindir&#125;/hello.sh</span><br><span class="line"></span><br><span class="line">%changelog</span><br></pre></td></tr></table></figure><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fedpkg --release f35 local</span><br></pre></td></tr></table></figure><h3 id="检查构建的RPM包"><a href="#检查构建的RPM包" class="headerlink" title="检查构建的RPM包"></a>检查构建的RPM包</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fedpkg --release f35 lint</span><br></pre></td></tr></table></figure><h3 id="查看依赖列表"><a href="#查看依赖列表" class="headerlink" title="查看依赖列表"></a>查看依赖列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rpm -qp --requires noarch/hello-1-1.fc35.noarch.rpm </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">/usr/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpmlib(CompressedFileNames) &lt;= 3.0.4-1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpmlib(FileDigests) &lt;= 4.6.0-1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpmlib(PayloadFilesHavePrefix) &lt;= 4.0-1</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">rpmlib(PayloadIsZstd) &lt;= 5.4.18-1</span></span><br></pre></td></tr></table></figure><h3 id="查看提供列表"><a href="#查看提供列表" class="headerlink" title="查看提供列表"></a>查看提供列表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[packager@fedora hello]$ rpm -qp --provides noarch/hello-1-1.fc35.noarch.rpm </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">hello = 1-1.fc35</span></span><br></pre></td></tr></table></figure><h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo rmp -i x86_64/hello-1-1.fc35.x86_64.rpm</span><br><span class="line">hello.sh</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">Hello!</span></span><br></pre></td></tr></table></figure><h2 id="规格文件概述-部分"><a href="#规格文件概述-部分" class="headerlink" title="规格文件概述(部分)"></a>规格文件概述(部分)</h2><ul><li>Name<br>  包的名称,必须与规格文件保持一直,遵从包命名指南,使用小写字符命名文件.</li><li>Version<br>  上游版本号,如果版本中包含非数字字符,那么Release标签中也可能需要添加非数字字符.</li><li>Release<br>  版本发布,初始值设置为1%{?dist},增加其中的数字,当有同一个版本的新包发布时.当版本改变后,重置发布数字为1.参考版本指南.</li><li>Summary<br>  输入一行软件包的简短单行摘要,<del>使用美式英语</del>,不要以句号结束.</li><li>Group<br>  这个标签自Fedora 17被标记为抛弃,参考<a href="https://docs-old.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/Packagers_Guide/chap-Packagers_Guide-Spec_File_Reference-Preamble.html">Spec File Reference Preamble</a></li><li>License<br>  开源软件许可证</li><li>URL<br>  有关此程序的详细信息,请参阅此URL.</li><li>Source0<br>  原始代码压缩归档文件的全路径,这个全路径的基本名称,将会被用于在SOURCES目录中搜索,如果有更多的源码,请使用Source1,Source2…</li><li>Patch0<br>  补丁文件路径</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.fedoraproject.org/jp/quick-docs/creating-rpm-packages/">Creating RPM packages</a></li><li><a href="https://fedoraproject.org/wiki/How_to_create_a_GNU_Hello_RPM_package/zh-cn">How to create a GNU Hello RPM package</a></li><li><a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Naming/">Package Naming Guidelines</a></li><li><a href="https://docs.fedoraproject.org/en-US/packaging-guidelines/Versioning/">Versioning Guide</a></li></ol>]]></content>
    
    
    <summary type="html">Fedora下RPM包制作.</summary>
    
    
    
    
    <category term="Fedora" scheme="http://tanqidong1992.github.io/tags/Fedora/"/>
    
    <category term="RPM" scheme="http://tanqidong1992.github.io/tags/RPM/"/>
    
    <category term="Package" scheme="http://tanqidong1992.github.io/tags/Package/"/>
    
  </entry>
  
  <entry>
    <title>Modbus</title>
    <link href="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/"/>
    <id>http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/</id>
    <published>2021-09-02T13:51:33.000Z</published>
    <updated>2023-02-13T13:30:14.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Modbus是一个位于应用层的消息传递协议,位于OSI模型第七层.它为连接在不同总线或者网络上的设备之间提供客户端&#x2F;服务器通信.</p><p>自1979年以来,Modbus一直是业界公认的串行标准,至今仍在为数以百万计的自动化设备提供通信服务.</p><p>Modbus是一种请求应答协议,提供功能代码(Function Code)指定的服务.</p><p>目前它主要基于以下几种媒介实现:</p><ul><li>TCP&#x2F;IP over Ethernet.</li><li>Asynchronized serial transmission over a variety of media(EIA&#x2F;TIA-232-E(RS-232),EIA-422,EIA&#x2F;TIA-485-A(RS-485),光纤,无线广播等).</li><li>Modbus PLUS,高速令牌传递网络.<br>  备注: Modbus在TCP&#x2F;IP协议栈上的保留端口为502.</li></ul><h2 id="Modbus通信协议栈"><a href="#Modbus通信协议栈" class="headerlink" title="Modbus通信协议栈"></a>Modbus通信协议栈</h2><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/13c1589682ee03c3f75e7d1bad2d648814404ea831a04a5b79844e3083235421.png"></p><h2 id="Modbus网络架构"><a href="#Modbus网络架构" class="headerlink" title="Modbus网络架构"></a>Modbus网络架构</h2><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/16f17ef21174125f87a87742bdc0505306493e192057aa0662ad440dc5f87fd8.png"></p><h2 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h2><h3 id="协议组成"><a href="#协议组成" class="headerlink" title="协议组成"></a>协议组成</h3><p>Modbus定义了一个简单,独立于通信层的协议数据单元(PDU).Modbus协议在特定总线或者网络上的实现,可以在应用数据单元(ADU)中引入额外的字段.一般的Modbus数据帧如下图所示:</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/50c74b7c1aff238ec130f2da8fe1ddb6ca022847605320ebaf0aff3015c855d2.png"></p><h4 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h4><p>PDU由功能码(Function Code)，数据组成：</p><ul><li>功能码指明了服务器应该执行何种操作.它被编码为1个字节,取值范围为[1,255]的整数(其中128-255被保留,作为异常码使用),<strong>在一些功能码中添加子功能码(子功能代码位于数据字段内),可以为一个功能码定义多个操作.</strong></li><li>数据是客户端传递给服务端为执行执行功能码指定操作的附带信息,可以是离散地址,寄存器地址,要处理项的数量等.在某些类型的请求中,数据字段可能不存在.</li></ul><p>PDU的最大值为256字节,这个最大值受限于第一个modbus在串口网络的实现(max RS485 ADU &#x3D; 256 bytes)</p><p>因此:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modbus PDU for serial line communication = 256 - Server address (1 byte) - CRC(2 bytes) = 253 bytes</span><br></pre></td></tr></table></figure><p>故而</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RS232/RS485 ADU = 253 + Server Address (1 byte) + CRC (2 bytes) = 256 bytes</span><br><span class="line">TCP Modbus ADU = 253 bytes + MBAP( 7 bytes ) = 260 bytes</span><br></pre></td></tr></table></figure><p>Modbus 一共定义了三种PDU</p><ul><li>Modbus Request PDU, mb_req_pdu.</li><li>Modbus Response PDU, mb_rsp_pdu.</li><li>Modbus Exception Response PDU, md_excep_rsp_pdu.</li></ul><h5 id="Modbus-Request-PDU"><a href="#Modbus-Request-PDU" class="headerlink" title="Modbus Request PDU"></a>Modbus Request PDU</h5><p>由功能码 + 请求数据组成:<br>功能码: 1个字节,<br>请求数据: n个字节,可取值:变量引用,变量数量,数据偏移,子功能代码等.</p><h5 id="Modbus-Response-PDU"><a href="#Modbus-Response-PDU" class="headerlink" title="Modbus Response PDU"></a>Modbus Response PDU</h5><p>由功能码 + 响应数据组成:<br>功能码: 1个字节,<br>响应数据: n个字节,可取值:变量引用,变量数量,数据偏移,子功能代码等.</p><h5 id="Modbus-Exception-Response-PDU"><a href="#Modbus-Exception-Response-PDU" class="headerlink" title="Modbus Exception Response PDU"></a>Modbus Exception Response PDU</h5><p>由异常功能码 + 请求数据组成:<br>异常代码: 1个字节,是功能代码+0x80.</p><h4 id="ADU"><a href="#ADU" class="headerlink" title="ADU"></a>ADU</h4><h5 id="ADU-Modbus-Frame-with-Serial-Transmission"><a href="#ADU-Modbus-Frame-with-Serial-Transmission" class="headerlink" title="ADU(Modbus Frame with Serial Transmission)"></a>ADU(Modbus Frame with Serial Transmission)</h5><p>基于串口通信的ADU由设备地址(1 bytes),PDU(253 bytes),错误校验组成(2 bytes).</p><h5 id="ADU-Modbus-Frame-With-TCP-x2F-IP-Transmission"><a href="#ADU-Modbus-Frame-With-TCP-x2F-IP-Transmission" class="headerlink" title="ADU(Modbus Frame With TCP&#x2F;IP Transmission)"></a>ADU(Modbus Frame With TCP&#x2F;IP Transmission)</h5><p>基于TCP&#x2F;IP实现的ADU由MBAP(7 bytes),PDU(253 bytes)组成.<br>MBAP由事务标识符,协议标识符,长度,单位标识符组成,如下图所示:</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/9455a09929f72233e465759915ee7948627087c5b82795e7dab873f2ebb7bd7e.png">- 事务标识符,用于事务匹配,服务器在响应中复制客户端请求中的值.如果客户端在每次查询时生成唯一的表示符,则可以为此查询分配唯一的响应.</p><ul><li>协议标识符,由于使用Modbus协议,因此此字段始终为0.</li><li>长度,数据长度,包括单位标识符(1 byte),函数代码(1 byte)和数据.</li><li>单位标识符,对应基于串口通信的Modbus协议ADU中的设备地址.此字段用于内部系统路由,如果控制器不支持路由,此字段始终为0.</li></ul><p>备注:由于TCP&#x2F;IP数据链路层的校验机制保证了数据的完整性,因此Modbus TCP的报文中不再带有数据校验.</p><h3 id="数据编码字节序"><a href="#数据编码字节序" class="headerlink" title="数据编码字节序"></a>数据编码字节序</h3><p>Modbus协议在发送数据时,采用与网络一样大端字节序发送数据,首先发送MSB.</p><h3 id="Modbus数据模型"><a href="#Modbus数据模型" class="headerlink" title="Modbus数据模型"></a>Modbus数据模型</h3><table><thead><tr><th align="left">基本表</th><th align="left">对象类型</th><th align="left">访问类型</th><th align="left">注释</th></tr></thead><tbody><tr><td align="left">离散量输入</td><td align="left">单个位</td><td align="left">只读</td><td align="left">I&#x2F;O系统可提供这种类型的数据</td></tr><tr><td align="left">线圈</td><td align="left">单个位</td><td align="left">读写</td><td align="left">通过应用程序可以改变这种类型的数据</td></tr><tr><td align="left">输入寄存器</td><td align="left">16位 字</td><td align="left">只读</td><td align="left">I&#x2F;O系统可提供这种类型的数据</td></tr><tr><td align="left">保持寄存器</td><td align="left">16位 字</td><td align="left">读写</td><td align="left">通过应用程序可以改变这种类型数据</td></tr></tbody></table><p>对于每一个基本表,协议都允许单个地选择65535个数据项.</p><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><p>设备组织数据的方法有很多种,每个设备根据其应用都有自己的组织数据的方法.</p><ol><li>示例1,含有四个独立块的设备</li></ol><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/0b8463c4bd849a2e69007ade2c98e3c1cf04cb30e193321e5fbc8c6908212be0.png">2. 示例2,含有单个独立块的设备</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/92551356980e4ac382c52bb769f792f81cd0e260df5d253c68164ae7d2764ba9.png"></p><h3 id="Modbus寻址模型"><a href="#Modbus寻址模型" class="headerlink" title="Modbus寻址模型"></a>Modbus寻址模型</h3><p>Modbus应用协议精确地定义了PDU寻址规则.<br>在Modbu PDU中,从0<del>65535寻址每一个数据.<br>Modbus应用协议明确地规定了由四个块构成的Modbus数据模型,每个块由几个编号为1</del>n的元素构成.<br>在Modbus数据模型中,从1~n来编号每一个元素.<br>Modbus数据模型和设备应用之间的映射完全与特定设备无关.</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/8f0ab1d31267153dff431af3b82d1274448c3343bc6e50118a028780600e80d0.png"></p><h3 id="Modbus事务定义"><a href="#Modbus事务定义" class="headerlink" title="Modbus事务定义"></a>Modbus事务定义</h3><p>如图所示描述了在服务侧Modbus事务处理的一般处理流程</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/efc2e1c2b08517a33cf1269b58fa432e46d19f4e848dc734779f438f4936fe2d.png"></p><p>一旦服务器处理请求,就必须使用相应的Modbus服务器事务处理生成Modbus响应.<br>根据处理结果,可以建立两种类型响应:</p><ol><li>一个正常的Modbus响应:响应功能码&#x3D;请求功能码</li><li>一个异常的Modbus响应:异常功能码&#x3D;请求功能码 + 0x80<br>用来为客户机提供处理过程中与所发现的差错相关的信息,提供异常码来表示发生差错的原因.</li></ol><h2 id="功能码类别"><a href="#功能码类别" class="headerlink" title="功能码类别"></a>功能码类别</h2><p>共有三类Modbus功能码,分为为:公共功能码,用户自定义功能码,保留功能码.它们的分布如下:</p><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/7d0c7f513bb19748d4874f4a7a22fabf1ef654a1bde7957a7e650c1911f655df.png"></p><h3 id="公共功能码"><a href="#公共功能码" class="headerlink" title="公共功能码"></a>公共功能码</h3><ol><li>被确切定义的功能码.</li><li>保证是唯一的.</li><li>由MODBUS.org组织验证.</li><li>公开文档.</li><li>可进行一致性测试.</li><li>包含已被定义的公共功能码和保留给未来使用的功能码.</li></ol><h3 id="用户自定义功能码"><a href="#用户自定义功能码" class="headerlink" title="用户自定义功能码"></a>用户自定义功能码</h3><ol><li>共有两个用户自定义功能码区域,即十进制的65-72,100-110.</li><li>用户无需Modbus组织的任何批准就可以选择和实现一个功能码.</li><li>不能保证被选用的功能码的使用是唯一的.</li><li>如果用户希望将某种功能设置为一个公共功能码,那么用户必须启动RFC,以便将这种变更引入公共分类中,并且指配一个新的公共功能码.</li></ol><h3 id="保留功能码"><a href="#保留功能码" class="headerlink" title="保留功能码"></a>保留功能码</h3><p>某些公司在传统产品上先行使用的功能码,不作为公共使用.</p><h2 id="公共功能码定义"><a href="#公共功能码定义" class="headerlink" title="公共功能码定义"></a>公共功能码定义</h2><p><img src="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/public-function-codes.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf">Modbus_Application_Protocol_V1_1b3</a></li><li><a href="http://www.ad.siemens.com.cn/productportal/Prods/published/Comm/Comm_9.1/Comm_9.1.html">Modbus TCP通信概述</a></li><li><a href="https://en.nanotec.com/products/manual/PD4E_ModbusTCP_ZH/bus%2Fmodbus%2Fmbap_header.html">技术手册 PD4-E MODBUS TCP</a></li></ol>]]></content>
    
    
    <summary type="html">Modbus协议.</summary>
    
    
    
    
    <category term="Modbus" scheme="http://tanqidong1992.github.io/tags/Modbus/"/>
    
    <category term="IOT" scheme="http://tanqidong1992.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg入门学习</title>
    <link href="http://tanqidong1992.github.io/2021/07/02/2021/07/02/introduction-of-ffmpeg/"/>
    <id>http://tanqidong1992.github.io/2021/07/02/2021/07/02/introduction-of-ffmpeg/</id>
    <published>2021-07-02T15:23:12.000Z</published>
    <updated>2023-02-13T13:30:14.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg入门学习"><a href="#FFmpeg入门学习" class="headerlink" title="FFmpeg入门学习"></a>FFmpeg入门学习</h1><h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>这些天一直加班,把心情都加没了,只能写写代码来改善一下心情.流媒体一直是公司项目中最难啃的骨头,恰好上次找到一本好书&lt;&lt;FFmpeg从入门到精通&gt;&gt;,最近常跟同事聊起流媒体相关内容,我因此决定去探索一番.</p><h2 id="FFmpeg组成"><a href="#FFmpeg组成" class="headerlink" title="FFmpeg组成"></a>FFmpeg组成</h2><p>FFmpeg框架主要由AVFormat,AVCodec,AVFilter,AVDevice,AVUtil模块组成.</p><h3 id="AVFormat"><a href="#AVFormat" class="headerlink" title="AVFormat"></a>AVFormat</h3><p>AVFormat实现了目前主流多媒体封装格式,包括封装和解封装.比如常见的文件封装格式:MP4,FLV,KV,TS,网络封装格式:RTMP,RTSP,MMS,HLS.<br>备注:FFmpeg支持媒体封装格式拓展,用户可以自定义自己的媒体封装格式拓展.</p><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>AVCodec实现了目前主流的多媒体编解码格式,包括MPEG4,AAC,MJPEG,H.264(AVC),H.265(HEVC).用户可以扩展以支持自己的编码格式.</p><h3 id="AVFilter"><a href="#AVFilter" class="headerlink" title="AVFilter"></a>AVFilter</h3><p>AVFilter提供了一个通用的音频,视频,字幕等滤镜处理框架,该框架支持多个输入流,多个输出流以及流分割.FFmpeg内置多种滤镜.</p><h3 id="Swscale"><a href="#Swscale" class="headerlink" title="Swscale"></a>Swscale</h3><p>swsample提供了高级别的图像转化API.</p><h3 id="swresample"><a href="#swresample" class="headerlink" title="swresample"></a>swresample</h3><p>swresample提供了高级别的音频重采样API.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://ffmpeg.org/">FFmpeg官网</a></li><li><a href="https://ffmpeg.org/ffmpeg-filters.html">FFmpeg Filters Documentation</a></li><li><a href="https://github.com/tanqidong1992/audio-video-learn">学习过程中编写的代码Java</a></li></ol>]]></content>
    
    
    <summary type="html">FFmpeg简介.</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="FFmpeg" scheme="http://tanqidong1992.github.io/tags/FFmpeg/"/>
    
    <category term="音视频" scheme="http://tanqidong1992.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="http://tanqidong1992.github.io/2021/06/15/2021/06/15/algorithms-of-garbage-collector/"/>
    <id>http://tanqidong1992.github.io/2021/06/15/2021/06/15/algorithms-of-garbage-collector/</id>
    <published>2021-06-14T16:23:12.000Z</published>
    <updated>2023-02-13T13:30:14.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="Throughput收集器"><a href="#Throughput收集器" class="headerlink" title="Throughput收集器"></a>Throughput收集器</h2><p>Throughput收集器有两个基本的操作:</p><ul><li>回收新生代的垃圾</li><li>回收老年代的垃圾</li></ul><h3 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h3><p>通常新生代垃圾回收发生在Eden空间快用尽的时候,新生代垃圾收集会把Eden空间的所有对象挪走,一部分会被移动到Survivor空间,其他的会被移动到老年代.</p><h3 id="老年代垃圾回收"><a href="#老年代垃圾回收" class="headerlink" title="老年代垃圾回收"></a>老年代垃圾回收</h3><p>老年代垃圾收集会回收新生代中所有对象(包括Survivor空间中的对象),只有那些活跃引用的对象,或者已经经过压缩整理的对象会在老年代中继续保留,其余对象都会被回收.<br><strong>备注:永久代中的对象不会被Full GC回收,除非永久代的空间被耗尽,JVM会发起Full GC回收<br>永久代中的对象.</strong></p><p>小结:Throughput收集器会进行两种操作,分别是Full GC和Minor GC;通过GC日志中的时间输出,我们可以迅速地判断出Throughput收集器的GC操作对应用程序总体性能影响.</p><h3 id="堆大小的自适应调整和静态调整"><a href="#堆大小的自适应调整和静态调整" class="headerlink" title="堆大小的自适应调整和静态调整"></a>堆大小的自适应调整和静态调整</h3><p>Throughput收集器的调优几乎是围绕停顿时间进行,寻求堆的总大小,新生代的大小以及老年代大小之间的平衡.</p><p>调优时有两种取舍:一是编程技术上时间与空间的取舍,二是与完成垃圾回收所需的时长相关,增大堆可以减少GC停顿发生的频率,但GC的时长会变长,平均响应时间也会变长;同理给新生代分配更多的空间可以缩短Full GC的时长,不过会增加Full GC的频率.</p><p>为了达到停顿时间的指标,Throughput收集器的自适应调整会重新分配堆(以及代)的大小,自适应调优标志如下:</p><ul><li>-XX:MaxGCPauseMillis&#x3D;N 最大停顿时长</li><li>-XX:GCTimeRatio&#x3D;N 设置应用程序在垃圾回收上花费的多少时间,计算公式如下:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThroughputGoal = 1 - 1/(1+GCTimeRatio)</span><br></pre></td></tr></table></figure><p>GCTimeRatio初始值为99,计算出ThroughputGoal的值为0.99,意味着99%的时间用于应用程序,1%的时间用于垃圾回收.</p><p>JVM使用这两个标志在堆的初始值(-Xms)和最大值(-Xmx)之间设置堆大小.MaxGCPauseMillis的优先级最高,如果设置了,新生代和老年代会随之进行调整,直到满足对应的停顿目标,一旦目标达成,堆的总容量就开始逐渐增大,直到运行时间的比率达到设定值.这两个目标达成后,JVM会尝试缩小堆的大小,尽可能以最小的堆大小来满足这两个目标.</p><p>由于默认情况下不设置停顿时间目标,通常自动调整的效果是堆的大小会持续增大,直到满足设置的GCTimeRatio目标.不过,在实际操作中,该标志的默认值已经相当优化了.</p><p>一般应用程序在垃圾回收的消耗为总时间的3%-6%效果是相当不错的.不过在内存受限的环境下,这些应用程序一般会在垃圾回收上消耗总时间10%-15%的时间,垃圾回收对这些应用程序的性能影响巨大,不过整体性能目标还是能够达到的.根据应用程序的性能目标,最佳配置也有所不同.</p><p><strong>小结:采用动态调整是进行堆调优极好的入手点,对很多应用程序而言,采用动态调整已经足够,动态调整的配置能够有效地减少JVM的内存使用;静态地设置堆的大小也可能获得最优的性能.设置合理的性能目标,让JVM根据设置确定堆的大小是学习这种调优很好的入门.</strong></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS收集器有三种基本操作:</p><ul><li>对新生代进行垃圾回收.</li><li>并发回收(启动一个并发线程对老年代空间的垃圾进行回收).</li><li>如有必要,发起Full GC.</li></ul><h3 id="对新生代进行垃圾回收"><a href="#对新生代进行垃圾回收" class="headerlink" title="对新生代进行垃圾回收"></a>对新生代进行垃圾回收</h3><p>CMS收集器的新生代垃圾回收与Throughput收集器的新生代垃圾回收非常相似:存活对象从Eden空间移动到Survivor空间,或者移动到老年代空间.</p><h3 id="并发回收"><a href="#并发回收" class="headerlink" title="并发回收"></a>并发回收</h3><p>CMS会根据堆的使用情况启动并发回收.当堆的占用达到某一个程度时,JVM启动后台线程扫描堆,回收不用的对象.<br><strong>注意:并发回收,并不会对老年代的空间进行压缩整理.</strong><br>并发回收的阶段</p><ol><li>初始标记阶段: 找到堆中所有垃圾回收根节点对象.应用程序线程被暂停</li><li>并发标记阶段: 应用程序继续运行,不会被中断.</li><li>并发预清理阶段 .</li><li>可中断预清理阶段</li><li>重新标记阶段. 应用程序线程被暂停</li><li>并发清除阶段.</li><li>并发重置阶段.</li></ol><p><strong>备注:重新标记阶段需要暂停应用线程,如果新生代收集刚刚结束,紧接着就是一个交际阶段的话,应用线程会遭遇两次连续停顿,CMS为了避免这种情况,因此引入可中断预清理阶段,目的就是缩短停顿的长度,避免连续的停顿.因此,可中断预清理阶段会等到新生代占到50%左右才开始,给了CMS收集器最好的机会避免发生连续停顿.</strong></p><h3 id="CMS-Full-GC"><a href="#CMS-Full-GC" class="headerlink" title="CMS Full GC"></a>CMS Full GC</h3><p>触发Full GC的原因</p><ul><li>并发模式失败: 当新生代垃圾回收完成,同时老年代没有足够的空间容纳晋升的对象.</li><li>晋升失败: 当新生代垃圾回收完成,老年代有足够的空间容纳晋升的对象,但是由于空闲空间碎片化,导致晋升失败.</li><li>永久代(元空间)用尽,</li></ul><p>并发模式导致的Full GC,仅需要回收堆内的无用对象,而晋升失败导致的Full GC需要对整个老年代空间进行整理和压缩,时间远远大于前者,压缩整理后就像Throughput收集器昨晚Full GC后,新生代完全空闲,老年代空间也已经整理过.</p><p><strong>备注:默认情况下,CMS收集器不会对永久代(元空间)进行收集,但是它一旦用尽,那就需要进行Full GC.</strong></p><p><strong>小结:CMS垃圾回收有多个操作,但是最期望发生的是Minor GC和并发回收;CMS收集过程中的并发模式失效以及晋升失败的代价都非常大,我们需要调优以避免这种情况;默认情况下,CMS不会对老年代(元空间)进行回收.</strong></p><h3 id="对并发模式失败的调优"><a href="#对并发模式失败的调优" class="headerlink" title="对并发模式失败的调优"></a>对并发模式失败的调优</h3><p>调优CMS收集器最重要的工作是避免发生并发模式失效以及晋升失败.<br>并发模式失效往往是由于CMS不能足够快的清理老年代空间,新生代需要垃圾回收时,CMS收集器计算发现老年代没有足够的空闲空间可以容纳这些晋升对象,不得不先对老年代进行垃圾回收.</p><p>初始时老年代空间的对象时一个接一个整齐有序排列的.当老年代的占用带到某个程度(默认70%)时,并发回收开始.一个CMS后台线程开始回收老年代空间,寻找无用的垃圾对象时,竞争就开始了:CMS必须在老年代剩余的空间(30%)用尽之前,完成老年代空间的扫描以及回收工作.如果并发回收在这场速度竞争中失败,CMS收集器就会发生并发模式失效.</p><p>以下途径可以避免发生这种失效:</p><ul><li>增大老年代空间,要么只移动部分新生代对象到老年代,要么增加堆空间.</li><li>以更高的频率运行后台回收线程.</li><li>使用更多的后台线程.</li></ul><p>如果有足够多的内存,更好的方案是增加堆的大小,否则尝试调整后台线程来解决这个问题.</p><h4 id="给后台线程更多的运行机会"><a href="#给后台线程更多的运行机会" class="headerlink" title="给后台线程更多的运行机会"></a>给后台线程更多的运行机会</h4><p>更早的启动并发周期,设置两个参数:-XX:CMSInitiatingOccupancyFraction&#x3D;N和-XX:+UseCMSInitiatingOccupancyOnly,同时设置这两个标志,CMS就只根据设置的老年代空间占比率来决定何时启动后台线程.默认情况下UseCMSInitiatingOccupancyOnly标志为假,CMS会根据复杂算法判断何时启动并行收集线程.如有必要提前启动后台线程,推荐使用最简单的方法,将UseCMSInitiatingOccupancyOnly标志为真</p><p>CMSInitiatingOccupancyFraction参数的值的调整可能需要多次迭代才能确定.如果开启UseCMSInitiatingOccupancyOnly标志,CMSInitiatingOccupancyFraction的默认值就被置为70,即CMS收集器在老年代空间占用比达到70%时,启动并发收集周期.</p><p>这里有一个取舍,给后台线程更多的运行机会,意味着,需要更多的CPU周期,导致更多的CMS并发周期中的停顿.</p><h4 id="调整CMS后台线程"><a href="#调整CMS后台线程" class="headerlink" title="调整CMS后台线程"></a>调整CMS后台线程</h4><p>每一个CMS后台线程都会100%的占用机器上的一颗CPU,如果应用程序发生并发模式失效,同时有额外的CPU可用,可以设置-XX:ConcGCThreads&#x3D;N标志,增加后台线程数,默认情况下,ConcGCThreads是根据ParallelGCThreads标志的值计算得到的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcGCThreads=(3+ParallelGCThreads)/4</span><br></pre></td></tr></table></figure><p>调整这一标志的要点在于判断是否有可用的CPU周期,如果ConcGCThreads的值设置的偏大,垃圾收集会占用本来能用于运行应用线程的CPU周期,最终导致应用程序略微的停顿.此外,在一个配备了大量CPU的系统上,ConcGCThreads参数的默认值会偏大.如果没有并发模式失效,可以考虑较少后台线程数,释放这部分CPU周期用于一个应用线程运行.</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>避免并发模式失效是提升CMS收集器处理能力,获得高性能的关键.</li><li>避免并发模式失效最简单的方式是增大最大堆的容量.</li><li>否则,我们只能通过调整CMSInitiatingOccupancyFraction参数,尽早启动并发后台线程的运行.</li><li>另外.调整后台线程数目对解决这个问题也有帮助.</li></ol><h3 id="CMS收集器的永久代的调优"><a href="#CMS收集器的永久代的调优" class="headerlink" title="CMS收集器的永久代的调优"></a>CMS收集器的永久代的调优</h3><p>如果永久代需要进行垃圾回收就会触发Full GC.Java 7默认情况下,CMS垃圾收集线程不会处理永久代中的垃圾.如果永久代的空间用尽,CMS会发起Full GC来回收其中的垃圾对象,此外,可以通过启用标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSPermGenSweepingEnabled</span><br></pre></td></tr></table></figure><p>开启后,永久代的垃圾使用与老年代一样的方式进行垃圾回收:通过一组后台线程并发地回收永久代中的垃圾.触发永久代垃圾回收的标志与老年代垃圾回收的标志相互独立为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingPermOccupancyFraction=N</span><br></pre></td></tr></table></figure><p>这个参数指定了CMS收集器在永久代空间占比达到设定值时启动永久代垃圾回收线程,默认值为80%.</p><p>为了真正释放不再引用的类,我们还需要启用标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSClassUnloadingEnabled</span><br></pre></td></tr></table></figure><p>否则,即使启用了永久代垃圾回收也只能释放少量的无效对象,类的元数据并不会被释放.由于永久代中大量的数据都是类的元数据,因此开启CMS永久代垃圾回收时,这个标志也应该开启.</p><p>Java 8中,CMS收集器默认就会收集元空间中不再载入的类,如果处于某些原因,你希望关闭次功能,你可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-CMSClassUnloadingEnabled</span><br></pre></td></tr></table></figure><p>进行关闭,默认情况下这个标志是开启的.</p><h3 id="增量式CMS垃圾收集"><a href="#增量式CMS垃圾收集" class="headerlink" title="增量式CMS垃圾收集"></a>增量式CMS垃圾收集</h3><p>如果只有一个单CPU的机器,或者你有多个非常忙碌的CPU,但是希望使用低延迟的垃圾收集器.这种情况下,使用CMS收集器进行增量式的垃圾收集,即只要有后台线程运行,垃圾收集器就不会对整个堆进行回收.这个后台线程间断性地暂停,有助于整个系统吞吐量的提高.</p><p>启动标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSIncrementalMode</span><br></pre></td></tr></table></figure><p>开启增量式CMS垃圾收集,通过改变标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSIncrementalSafetyFactory=N</span><br><span class="line">-XX:CMSIncrementalDutyCycleMin=N</span><br><span class="line">-XX:CMSIncrementalPacing=N</span><br></pre></td></tr></table></figure><p>可以控制垃圾收集线程为应用程序让出多少CPU.</p><p>增量式CMS垃圾收集依据责任周期(duty cycle)原则进行工作.这个原则决定了CMS垃圾收集器的后台线程在释放CPU周期给应用线程前,每隔多长时间扫描一次堆.换言之,这些标志实际控制着主动暂停运行,释放资源给应用线程运行之前,后台线程持续运行的时间.</p><p>责任周期的时长是以新生代相邻两次垃圾收集之间的时间长度计算得出的;默认情况下增量式CMS垃圾收集持续的时间是该时长的20%左右(初始时是这个值,CMS会不断调整该值以适应不断晋升到老年代的对象数目).如果这个时间不够长,就会发生并发模式失效.我们的目的就是通过调整增量式CMS垃圾收集,避免发生这个GC.</p><p>我们可以从调整CMSIncrementalSafetyFactory参数入手,这个参数可以增大到默认责任周期的时间百分比.责任周期的默认值为10%.默认情况下,安全因子的值是在增加10%(默认责任周期所占用的时间百分比变为20%),可以让后台线程有更多的运行时间.</p><p>此外,如果参数CMSIncrementalDutyCycleMin设置得比默认值(10)更大也可以调整责任周期的长度.不过这个参数值会受JCM自动调节机制影响,因为JVM的自动调整机制会监控由新生代晋升到老年代的对象数并进行相应的调节.即使增大这个值,JVM可能还是根据自身的判断,如果增量式垃圾收集不需要运行得过于频繁,从而减少这个值.如果应用程序运行时操作有爆发式的波峰,通过自动调节机制计算出的结果通常不正确,你需要显式地设置责任周期,同时调整CMSIncrementalDutyCycle标志关闭自动参数调节(CMSIncrementalDutyCycle的值默认为真,即开启).</p><p><strong>小结:应用在CPU资源受限的机器上运行,同时要求较小的停顿,这时使用增量式CMS收集器是一个不错的选择;通过责任周期可以调整增量式CMS收集器,增加责任周期的运行时间可以避免CMS收集器发生并发模式失效.</strong></p><p>备注:</p><ol><li>增量式CMS收集在Java 8中已经不推荐使用,在Java 9中已经被移除.</li><li>随着多核技术的发展,使得iCMS存在的意义变得不那么重要了.</li><li>如果系统确实只配备了极其有限的CPU,作为替代方案,可以考虑使用G1收集器.G1收集器的后台线程在垃圾收集过程中也会周期性地暂停,客观上减少了与应用线程竞争CPU资源的情况.</li></ol><h3 id="自适应调优和CMS垃圾收集"><a href="#自适应调优和CMS垃圾收集" class="headerlink" title="自适应调优和CMS垃圾收集"></a>自适应调优和CMS垃圾收集</h3><p>CMS收集器使用两个配置MaxGCPauseMllis&#x3D;N和GCTimeRatio&#x3D;N来确定使用多大的堆和多大的代空间.</p><p>CMS收集器与其他的垃圾收集方法一个显著不同的地方在于除非发生Full GC否则CMS的新生代不会做调整,由于CMS的目标是尽量避免发生Full GC,因此使用精细调优的CMS收集器的应用程序永远不会调整它的新生代大小.</p><p>程序启动时可能频发并发模式失效,因为CMS收集器需要调整堆和永久代的大小,使用CMS收集器,初始时,采用一个比较大的堆(以及一个更大的永久代或元空间)是一个很好的主意,这是一个特例,增大堆的大小而帮助避免那些失效.</p><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p>G1收集器是一种工作在堆内不同分区上的并发收集器.分区既可以属于老年代也可以属于新生代(默认分区数为2048),同一个代的分区不需要保持连续.<br>老年代分区设计初衷:发现后台线程在回收老年代的垃圾时:有的分区垃圾对象比较多,另一些分区垃圾比较少.</p><p>虽然分区的垃圾收集工作仍然会暂定应用线程,但G1收集器专注于收集垃圾最多的分区,最终的效果是花费较少的时间就能回收这些分区垃圾.</p><p>这种只专注于垃圾最多的分区的方式就是G1垃圾收集器名称的由来,即首先收集垃圾最多的分区.</p><p>这种算法不适用与新生代.新新代也采用分区设计的原因是:采用预定义的分区能够便于代的大小调整.</p><p>G1收集器的收集活动主要包括四种操作:</p><ul><li>新生代垃圾收集.</li><li>并发垃圾回收(后台收集,并发周期).</li><li>混合式垃圾收集.</li><li>必要时的Full GC.</li></ul><h3 id="G1新生代垃圾回收"><a href="#G1新生代垃圾回收" class="headerlink" title="G1新生代垃圾回收"></a>G1新生代垃圾回收</h3><p>Eden空间耗尽时,触发G1新生代垃圾回收.新生代收集之后不会有一个分区马上分配到Eden空间(因为这时Eden为空),不过至少会有一个分区分配到Survivor空间,一部分数据会移动到老年代.</p><h3 id="G1并发垃圾收集"><a href="#G1并发垃圾收集" class="headerlink" title="G1并发垃圾收集"></a>G1并发垃圾收集</h3><ul><li>初始标记阶段(initial-mark),暂停应用线程.</li><li>扫描根分区(concurrent-root-region-scan-start),并发执行.</li><li>并发标记阶段(concurrent-mark-start)–&gt;(concurrent-mark-end),可以中断,可能发生新生代垃圾回收.</li><li>重新标记阶段(remark),暂停应用线程.</li><li>清理阶段(cleanup)(concurrent-cleanup-start –&gt; concurent-cleanup-end),暂停应用线程.<br>  到此,G1的周期就结束了,清理阶段真正回收的内存数量很少,G1到这个点为止真正做的事就是定位出那些老的分区可回收垃圾最多.</li></ul><h3 id="G1混合式垃圾回收"><a href="#G1混合式垃圾回收" class="headerlink" title="G1混合式垃圾回收"></a>G1混合式垃圾回收</h3><p>G1并发周期结束后,G1会进行一系列的混合式垃圾回收,不仅进行正常的新生代垃圾回收,同时也回收部分后台扫描线程标记的分区.</p><p>同新生代垃圾收集行为一样,G1收集器清空Eden空间,同时调整Survivor空间的大小.此外<strong>部分</strong>标记的分区也被回收,绝大部分空间被释放,剩余的对象被移动到其他分区.这也是为什么G1收集器最终出现碎片化堆的频率比CMS收集器要小得多的原因,G1垃圾回收以这种方式移动对象,实际伴随着压缩.</p><p>混合式垃圾回收周期会持续到(几乎)所有的标记分区被回收.之后,G1收集器会恢复常规的新生代垃圾回收机制.最终G1收集器会启动再一次的并发周期</p><h3 id="G1-Full-GC"><a href="#G1-Full-GC" class="headerlink" title="G1 Full GC"></a>G1 Full GC</h3><p>触发G1进行Full GC有以下四种情况</p><ul><li>并发模式失效:G1垃圾收集启动标记周期,但老年代在周期完成之前被填满(concurrent-mark-start –&gt; concurrent-mark-abort).</li><li>晋升失败:G1收集器完成标记阶段,开始启动混合式垃圾回收,清理老年代的分区,老年代在释放出足够的内存之前就被耗尽( pause(mixed) –&gt; Allocation Failure).</li><li>疏散失败:进行新生代垃圾收集时,Survivor空间和老年代中没有足够的空间容纳所有的幸存对象.( pause young (to-space overflow)),此时堆已经被耗尽或者碎片化了.</li><li>巨型对象分配失败:分配非常大的对象时,可能会遭遇另一种Full GC.</li></ul><p><strong>小结:G1垃圾收集包含多个周期(以及并发周期内的阶段),调优良好的JVM运行G1收集器时应该只经历新生代周期,混合式周期和并发周期;G1并发阶段会产生少量的停顿;恰当的时候,我们需要对G1进行调优,才能避免Full GC周期发生;</strong><br><strong>备注:如果进行根分区扫描时,新生代空间刚好用尽,新生代垃圾回收必须等待根扫描结束才能完成.</strong></p><h3 id="G1垃圾收集器调优"><a href="#G1垃圾收集器调优" class="headerlink" title="G1垃圾收集器调优"></a>G1垃圾收集器调优</h3><p>G1垃圾收集器调优的主要目的:避免发生并发模式失败或者疏散失败,一旦发生这些失败会导致Full GC.<br>备注: 避免发生Full GC的方法也适用于频繁发生的新生代垃圾收集.<br>以下方法可以避免发生Full GC:</p><ul><li>增加堆空间的大小或者调整老年代,新生代之间的比例来增加老年代的大小.</li><li>增加后台线程的数目(如果有足够多的CPU资源).</li><li>以更高的频率进行G1的后台垃圾收集活动.</li><li>在混合式垃圾回收周期中完成更多的垃圾收集工作</li></ul><h3 id="调整最大停顿时间"><a href="#调整最大停顿时间" class="headerlink" title="调整最大停顿时间"></a>调整最大停顿时间</h3><p>G1收集器最主要通过调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=N</span><br></pre></td></tr></table></figure><p>标志,来达到性能目标.如果G1收集器发生时空停顿(stop-the-world)的时长超过该值,G1收集器就会尝试各种方式进行弥补:</p><ul><li>调整新生代与老年代的比例.</li><li>调整堆大小.</li><li>调整更早地启动后台线程.</li><li>改变晋升阀值.</li><li>在混合垃圾收集周期中处理更多或更少的老年代分区.<br>这里需要权衡的是: 减少参数值,为了达到停顿目标,新生代的大小会相应的减少,不过新生代垃圾收集的频率会更加频繁.此外,为了达到停顿目标,混合式GC收集的老年代分区数也会减少,而这会增大并发模式失败发生的机会.</li></ul><p>如果设置停顿时间无法避免Full GC,我们可以进一步针对不同方面逐一调优.</p><h3 id="调整G1垃圾收集的后台线程数"><a href="#调整G1垃圾收集的后台线程数" class="headerlink" title="调整G1垃圾收集的后台线程数"></a>调整G1垃圾收集的后台线程数</h3><p>如果有足够的空闲CPU,可以增加后台标记线程数目.</p><ul><li>对于应用程序暂停运行的周期,可以通过ParallelGCThreads标志设置运行的线程数;</li><li>对于并发运行阶段,可以使用ConcGCThreads标志设置运行线程数.<br>备注: ConcGCThreads标志的默认值为</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcGCThreads = (ParallelGCThreads + 2) /4</span><br></pre></td></tr></table></figure><h3 id="调整垃圾收集器运行的频率"><a href="#调整垃圾收集器运行的频率" class="headerlink" title="调整垃圾收集器运行的频率"></a>调整垃圾收集器运行的频率</h3><p>如果G1收集器更早的启动垃圾收集,有助于避免并发模式失效.G1垃圾收集周期通常在堆的占用达到参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=N</span><br></pre></td></tr></table></figure><p>设置的比率时启动,默认情况下该值为45.<br>备注:该值是指整个堆的占用率,而不是单指老年代.</p><p>InitiatingHeapOccupancyPercent是一个常数,G1收集器自身不会为了达到停顿时间而修改整个值.</p><ul><li>如果设置的过高,应用程序会陷入Full GC的泥潭,因为并发阶段没有足够的时间在剩下的堆空间被填满之前完成垃圾收集.</li><li>如果设置的过低,应用程序又会以超过实际需要的节奏进行大量的后台处理.这会导致非常严重的结果,因为并发阶段会出现越来越多的短暂应用线程的停顿.</li></ul><p>因此,使用G1收集器时要避免频繁地进行后台清理,并发周期结束后,检查堆的大小,确保InitiatingHeapOccupancyPercent的值大于此时堆的大小.</p><h3 id="调整G1收集器的混合式垃圾收集器周期"><a href="#调整G1收集器的混合式垃圾收集器周期" class="headerlink" title="调整G1收集器的混合式垃圾收集器周期"></a>调整G1收集器的混合式垃圾收集器周期</h3><p>并发周期后,老年代标记分区回收完成前,G1收集器无法启动新的并发周期,因此,让G1收集器更早的启动标记周期的另一方法是:混合式垃圾回收周期尽量处理更多分区,进而减少混合式GC周期数.<br>混合式垃圾收集要处理的工作量取决于三个因素:</p><ol><li>有多少分区被发现大部分是垃圾对象.目前没有标志能够直接调节这个因素.混合垃圾收集中,如果分区的垃圾占比达到35%,那么这个分区被标记为可以进行垃圾回收.</li><li>G1垃圾收集器回收分区时的最大混合式GC周期数,通过参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1MixedGCCounttarget=N</span><br></pre></td></tr></table></figure><p>进行调节,默认值为8,减少该参数有助于解决晋升失败的问题,代价是混合式GC周期的停顿时间会更长.另一方面,如果混合式GC的时间过长,可以增大这个参数的值,减少每次混合式GC周期的工作量,不过需要确保调整最大值后不会对下一次GC并发周期带来太大的延迟,否则会导致并发模式失败.<br>3. GC停顿可忍受最大时长(通过MaxGCPauseMillis参数设定),MaxGCPauseMillis标志设定的混合式周期是向上规整的,如果实际停顿时间在停顿最大时长以内,G1收集器能够收集超过八分之一标记的老年代分区.增大MaxGCPauseMillis能在每次混合式GC中收集更多的老年代分区,而这反过来又能帮助G1收集器在更早的时候启动并发周期.</p><h3 id="G1垃圾调优小结"><a href="#G1垃圾调优小结" class="headerlink" title="G1垃圾调优小结"></a>G1垃圾调优小结</h3><ol><li>作为G1收集器调优的第一步,首先是设定一个合理的停顿时间作为目标.</li><li>如果使用这个设置后,还是频繁发生Full GC,并且堆的大小没有扩大的可能,这时候需要针对特定的失败,采用特定的方法进行调优.</li></ol><ul><li>通过InitiatingHeadpOccupancyPercent标志可以调整G1收集器,更频繁地启动后台垃圾收集线程.</li><li>如果有足够的CPU资源,可以考虑调整ConcGCThreads标志,增加垃圾收集线程数.</li><li>减少G1MixedGCCountTarget参数可以避免晋升失败.</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs">understanding-cms-gc-logs</a></li></ol>]]></content>
    
    
    <summary type="html">垃圾收集算法.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>GC调优基础</title>
    <link href="http://tanqidong1992.github.io/2021/06/12/2021/06/12/base-of-gc-tuning/"/>
    <id>http://tanqidong1992.github.io/2021/06/12/2021/06/12/base-of-gc-tuning/</id>
    <published>2021-06-12T13:39:31.000Z</published>
    <updated>2023-02-13T13:30:14.328Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC调优基础"><a href="#GC调优基础" class="headerlink" title="GC调优基础"></a>GC调优基础</h2><p>虽然处理堆时各种GC算法有所差异,但是它们的基本配置参数是一致的.很多情况下,我们只需要这些基本的配置就能运行应用程序.</p><h3 id="调整堆的大小"><a href="#调整堆的大小" class="headerlink" title="调整堆的大小"></a>调整堆的大小</h3><p>选择堆的大小是一种平衡,如果分配的堆过小,程序的大部分时间可能消耗在GC上,没有足够的时间去运行应用程序逻辑.<br>如果粗暴地设置一个大堆,将有以下风险:</p><ul><li>GC停顿的时间取决于堆的大小,如果增加堆的大小,停顿的持续时长也会变长.这种情况下,虽然停顿的频率会变得更少,但是他们持续的时间会让程序的整体性能变慢.</li><li>如果JVM使用的内存超过计算机的物理内存,部分不活跃的内存可能会被操作系统置换到交换分区(页面文件)中,JVM不会了解到这些细节.由于Full GC会访问整个JVM堆,那么内存交换一定会发生.Full GC停顿的时间将会以正常停顿时间的数个数量级的增长.类似的如果使用Concurrent收集器,后台线程在回收堆的时候,它的速度会被拖慢,因为要等待从磁盘复制数据到内存,结果导致发生代价昂贵的并发模式失败.<br>因此,调整堆的大小时,永远不要把堆的大小设置的超过物理内存,另外如果同一台机器运行多个JVM,那么这个规则适用于所有堆的和.除此之外,你还必须为JVM自身以及其他应用程序预留部分内存,通常情况下,对于一般操作系统,应该至少预留1G的内存空间.</li></ul><p>堆的大小由两个参数控制:</p><ul><li>最小值:-Xms(-XX:InitialHeapSize)</li><li>最大值:-Xmx(-XX:MaxHeapSize)</li></ul><p>默认值的调整取决于多个因素,包括操作系统的类型,系统内存大小,使用的JVM,其他命令行标志也会对该值造成影响;堆的大小是JVM自适应调优的核心.</p><p>Windows下Java11,物理内存为32G的情况下,初始值为512mb,最大值为8G,</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\me\blog<span class="literal">-test</span>&gt;java <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr InitialHeapSize</span><br><span class="line">size_t InitialHeapSize                          = <span class="number">534773760</span>                                 &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version <span class="string">&quot;11.0.11&quot;</span> <span class="number">2021</span><span class="literal">-04-20</span></span><br><span class="line">OpenJDK Runtime Environment GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci-21</span>.<span class="number">1</span><span class="literal">-b05</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci-21</span>.<span class="number">1</span><span class="literal">-b05</span>, mixed mode, sharing)</span><br><span class="line"></span><br><span class="line">D:\me\blog<span class="literal">-test</span>&gt;java <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr MaxHeapSize     </span><br><span class="line">size_t MaxHeapSize                              = <span class="number">8541700096</span>                                &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version <span class="string">&quot;11.0.11&quot;</span> <span class="number">2021</span><span class="literal">-04-20</span></span><br><span class="line">OpenJDK Runtime Environment GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci-21</span>.<span class="number">1</span><span class="literal">-b05</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci-21</span>.<span class="number">1</span><span class="literal">-b05</span>, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>堆的大小具有初始值和最大值,JVM的目标是根据系统可用资源情况找到一个合理的默认值.堆的大小具有初始值和最大值的这种设计让JVM能够根据实际的负荷情况更灵活地调整JVM的行为,如果JVM发现使用初始的堆的大小,频繁地发生GC,它会尝试增大堆的空间,直到JVM的GC的频率回归到正常的范围,或者直到堆的大小增大到它的上限值.</p><p>通常,如果应用程序运行所需要的堆不超过运行平台默认的最大值,这个方法就可以工作的很好.<br>然后,如果应用程序在GC时消耗了太长的时间,你有可能需要通过设置-Xmx标志增大堆的大小.选择怎样的大小,没有硬性或者简单的法则.一个经验的法则是,一次Full GC后,应该释放出70%的空间.</p><p>即使显式地设置了堆的大小,还是会发生堆的自动调节,初始时堆以默认的大小开始运行,为了达到根据垃圾收集算法设置的性能目标,JVM会逐步增大堆的大小.将堆的大小设置的比实际需要更大不一定会带来性能损失.堆不会无限制地增大,JVM会调节堆的大小直到其满足GC的性能目标.</p><p>备注:如果你确切地直到应用程序需要多大的堆,那么你可以将堆的初始值和最大值设置成对应值,这种设置可以稍微提高GC的运行效率,因为它不需要估算堆是否需要调整大小了.</p><p>总结:JVM会根据其运行的机器,尝试估算合适的最大,最小堆的大小;除非应用程序需要比默认值更大的堆,否则在调优时,尽量考虑通过调整GC算法的性能目标,而非微调堆的大小来改善程序性能.</p><h3 id="代空间的调整"><a href="#代空间的调整" class="headerlink" title="代空间的调整"></a>代空间的调整</h3><p>堆的大小被确定后,我们还学要确定代的大小,如果新生代的大小分配的过小,那么会频繁地发生Minor GC,同样老年代就会比较大,发生的Full GC的频率较低,这里需要找到一个平衡.<br>调整代空间标识</p><ul><li>设置新生代与老年代的空间比率: -XX:NewRatio&#x3D;N</li><li>设置新生代的初始大小: -XX:NewSize&#x3D;N</li><li>设置新生代的最大大小: -XX:MaxNewSize&#x3D;N</li><li>将新生代的最大最小值设置为同一值的快捷方法 -XmnN</li></ul><p>NewRation的默认值为2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/mnt/d/me/blog-test$ java -XX:+PrintFlagsFinal -version | grep NewRatio</span><br><span class="line">uintx NewRatio                                 = 2                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">openjdk version &quot;11.0.11&quot; 2021-04-20</span><br><span class="line">OpenJDK Runtime Environment GraalVM CE 21.1.0 (build 11.0.11+8-jvmci-21.1-b05)</span><br><span class="line">OpenJDK 64-Bit Server VM GraalVM CE 21.1.0 (build 11.0.11+8-jvmci-21.1-b05, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>新生代初始大小计算公式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initial Young Generation Size = Initial Heap Size / ( 1 + NewRatio )</span><br></pre></td></tr></table></figure><p>默认情况下新生代的初始大小为初始堆的33%.</p><p>我们也可以通过设置NewSize的值,显式地设定新生代的初始大小,其优先级高于通过NewRatio计算出来的值.虽然NewSize有默认值,但是在未设置的情况下,以NewRatio计算出来的为准</p><p><strong>小结:整个堆范围内,不同代的大小划分是由新生代所占用的空间控制的;新生代的大小会随着整个堆的增大而增长,但是也是随着整个堆的空间比率波动变化的(依据新生代的初始值和最大值)</strong></p><h3 id="永久代和元空间的调整"><a href="#永久代和元空间的调整" class="headerlink" title="永久代和元空间的调整"></a>永久代和元空间的调整</h3><p>JVM载入类的时候,它需要记录这些类的元数据.这些数据被保留在单独的堆空间中,在Java7中称为永久代(Permanent Generation),在Java8中称为元空间(Metaspace).<br>永久代与元空间不完全一样,在Java7中,永久代还保存了一些与类无关的杂项数据.这些数据在Java8中被移动到了普通的堆空间,Java8还在根本上改变了保存在这个特殊区域内的元数据的类型.</p><p>目前没有一个好算法可以提前计算出程序永久代&#x2F;元空间需要多大空间的好算法.<br>永久代&#x2F;元空间的大小与程序使用类的数量成正比例,应用程序越复杂,使用的对象越多,永久代&#x2F;元空间就越大.<br>备注:使用元空间替换掉永久代的优势之一是我们不需要对其进行调整.<br>配置标志:</p><ul><li>永久代初始大小: -XX:PermSize&#x3D;N</li><li>永久代最大值: -XX:MaxPermSize&#x3D;N</li><li>元空间初始大小: -XX:MetaspaceSize&#x3D;N</li><li>元空间最大值: -XX:MetaspaceSize&#x3D;N<br>备注:元空间默认是没有大小限制的,Java8的应用可能由于元空间被填满而耗尽内存,可以使用NMT(Native Memory Tracking)诊断这类问题.通过设置MaxMetaspaceSize调整元空间的上限,一旦超过会触发OutOfMemoryError错误.解决此类问题需要定位出为什么类的元空间这么大.</li></ul><p>虽然名叫永久代,元空间,但其中的数据并不会被永久保存,保存在其中的类会像对象一样会经历垃圾回收,当类加载器不再被引用时,其加载的类,会等待GC回收.</p><p>堆转储信息可以用于诊断存在那些类加载器.而这些信息放过来可以帮助确定是否存在类加载的泄露,最终导致永久代&#x2F;元空间被耗尽,除此之外使用jmap和-permstat参数(Java7)或者clstats参数(Java8)可以输出类加载器相关信息.这些命令不稳定,不推荐使用.</p><p><strong>小结:永久代&#x2F;元空间保存着类的元数据(并非类的本体数据),他以分离的堆的形式存在;典型的应用在启动后不需要载入新的类,这个区域的初始值可以根据所有类都加载后的情况设置,使用优化的初始值能够加快启动的过程;开发中的应用服务器(或者任何需要频繁载入类的环境)上经常能碰到永久代或元空间耗尽而触发的Full GC,这时老的元数据会被回收.</strong></p><h2 id="控制并发"><a href="#控制并发" class="headerlink" title="控制并发"></a>控制并发</h2><p>除了Serial收集器,几乎所有的收集器使用的算法都是基于多线程.启动线程的数量由-XX:ParallelGCThreads&#x3D;N参数控制,这个参数会影响以下操作:</p><ul><li>使用-XX:+UseParallelGC收集新生代.</li><li>使用-XX:+UseParallelOldGC收集老年代.</li><li>使用-XX:+UseParNewGC收集新生代.</li><li>使用-XX:+UseConcMarkSweepGC收集老年代时空停顿阶段.</li><li>使用-XX:+UseG1GC收集老年代时空停顿阶段.</li><li>使用-XX:UseG1GC收集新生代.<br>由于GC操作会暂停所有应用程序线程,JVM为了缩短停顿时间就必须尽可能地利用更多的CPU资源,默认情况下JVM会在每一个CPU上运行一个垃圾收集线程,最多不超过8个,一旦超过8个,则采用以下公式计算:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParallelGCThreads = 8 + (N-8)*5/8, N表示CPU的数量</span><br></pre></td></tr></table></figure><p><strong>小结: 几乎所有的垃圾收集算法中基本的垃圾回收线程都依据机器上CPU的数目计算得出;多个JVM运行在同一个机器上,依据公式计算出的线程数量可能过高,必须进行优化(减少).</strong></p><h3 id="自适应调整"><a href="#自适应调整" class="headerlink" title="自适应调整"></a>自适应调整</h3><p>自适应调整策略,JVM会不断地尝试,寻找优化性能的机会,JVM运行的过程中,堆,代以及Survivor空间的大小都可能发生变化.</p><p>这是一种尽力而为的方案,它根据过往的性能历史,假设即将来的GC周期跟最近的历史GC周期的状况可能很相似.事实证明,在多种负荷下这一假设是正确的.即使某个时刻内存的分配发生突变的情况,JVM也能依据最新的情况重新调整它的大小.</p><p>自适应调整有两方面的好处:</p><ul><li>小型的应用程序不需要再为指定过大的堆而担心.</li><li>很多应用程序不需要担心他们堆的大小,如果使用堆的大小超过平台默认值,他们可以放心地分配更大的堆,而不用关心其中的细节.JVM会自动调整堆和代的大小,根据垃圾回收算法的性能目标,使用优化的内存量,自适应调整就是让自动调整生效的法宝.</li></ul><p>空间的调整终归需要花费一定的时间开销,这部分时间大多数消耗在GC停顿的时候,如果你投注了大量的时间精细地调优了垃圾回收参数,定义了堆的大小限制,可以考虑关闭自适应调整.如果应用程序的运行明显划分为不同的阶段,你希望对这些阶段中的某个阶段进行垃圾回收的优化,那么关闭自适应调优也是很有帮助的.</p><p>使用-XX:-UseAdaptiveSizePolicy标志关闭自适应调整功能(默认开启);如果堆容量的最大值,最小值设置为一样,同时新生代的初始值和最大值也设置为同样大小,自适应功能会被关闭,不过此时Survivor空间是个意外.</p><p>可以启用标志-XX:+PrintAdaptiveSizePolicy标志,了解应用程序运行时JVM是如何调整的,一旦发生垃圾回收,GC的日志中包含不同代进行空间调整的细节信息.</p><p><strong>小结: JVM在堆内部如何调整新生代与老年代的百分比是由自适应调整机制控制的;通常情况下我们应该开启自适应调整,垃圾回收算法依赖于调整后的代的大小来达到它停顿的性能目标;对于已经精细优化过的堆,关闭自适应调整能获得一定的性能提升.</strong></p><h2 id="垃圾回收工具"><a href="#垃圾回收工具" class="headerlink" title="垃圾回收工具"></a>垃圾回收工具</h2><h3 id="输出垃圾回收日志"><a href="#输出垃圾回收日志" class="headerlink" title="输出垃圾回收日志"></a>输出垃圾回收日志</h3><p>垃圾回收对JVM性能影响至关重要,观察垃圾回收对应用程序性能的最好方法就是尽量熟悉垃圾回收的日志.垃圾回收日志中包含了程序运行过程中的每一次垃圾回收操作.</p><p>垃圾回收日志的细节依据使用的垃圾回收算法各有不同,不过垃圾回收日志的基本结构是一致的.</p><h3 id="开启垃圾回收日志"><a href="#开启垃圾回收日志" class="headerlink" title="开启垃圾回收日志"></a>开启垃圾回收日志</h3><ul><li>开启基本日志 -verbose:gc 或者 -XX:+PrintGC (默认关闭)</li><li>开启详细日志 -XX:+PrintGCDetails (默认关闭)</li></ul><p>备注:出了详细日志,我们还需要开启-XX:+PrintGCTimeStamps 或者 -XX:+PrintGCDateStamps,便于我们精准地判断几次GC操作的时间,时间戳是相对JVM启动的时间,日期戳是实际的日期字符串</p><h3 id="垃圾回收日志输出到文件"><a href="#垃圾回收日志输出到文件" class="headerlink" title="垃圾回收日志输出到文件"></a>垃圾回收日志输出到文件</h3><p>默认情况下垃圾回收日志直接输出到控制台,使用-Xloggc:filename标志能修改输出到某个文件(除非显示的启动PrintGCDetails,不然仅输出基本日志).使用日志循环(Log rotation)标志限制保存在GC日志文件中的数据量,标志如下:</p><ul><li>启用日志文件循环 -XX:+UseGCLogfileRotation</li><li>设置日志文件数量限制 -XX:NumberOfGCLogfiles&#x3D;N</li><li>设置日志文件大小限制 -XX:GCLogfileSize&#x3D;N</li></ul><p><strong>备注: 默认情况下UseGCLogfileRotation是关闭的,开启UseGCLogfileRotation后,文件的数量为0,即为不限制数量,默认的文件大小也为0,即为不限制大小,如果设置的文件大小不足8K,那么日志文件的大小也会以8K为单位进行规整.</strong></p><h3 id="阅读垃圾回收日志"><a href="#阅读垃圾回收日志" class="headerlink" title="阅读垃圾回收日志"></a>阅读垃圾回收日志</h3><p>我们可以手工解析,阅读垃圾回收的日志,也可以借助外部工具.</p><ul><li>GC Histogram可以根据日志文件生成对于的图表与表格.</li><li>jconsole可以查看堆的实时使用情况</li><li>jstat 可以使用脚本的方式获取堆的使用信息,比如选项-gcutil,它能输出消耗在GC上的时间,以及每个GC区域使用的百分比.</li></ul><p>备注 jstat接受一个可选的参数,指定每隔多少毫秒重复执行这个命令.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>GC日志是分析GC相关问题的重要线索;我们应该开启GC日志标志(即使在生产服务器上).</li><li>使用PrintGCDetails标志能获得更详尽的GC日志信息.</li><li>使用工具能很有效地帮助我们解析和理解GC日志的内容,尤其是在对GC日志中的数据进行归纳汇总时,他们非常有帮助.</li><li>使用jstat能动态地观察程序的垃圾回收操作.</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对任何一个Java应用程序,垃圾收集的性能都是其构成整体性能的关键一环.虽然对大多数的应用程序来说,调优的工作仅仅是选择合适的垃圾收集算法,或者在需要的时候,增大应用程序的堆空间.</p><p>自适应调整让JVM能够自动调整它的行为,使用给定的堆,提供尽可能好的性能.</p>]]></content>
    
    
    <summary type="html">GC调优基础.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>HarmonyOS</title>
    <link href="http://tanqidong1992.github.io/2021/05/29/2021/05/29/harmonyOS_architecture/"/>
    <id>http://tanqidong1992.github.io/2021/05/29/2021/05/29/harmonyOS_architecture/</id>
    <published>2021-05-28T17:35:11.000Z</published>
    <updated>2023-02-13T13:30:14.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HarmonyOS"><a href="#HarmonyOS" class="headerlink" title="HarmonyOS"></a>HarmonyOS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>HarmonyOS是华为开发的,一款面向未来的全场景分布式智慧操作系统,将逐步覆盖1+8+N全场景终端设备</p><h3 id="1-8-N"><a href="#1-8-N" class="headerlink" title="1+8+N"></a>1+8+N</h3><ul><li>1: 手机.</li><li>8: PC,平板,手表,智慧屏,AI音箱,耳机,AR&#x2F;VR眼镜,车机.</li><li>N: IoT生态产品.</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>消费者<br>  HarmonyOS用一个统一的软件系统,从根本上解决消费者面对大量智能终端体验割裂的问题,为消费者带来统一,便利,安全的智慧化全场景体验.</li><li>开发者<br>  HarmonyOS通过多种分布式技术,整合不同终端硬件能力,形成一个虚拟的”超级终端”,应用开发者可基于超级终端开发应用,聚焦上层业务逻辑,无需关注硬件差异,设备开发者可以按需调用其他终端能力,带来基于超级终端的创新服务体验</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HarmonyOS作为一款面向未来的崭新操作系统,必将在万物互联,万物智能的全联接世界中发挥至关重要的作用,期待广大开发者伙伴积极加入我们,共同见证全场景智慧生态的无限可能.</p><h2 id="HarmonyOS-Architecture"><a href="#HarmonyOS-Architecture" class="headerlink" title="HarmonyOS Architecture"></a>HarmonyOS Architecture</h2><p><img src="http://tanqidong1992.github.io/2021/05/29/2021/05/29/harmonyOS_architecture/1df249e302b8c523f2efe706c0680a1eb9afd0121fffda7d451cad27fe514989.svg"></p>]]></content>
    
    
    <summary type="html">HarmonyOS概念以及架构.</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="http://tanqidong1992.github.io/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集入门</title>
    <link href="http://tanqidong1992.github.io/2021/05/24/2021/05/24/introduction-to-garbage-collection/"/>
    <id>http://tanqidong1992.github.io/2021/05/24/2021/05/24/introduction-to-garbage-collection/</id>
    <published>2021-05-24T13:55:11.000Z</published>
    <updated>2023-02-13T13:30:14.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集入门"><a href="#垃圾收集入门" class="headerlink" title="垃圾收集入门"></a>垃圾收集入门</h1><h2 id="主流垃圾收集器"><a href="#主流垃圾收集器" class="headerlink" title="主流垃圾收集器"></a>主流垃圾收集器</h2><p>Java主流的垃圾收集器分别是:</p><ul><li>Serial收集器.</li><li>Parallel(Throughput)收集器.</li><li>Concurrent收集器,CMS.</li><li>Concurrent收集器,G1.</li></ul><h2 id="垃圾收集概述"><a href="#垃圾收集概述" class="headerlink" title="垃圾收集概述"></a>垃圾收集概述</h2><p>Java最诱人的特性之一便是不需要显式地管理对象的生命周期,JVM会在后台自动回收不再使用的对象.<br>垃圾收集主要由两部分构成:</p><ul><li>查找不再使用的对象.</li><li>释放这些对象所管理的内存</li><li>有时候,还需要进行内存整理防止内存碎片.</li></ul><p>在垃圾收集进行时,所有应用线程都停止运行所产生的的停顿被称为时空停顿(stop-the-world),通常这些停顿对应用的性能影响最大,调优垃圾收集时,尽量减少这种停顿是最为关键的因素.</p><h3 id="分代垃圾收集器"><a href="#分代垃圾收集器" class="headerlink" title="分代垃圾收集器"></a>分代垃圾收集器</h3><p>虽然不同垃圾收集器实现细节千差万别,但都遵循同一个方式,即根据情况将堆分为不同的代(Generation),被分为老年代(Old Generation)和新生代(Young Generation),新生代又被分为Eden空间以及Survivor空间.</p><p>采用分代机制的原因是很多对象的生存周期非常短.采用分代设计主要有两个性能优势:</p><ul><li>新生代仅是堆的一部分,处理新生代更快.</li><li>对象分配于新生代,垃圾收集时,新生代被清空,Eden空间对象要么被移走,要么被回收;所有存活对象要么被移动到老年代,要么被移动到Survivor空间,由于所有对象被移走,相当于新生代空间在垃圾收集时,自动进行了一次垃圾整理.</li></ul><p>回收新生代空间,不用的对象被回收,存活的对象被移动到其他空间,这种操作称为Minor GC.<br>对象不断移动到老年代,最终老年代空间也会被占满,JVM需要找出老年代中不再使用的对象,并对它们进行回收,接着对对空间进行整理,这是垃圾收集算法差异最大的地方,这个过程称为Full GC,通常会导致应用程序线程长时间的停顿,</p><p>另一方面,通过更复杂的计算,我们还可能在应用程序运行的同时,找出不再使用的对象;CMS和G1收集器便是通过这种方式进行垃圾回收.由于它们不需要停止应用线程就能找出不再使用的对象,它们也被称为Concurrent收集器.Concurrent收集器采用不同的方法对老年代进行压缩.</p><p>使用CMS或G1收集器时,应用程序经历的停顿会更少(也更短),其代价便是消耗更多的CPU,CMS和G1收集器也可能遭受长时间的Full GC(调优算法以尽量避免出现这种情况).</p><p>评估垃圾收集器,要想达到整体的性能目标,每一个决定都需要取舍,如果应用对单个响应时间有要求,主要考虑以下方面:</p><ul><li>单个请求会受停顿时间的影响(受Full GC长时间停顿的影响更大),如果目标是尽可能地缩短响应时间,那么采用Concurrent收集器更为合适.</li><li>如果平均响应时间比最大响应时间更为重要(譬如90%地响应时间),那么采用Throughput收集器通常就能满足需要.</li><li>使用Concurrent收集器来避免长时间Full GC的代价便是消耗更多的CPU.</li></ul><p>为批量应用选择垃圾收集器遵守以下规则:</p><ul><li>如果CPU足够强劲,使用Concurrent收集器避免发生Full GC可以让任务运行更快.</li><li>如果CPU有限,那么Concurrent收集器额外的CPU消耗会让批量任务消耗更多的时间.</li></ul><p>备注:</p><ul><li>所有GC算法都将堆划分为新生代和老年代.</li><li>所有GC算法都在清理新生代对象时,都使用了”时空停顿”(Stop-The-World)方式收集垃圾,这通常是一个较快便能完成的操作.</li></ul><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>JVM提供四种不同的垃圾收集算法</p><h3 id="Serial垃圾收集器"><a href="#Serial垃圾收集器" class="headerlink" title="Serial垃圾收集器"></a>Serial垃圾收集器</h3><p>Serial收集是四种收集器中最简单的一种,如果运行在Client型虚拟机,这也是默认的垃圾收集器.<br>Serial收集器采用单线程清理堆内容,无论是Minor GC还是Full GC,所有应用线程都会被暂停,进行Full GC时,会对老年代的对象进行压缩整理,使用-XX:+UseSerialGC标志启用Serial收集器.</p><h3 id="Throughput收集器"><a href="#Throughput收集器" class="headerlink" title="Throughput收集器"></a>Throughput收集器</h3><p>Thoughput收集器是Server虚拟机的默认收集器,Throughput收集器采用多线程回收新生代空间和老年代空间,Minor GC比Serial收集器快的多,Throughput收集器在Minor GC和Full GC时会暂停所有应用线程.在Full GC时会对老年代空间进行压缩整理.使用标志-XX:+UseParallelGC,-XX:+UseParallelOldGC启用Throughput收集器.由于Throughput收集器采用多线程,因此也被称为Parallel收集器.</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器设计的初衷是为了解决Serial以及Throughput收集器Full GC周期长时间的停顿.CMS会在Minor GC中停止所有的应用线程,并采用多线程的方式回收新生代空间,不同于Throughput收集器的-XX:+UseParallelGC,改用新的算法来回收新生代对象(-XX:+UseParNewGC)</p><p>CMS在Full GC时,不再停止应用线程,而是使用多个后台线程定期地对老年代进行扫描,及时回收其中不再使用的对象.这种算法帮助CMS收集器成为一个低延迟的收集器.应用线程只在Minor GC以及后台线程扫描老年代时发生及其短暂的停顿.应用线程的停顿的总时长比Throughput收集器短得多.</p><p>这里需要付出的代价是更高的CPU使用:必须有足够的CPU资源用于后台的垃圾收集线程.<br>除此之外,后台线程不再进行任何压缩整理操作,这意味堆会逐渐变得碎片化,如果CMS的后台线程无法获得完成他们任务的CPU资源或者堆过于碎片化以至于无法找到连续空间分配对象.CMS就会蜕化到Serial收集器行为:暂停所有应用线程,使用单线程回收,整理老年代空间.这之后又恢复到并发运行,再次启动后台线程.使用-XX:+UseConcMarkSweepGC,-XX:+UseParNewGC启用CMS垃圾收集器.</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1垃圾收集器设计的初衷是为了尽量缩短处理超大堆(大于4G)时产生的停顿,G1收集器将堆分为多个区域(Region),不过它仍属于分代收集器,在进行Minor GC时,暂停所有的应用线程,采用多线程方式回收垃圾,将存活对象移动到老年代或者Survivor空间.</p><p>G1垃圾收集器属于Concurrent收集器:老年代的垃圾收集由后台线程完成,大多数工作不需要停止应用线程.由于老年代被分为多个区域,G1收集器通过将对象从一个区域复制到另一个区域,完成对象清理,同时也完成了堆的压缩整理.因此,G1收集器的堆不太容易发生碎片化.</p><p>同CMS收集器一样,避免Full GC的代价是消耗额外的CPU,负责垃圾收集的多个后台线程必须在应用线程运行的同时获得足够多的CPU运行周期,通过标志-XX:+UseG1GC启用</p><h3 id="触发及禁用显示的垃圾回收"><a href="#触发及禁用显示的垃圾回收" class="headerlink" title="触发及禁用显示的垃圾回收"></a>触发及禁用显示的垃圾回收</h3><p>通常情况下垃圾收集是由JVM在需要的时候触发:新生代快用尽时会触发Minor GC,老年代快用尽的时候会触发Full GC,或者堆空间即将填满时会触发Concurrent垃圾收集.</p><p>JVM提供一种机制让应用程序强制进行GC.</p><ul><li>System.gc()</li><li>jcmd <pid> GC.run</pid></li><li>RMI作为分布式垃圾收集器的一部分,每隔一个小时它会调用System.gc()一次,可以通过-Dsum.rmi.dgc.server.gcInterval&#x3D;N和-Dsum.rmi.dgc.client.gcInterval&#x3D;N进行修改,N的单位为毫秒.Java 7中N默认为3600000(1小时).<br>可以通过配置JVM参数-XX:+DisableExplicitGC显式地禁用这种类型的GC</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>四种垃圾收集器分别采用了不同的方法来缓解GC对应用的影响.</li><li>Serial收集器常用于仅有单CPU可用以及当其他程序会干扰GC的情况.</li><li>Throughput收集器能够在其他的虚拟机上是默认值,它能最大化应用程序的总吞吐量,但有些操作会遭遇较长的停顿.</li><li>CMS收集器能够在应用线程运行的同时并发地对老年代的垃圾进行收集,.如果CPU的计算能力足够支持后台垃圾收集线程的运行,该算法能够有效避免应用程序发生Full GC.</li><li>G1收集器也能在应用线程运行的同时并发地对老年代的垃圾进行收集,在某种程度上能够减少发生Full GC的风险.G1的设计理念使得它比CMS更不容易遭遇Full GC.</li></ol><h2 id="选择GC算法"><a href="#选择GC算法" class="headerlink" title="选择GC算法"></a>选择GC算法</h2><p>Serial收集器适用于应用程序的内存小于100MB的场景.这种情况下应用程序只需要很小的堆,无论是Throughput收集器的并行收集,还是CMS和G1收集器的后台收集都发挥不了太大的作用.</p><h3 id="GC算法及批量任务"><a href="#GC算法及批量任务" class="headerlink" title="GC算法及批量任务"></a>GC算法及批量任务</h3><p>对于批处理任务而言,Throughput收集器所引入的停顿,尤其是Full GC停顿是主要的顾虑.如果有额外的CPU处理能力,那么Concurrent收集器将极大提高应用程序的性能.关键在于我们是否能够提供足够的CPU给Concurrent收集器的线程进行.<br><strong>备注:使用Throughput收集器处理应用程序线程的批量任务能最大程度的利用CPU的处理能力,通常能获得更好的性能;如果批处理任务并没有使用机器上的所有可用CPU资源,那么切换到Concurrent收集器往往能获得更好的性能.</strong></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li>衡量标准是响应时间或者吞吐量,在Throughput收集器和Concurrent收集器之间做选择的依据主要是有多少空闲的CPU资源能够用于运行后台的并发线程.</li><li>通常情况下,Throughput收集器的平均响应时间比Concurrent收集器要差,但是在90%的响应时间或者99%的响应时间这几项指标上,Throughput收集器比Concurrent收集器要好些.</li><li>使用Throughput收集器会超负荷地进行大量的Full GC,切换到Concurrent收集器通常会获得更低的响应时间.</li><li>选择Concurrent收集器时,如果堆较小,推荐使用CMS收集器.</li><li>G1的设计使得它能够在不同的分区处理堆,因此它的扩展性更好,比CMS更容易于处理超大堆的情况.</li></ol>]]></content>
    
    
    <summary type="html">垃圾收集入门.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>基于CentOS7制作带Docker的Vagrant基础Box</title>
    <link href="http://tanqidong1992.github.io/2021/03/12/2021/03/12/make-vagrant-base-box/"/>
    <id>http://tanqidong1992.github.io/2021/03/12/2021/03/12/make-vagrant-base-box/</id>
    <published>2021-03-12T13:33:45.000Z</published>
    <updated>2023-02-13T13:30:14.144Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化Vagrant工程并启动虚拟机"><a href="#初始化Vagrant工程并启动虚拟机" class="headerlink" title="初始化Vagrant工程并启动虚拟机"></a>初始化Vagrant工程并启动虚拟机</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant init <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure><p>Vagrantfile内容如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> |<span class="params">config</span>|</span><br><span class="line">config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="虚拟机中安装VBoxGuestAdditions"><a href="#虚拟机中安装VBoxGuestAdditions" class="headerlink" title="虚拟机中安装VBoxGuestAdditions"></a>虚拟机中安装VBoxGuestAdditions</h2><ol><li>将VBoxGuestAdditions.iso解压到Vagrant工程目录</li><li>执行安装命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kernel-headers kernel-devel gcc make</span><br><span class="line">sudo /VBoxGuestAdditions/VBoxLinuxAdditions.run</span><br></pre></td></tr></table></figure><p>备注: VBoxGuestAdditions.iso可以从Virtualbox安装目录下找到.</p><h2 id="虚拟机中安装Docker"><a href="#虚拟机中安装Docker" class="headerlink" title="虚拟机中安装Docker"></a>虚拟机中安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line">newgrp docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="设置不安全的ssh公钥"><a href="#设置不安全的ssh公钥" class="headerlink" title="设置不安全的ssh公钥"></a>设置不安全的ssh公钥</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8iallvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTBckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6kivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmBYSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYCzRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key</span><br><span class="line">&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><strong>备注:此步骤如果不进行,会导致基于此Box的虚拟机无法启动(ssh认证失败).</strong></p><h2 id="导出box"><a href="#导出box" class="headerlink" title="导出box"></a>导出box</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vagrant package --base &lt;Your VM Name&gt;</span></span><br><span class="line">vagrant package <span class="literal">--base</span> centos<span class="literal">-with-docker_default_1615543273586_25894</span></span><br></pre></td></tr></table></figure><p>在Vagrant工程目录可以看到导出的package.box.</p><h2 id="测试Box"><a href="#测试Box" class="headerlink" title="测试Box"></a>测试Box</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add <span class="literal">--name</span> my<span class="literal">-box</span> package.box</span><br><span class="line">mkdir <span class="built_in">test-box</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test-box</span></span><br><span class="line">vagrant init my<span class="literal">-box</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.vagrantup.com/docs/boxes/base">General Guide to Creating Base Box</a></li><li><a href="https://www.vagrantup.com/docs/providers/virtualbox/boxes">Creating a Virtualbox Base Box</a></li><li><a href="https://github.com/hashicorp/vagrant/tree/main/keys">insecure keypair</a></li></ol>]]></content>
    
    
    <summary type="html">基于CentOS7制作带Docker的Vagrant基础Box</summary>
    
    
    
    
    <category term="Vagrant" scheme="http://tanqidong1992.github.io/tags/Vagrant/"/>
    
    <category term="Vagrant Box" scheme="http://tanqidong1992.github.io/tags/Vagrant-Box/"/>
    
  </entry>
  
  <entry>
    <title>密码学的分类</title>
    <link href="http://tanqidong1992.github.io/2021/01/26/2021/01/26/category-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/26/2021/01/26/category-of-cryptography/</id>
    <published>2021-01-25T16:50:11.000Z</published>
    <updated>2023-02-13T13:30:13.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学的分类"><a href="#密码学的分类" class="headerlink" title="密码学的分类"></a>密码学的分类</h1><p>密码学起源于古代,发展于现代,随时间推移,密码学不断完善,拥有众多分支,可以从时间上,保密内容,密码体制等方面进行划分.</p><h2 id="分类的划分"><a href="#分类的划分" class="headerlink" title="分类的划分"></a>分类的划分</h2><h3 id="按时间划分"><a href="#按时间划分" class="headerlink" title="按时间划分"></a>按时间划分</h3><ul><li>古典密码:以字符为基本加密单元</li><li>现代密码:以信息块为加密单元</li></ul><h3 id="按保密内容的算法划分"><a href="#按保密内容的算法划分" class="headerlink" title="按保密内容的算法划分"></a>按保密内容的算法划分</h3><ul><li>受限(Restricted)算法:算法的保密性基于保持算法的秘密,一般不赞成使用这种算法,除非用于军事一类的应用,算法由专业机构开发,验证,确保其算法的安全性,这是古典密码学的主要特征.</li><li>基于密钥(Key-Based)算法:算法的保密性基于对密钥的保密.这是基于柯克霍夫原则设计的算法,算法的公开有助于算法安全性的验证,算法的漏洞得以及时修正,避免算法的设计者在算法上留下后门等.这是现代密码学的主要特征.</li></ul><h3 id="按密码体制划分"><a href="#按密码体制划分" class="headerlink" title="按密码体制划分"></a>按密码体制划分</h3><ul><li>对称密码体制:也称为单钥密码体制或私钥密码体制.指该密码体制中的加密密钥与解密密钥相同.</li><li>非对称密码体制:也称为双钥密码体制或者公钥密码体制.指该密码体制的加密密钥与解密密钥不同,密钥分公钥与私钥,公钥对外开放,私钥对外保密.</li></ul><p>备注:与上述密码体制对应的算法有对称密码算法和非对称密码算法.</p><ul><li>对称密码算法:也称为单钥密码算法或私钥密码算法,指对应于对称密码体制的加密,解密算法,常见的有DES,AES.</li><li>非对称密码算法:也称为双钥密码算法或公钥密码算法,指对于非对称密码体制的加密,解密算法,常见的算法有RSA,DSA,常用于数字签名,身份认证.</li></ul><p>非对称加密对于对称加密算法有着更高的安全性,却同时有着不可回避的加密解密耗时时长.</p><h3 id="按明文的处理方法划分"><a href="#按明文的处理方法划分" class="headerlink" title="按明文的处理方法划分"></a>按明文的处理方法划分</h3><ul><li>分组密码(Block Cipher):指加密时,将明文划分成固定长度的组,用同一个密钥和算法对每一块加密,输出也是固定长度的密码,分组加密多用于网络.</li><li>流密码(Stream Cipher):也称为序列密码,指加密时每次加密一位或一个字节的明文.手机平台对应用使用的系统资源有着极为苛刻的要求,流密码对于系统资源要求极低.RC4是相当有名的流密码算法.</li></ul><p>备注:手工加密阶段和机械加密阶段,流密码曾是当时的主流.现代密码学研究的主要关注点时分组密码和流密码及其应用,在对称密码体制中,大部分加密算法属于分组密码.</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><p>古典密码起始于古代终止于19世纪末,是现代密码学的基础.古典密码受限于当时的环境,以语言学为基础对文字进行字符变化(对字符加密),以达到信息加密的目的.古典密码加密算法最常用,最核心的两种加密技巧是位移和替代,这同样是对称加密算法最常用的方法.</p><ul><li>位移密码(Transposition Cipher):错位密码,将字符重新排序,例如”123456” 变成 “321654”.</li><li>替代密码(Substitution Cipher):也称置换密码,将明文中的一组字符替代为其他的字符,形成密文,例如”hello” 变成 “ifmmp”(每个字母使用下一个字母替代).著名的凯撒密码就应用了替代法.</li></ul><p>在古典加密时期,替代密码发展迅速,拥有众多分支,又分为以下几种:</p><ul><li>单表替代密码:也称为简单替代密码,明文的一个字符用相应的一个密文字符代替.加密过程是从明文字母表到密文字母表的一一映射.主要包括位移(shift)密码,乘数(multiplicative)密码,仿射(affine)密码,多项式(Polynomial)密码,密钥短语(Key Word)密码.</li><li>同音替代密码:也称多名替代密码.与单表替代系统相似,唯一不同的是单个字符明文可以映射成密文的几个字符之一.</li><li>多表替代密码(Polyalphabetic Substitution Cipher):明文中的字符映射到密文空间还依赖与它在上下文中的位置,由多个简单的替代密码构成.例如,可能有五个被使用的不同的简单替代密码,单独的一个字符用来改变明文的每个字符的位置.弗吉尼亚密码,博福特密码,滚动密钥密码,弗纳姆密码,转子机密码均为多表替代密码.第二次世界大战中,德军用的转子加密机Enigma,正是多表替代密码应用的典范.</li><li>多字母替代密码(Polygram Substitution Cipher):明文中的字符被成组加密,例如’ABA’可能对应于’RTQ’.希尔密码,Playfair密码均为多字母替代密码.第一次世界大战中英国人就采用这种密码.</li></ul><p>备注: 不管是位移密码还是替代密码,终究脱离不了人类的语言.针对该特点,通过对密文进行语义分析使得古典密码在破译上有章可循.例如凯撒密码是单表替代密码,要破解凯撒密码,只要以语言学为基础,找出使用频度最高的字符,例如’’和e’,用ascii码表示就是32和101,差值69,如果明文中两个出现最高的字符的ascii码相差69,那么对应加密后密文中相应出现频度最高的字符的ascii相差也一定是69,很显然,通过这样的分析方法,只要找出密文中与之对应的字符,计算偏移量(密钥),就可以破解密文,这就是著名的频度分析法.</p><h3 id="对称密码体制"><a href="#对称密码体制" class="headerlink" title="对称密码体制"></a>对称密码体制</h3><p>对称密码体制并不是现代密码学的新生事物,它是古典密码学的进一步延续.古典密码学常用的两种技巧替代和位移,仍然是对称加密体制中最重要的加密技巧.</p><p>对称密码体制要求加密和解密使用同一个密钥,解密时加密的逆运算,由于双方需要共享同一个密钥,这就要求双方必须在通信前商定该密钥,并妥善保存该密钥,该密钥称为秘密密钥,秘密密钥的存在使得对称加密体制开放性变差.</p><p>对称密码体制分为两种:一种是对明文的单个位(或字节)进行运算,称为流密码,也称为序列密码;另一种是把明文信息划分为不同的组(块)结构,分别对每个组(或块)进行加密和解密,称为分组密码.</p><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>流密码是军事,外交等机要部门中应用最广泛的对称密码体制,同时,它也是手机上应用平台最常用的加密手段.流密码实现较为简单,加密时将明文按字符(或字节)逐位进行加密,解密时将密文按字符(字节)逐位解密.加密和解密都是简单的位运算.明文加密后,生成的密文几乎和明文保持相同的长度.</p><p>流密码分为同步流密码和自同步流密码</p><h5 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h5><p>信息发送方与接收方在传递信息时,同步进行加密和解密操作,明文与密文一一对应.密文如果在传播过程中被篡改,删除或插入,可导致同步失效,以致密文解密失败,必须重新同步来实现解析,恢复密文.在密文传输过程中,如果某个位发生改变,那么该位的变化只影响该位的恢复,对后续密文位不受影响,这是同步流密码的一个重要特点.但是,根据该特性主动攻击者可以有选择地对密文字符进行改动,并准确知道这些改动对明文的影响.因此,同步流密码具有同步性,无错误传递及主动攻击性三种特性.同步流密码适用于为音频和视频数据提供版权保护.</p><h5 id="自同步流密码"><a href="#自同步流密码" class="headerlink" title="自同步流密码"></a>自同步流密码</h5><p>与同步流密码相比,自同步流密码是一种有记忆变换的密码.每一个密钥与已产生的固定数量的密文位有关,密钥由已生成的密文决定.在密文传输过程中,如果一个密文位发生改变,那么该位的变化会影响到后续有限位(如n位)的密文位的正确解密.所以自同步流密码具有错误传递现象,但是在接受n位正确密文字符后,密码会自身实现重新同步.基于这一特点,如果主动攻击者对密文做了修改,接收方仍然不能检测出密文的完整性.与同步流密码相比,自同步流密码的密码分析更加困难,安全性更高.因此自同步流具有自同步性,错误传递有限性,主动攻击性及明文统计扩散四种特征.</p><p>流密码实现简单,便于硬件计算,加密与解密处理速度快,错误传播率低等优点.但是,流密码对错误的产生不够敏感,这是流密码的缺点.流密码通常配合其他技术验证消息的完整性.流密码涉及大量的理论知识,受限于应用场景(目前主要运用与军事和外交等机要部门),许多研究成果并未完全公开.目前使用较多的流密码是自同步流密码.流密码的常用算法有RC4和SEAL.</p><p>流密码的安全强度依赖于密钥流生成器所产生的密钥流序列的特征,关键在与密钥生成器的设计以及消息收发两端密钥流产生的同步技术.</p><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p>分组密码多应用于网络加密,是对称密码体制中发展最为完善的密码体制.分组密码对固定长度的一组明文进行加密,这一固定长度称为分组长度.分组长度是分组密码的一个参数,它与算法的安全性成正比,其取值范围取决于实际应用的环境.</p><p>为保证分组算法的安全性,分组长度越长越好,分组长度越长,则密码分析越困难;为保证分组密码的实用性,分组长度越短越好,分组长度越短,则越便于操作和运算.分组长度的设定需要权衡分组算法的安全性与实用性,一般设置为56.随着密码学的发展,分组长度只有56位的分组密码已不能确保算法的安全性,目前,分组密码多选择128位作为算法的分组长度.</p><p>分组密码的加密过程是对一个分组长度为n位的明文进行加密操作,相应地产生一个n位的密文分组,由此可见不同的n位密文共有2^n个,考虑到加密算法的可逆性,每一个不同的n位明文都应该产生一个唯一的密文分组,加密过程对于的变换称为可逆变换或非奇异变换.所以,分组密码从本质上来说是定义了一种从分组的明文到相应密文的可逆变换.</p><p>分组密码是现代密码学的重要组成部分,具有代表的分组加密算法有DES,AES.</p><h5 id="分组密码设计原则"><a href="#分组密码设计原则" class="headerlink" title="分组密码设计原则"></a>分组密码设计原则</h5><p>分组密码的设计原则包括安全性和实现性两个方面.前者主要研究如何设计安全算法,分组长度和密钥长度;后者主要讨论如何提供算法的执行速度.</p><ol><li>针对于安全的一般设计原则</li></ol><blockquote><blockquote><p>安全性原则,也称为不可破译原则,它包含理论上不可破译和实际上不可破译两重含义.香农认为:在理想密码系统中,密文的所有统计特性都与所使用的密钥独立.关于实用密码的两个一般原则是香农提出的混乱原则和扩散原则.</p><ul><li>扩散(Diffusion)原则:人们所设计的密码应使得密钥的每一位数字影响到密文的多位数字,以防止对密钥进行逐段破译,而且明文的每一位数字也影响密文的多位数字以便隐藏明文数字的统计性.</li><li>混乱(Confusion)原则:人们所设计的密码应使得密钥和明文之间的信赖关系相当复杂以至于这种信赖对密码分析者来说是无法利用的.<br>衡量密码体制的安全性,主要提现在以下几个方面:</li><li>密码体制的破译所需要的时间和费用超过了现有的资源和能力.</li><li>密码体制的破译所需要的时间超过了该体制保护的信息的有效时间.</li><li>密码体制的破译所需要的费用超过了该体制所保护信息的价值.</li></ul><ol start="2"><li>针对实现的设计原则<br>分组密码可以用软件和硬件来实现.硬件实现的优点是可获得高效率,而软件实现的优点是灵活性高,代价低.</li></ol><ul><li>软件设计原则:使用子块和简单的运算,密码运算在子块上进行,要求子块的长度能自然地适应软件编程,如8,16,32位等.应避免按位置换,在子块所进行的密码运算尽量采用易于软件实现的运算.最好是使用处理器的基本运算,如加法,乘法,移位.</li><li>硬件设计原则:加密和解密的相似性,即加密和解密的过程的不同应局限于密钥使用方式上,以便采用同样的器件来实现加密和解密,以节省费用和体积.尽量采用标准组件结构,以便适应于在超大规模集成电路中实现.</li></ul><h5 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h5><p>我们以DES算法工作模式为例,DES算法根据其加密算法所定义的明文分组长度(56位),将数据分为若干56位的加密区块,再以区块为单位,分别进行加密处理.如果最后剩下不足一个区块的大小,我们称之为短块,短块的处理方法有填充法,流密码加密法,密文挪用技术.</p></blockquote></blockquote><p>1980年12月,DES算法工作模式被美国联邦信息处理标准组织(FIPS)标准化.加密算法应用的复杂性,有的强调效率,有的强调安全,有的强调容错性.根据数据加密时每个加密区块间的关联方式来区别,可以分为四种工作模式:电子密码本模式(Electronic Code Book,ECB),密文链接模式(Cipher Book Chaining,CBC),密文反馈模式(Cipher Feed Back,CFB),输出反馈模式(Output Feed Back,OFB),AES标准除了推荐上述四种工作模式外,还推荐一种新的工作模式:计数器模式(Counter,CTR).这些工作模式可适用于各种分组密码算法.</p><ul><li>电子密码本模式(ECB)</li></ul><blockquote><blockquote><p>电子密码本模式,它是最基本,最简单的工作模式.每次加密均产生独立的密文分组,每组的加密结果不会对其他分组产生影响,相同的明文加密后对应产生相同的密文,无初始化向量(也称为加密向量).可以认为有一个非常大的电码本,对任意一个可能的明文分组,电码本都有一项对应它的密文,这也是该模式名称的由来.</p><p>优点:易于理解且简单易行;便于实现并行操作;没有误差传播;</p><p>缺点:不能隐藏明文的模式,如果明文重复,对应的密文也会重复,密文内容很容易被替换,重排,剔除,重放,对明文进行主动攻击的可能性较高.</p><p>用途:适合加密密钥,随机数等短数据.例如安全传递DES密钥,ECB模式是最合适的.</p><ul><li>密文链接模式(CBC)<br>密文链接模式,它是目前应用最广泛的工作模式.明文加密前先需先与前面的密文进行异或(XOR)运算然后再加密,因此只要选择不同的初始向量,相同的明文加密后产生不同的密文.</li></ul><p>优点: 密文链接模式加密后的密文上下文关联,即使明文中出现重复的信息也不会产生相同的明文;密文内容如果被替换,重排,删除,重放或者网络传输过程中发生错误,后续密文即被破坏,无法完成解密还原;对明文的主动攻击性较低.</p><p>缺点: 不利于并行计算,目前没有已知的并行运算算法;误差传递,如果在加密过程中发生错误,则错误将被无限放大,导致加密失败;需要初始化向量.</p><p>用途: 可加密任意长度消息;适用于计算产生检测数据完整性的消息认证码MAC</p><ul><li>密文反馈模式(CFB)<br>密文反馈模式,它类似于自同步流密码,分组加密后,按8位分组将密文和明文进行移位异或后得到输出同时反馈回移位寄存器.它的有点是可以按字节逐个进行加密解密,也可以按n位字节处理.CFB是上下文关联的,明文的一个错误会影响后面的密文(错误扩散).CFB需要一个初始化向量,加密后与第一个分组进行异或运算产生第一组密文;然后对第一组密文进行加密后在与第二组进行异或运算取得第二组密文,以此类推,直到加密完成.<br>优点: 隐藏了明文的模式,每一个分组的加密结果必受其前面所有分组内容的影响,即使出现多次相同的明文,均产生不同的密文;分组密码转化为流模式,可产生密钥流;可以及时加密传送小于分组的数据</li></ul><p>缺点: 与CBC类似.不利于并行计算,目前没有已知的并行运算算法;存在误差传播,一个单元的损坏影响多个单元;需要初始化向量.</p><p>用途: 因错误传播无解,可用于检查发现明文密文的篡改.</p><ul><li>输出反馈模式(OFB)<br>输出反馈模式,它将分组密码作为同步流密码运行,和CFB相似,不过OFB用的是前一个n位密文输出分组反馈回移位寄存器,OFB没有错误扩散问题.该模式产生与明文异或运算的密钥流,从而产生密文,这一点与CFB相似,唯一不同的差异是与明文分组进行异或的输入那部分是反复加密后得到的.<br>优点: 隐藏明文的模式;分组密码转化为流模式;无误差传递问题;可以及时加密传送小于分组的数据.</li></ul><p>缺点: 不利于并行计算;对明文的主动攻击是可能的,安全性较CFB差.</p><p>用途: 适用于加密冗余性较大的数据,比如语言和图像数据.</p><ul><li>计数器模式(CTR)<br>计数器模式,它的特点是将计数器从初始值开始计数所得到的值发送给分组密码算法.随着计数器的增加,分组密码算法输出连续的分组来构成一个位串,该位串被用来与分组明文进行异或操作.计数器模式是用来提取分组密码的最大能效以实现保密性.在AES的实际应用中,经常会选择CBC和CTR模式,但更多的是选择CTR模式.<br>优点: 可并行计算;安全性至少和CBC一样好;加密和解密仅涉及密码算法的加密</li></ul><p>缺点: 没有错误传播,因此不易确保数据完整性.</p><p>用途: 适用于各种加密.</p><h3 id="非对称密码体制"><a href="#非对称密码体制" class="headerlink" title="非对称密码体制"></a>非对称密码体制</h3><p>1976年,密码学专家diffie和hellman在&lt;&lt;密码学的新方向&gt;&gt;一文中提出公开密钥体制的思想,开创了现代密码学的新领域,非对称密码体制的篇章由此揭开.</p></blockquote></blockquote><p>非对称密码体制与对称密码体制相对;其主要区别是:非对称密码体制的加密密钥与解密密钥不相同,分为两个密钥,一个公开,一个保密.公开的密钥称为公钥,保密的密钥称为私钥.因此,非对称密码体制也称为公钥密码体制.非对称密码体制使得发送者与接受者无密钥传输的保密通信成为可能,弥补了对称密码体制的缺陷.</p><p>非对称密码体制的主要优点是可以适应开发性的使用环境,密钥管理问题相对简单,可以方便,安全地实现数字签名和验证.RSA是非对称密码体制的典范,它不仅可以完成一般的数据保密操作,同时它也支持数字签名与验证.</p><p>非对称密码算法的安全性完全依赖于基于计算复杂度上的难题,通常来自于数论.例如RSA源于整数因子分解问题;DSA数字签名算法,源于离散对数问题;ECC椭圆曲线加密算法,源于离散对数问题.由于这些数学难题的实现涉及底层模数乘法或指数运算,相对于分组密码需要使用更多的计算,为了弥补这一缺陷,非对称密码系统通常是复合式的:用高效率的对称密码算法对信息进行加密解密处理;用非对称密钥加密对称密码系统所使用的密钥.通过这种复合方式增进效率.</p>]]></content>
    
    
    <summary type="html">密码学的分类</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学定义与术语</title>
    <link href="http://tanqidong1992.github.io/2021/01/25/2021/01/25/terms-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/25/2021/01/25/terms-of-cryptography/</id>
    <published>2021-01-24T16:20:01.000Z</published>
    <updated>2023-02-13T13:30:14.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学定义与术语"><a href="#密码学定义与术语" class="headerlink" title="密码学定义与术语"></a>密码学定义与术语</h1><h2 id="密码学的定义"><a href="#密码学的定义" class="headerlink" title="密码学的定义"></a>密码学的定义</h2><p>密码学:主要研究保密通信和信息保密的问题,包括信息保密传输和信息加密存储等.密码学包括密码编码学(Cryptography)和密码分析学(Cryptanalyst).编码学与分析学相互促进,又相互制约.一方面,两者在加强密码分析的安全上相互促进;另一方面,两者在实施更为有效的攻击方面也相互影响.</p><ul><li>密码编码学:主要研究对信息进行编码,实现对信息的隐蔽,是密码学理论的基础,也是保密系统设计的基础.</li><li>密码分析学:主要研究加密信息的破译或信息的伪造,是校验密码体制安全性最直接的手段,只有通过实际密码分析考验的密码体制,才是真正可用的.</li></ul><h2 id="密码学常用术语"><a href="#密码学常用术语" class="headerlink" title="密码学常用术语"></a>密码学常用术语</h2><ul><li>明文(plaintext):待加密信息,明文可以是文本文件,图像文件,二进制数据等.</li><li>密文(ciphertext):经过加密后的明文,密文通常以文本,二进制数据等形式存在.</li><li>发送者(sender):指发送消息的人.</li><li>接受者(receiver):指接受消息的人.</li><li>加密(Encryption):指将明文转化为密文的过程.</li><li>加密算法(Encryption Algorithm):指将明文变化为密文的转化算法.</li><li>解密(Decryption):指将密文转化为明文的过程.</li><li>解密算法(Decryption Algorithm):指将密文转化为明文的转化算法.</li><li>解密密钥(Decryption Key):指通过解密算法进行解密操作用的密钥.</li><li>密码分析(Cryptanalysis):指截获密文者试图通过分析截获的密文从而推断出原来的明文或者密钥的过程.</li><li>密码分析者(Cryptanalyst):等同于密码破译者,指从事密码分析的人.</li><li>被动攻击(Passive Attack):指对一个保密系统采取截获密文并对其进行分析和攻击.这种攻击对密文没有破坏作用.</li><li>主动攻击(Active Attack):指攻击者非法入侵密码系统,采用伪造,修改,删除等手段向系统注入假消息进行欺骗.这种攻击对密文具有破坏作用.</li><li>密码体制(Cipher System):由明文空间,密文空间,密钥空间,加密算法和解密算法五部分构成.</li><li>密码协议(Cryptographic Protocol):有时也称为安全协议,指以密码学为基础的信息交换的通信协议,其目的是在网络环境中提供各种安全服务.密码协议与密码算法同等重要,堪称当今密码学研究的两大课题.密码学是网络安全的基础,但网络安全不能单纯依赖安全的密码算法.密码协议是网络安全的一个重要组成部分,通过密码协议进行实体间的认证,在实体间安全地分配密钥或其他各种秘密,确认发生和接受的消息的不可否认性等.</li><li>密码系统(Cryptography):指用于加密和解密的系统.加密时,系统输入明文和加密密钥,加密变化后,输出密文;解密时,系统输入密文和解密密钥,解密变换后,系统输出明文.一个密码系统由信源,加密变换,解密变换,信宿和攻击者组成.密码系统强调密码方案的实际应用,通常应当是一个包含软,硬件的系统.</li><li>柯克霍夫原则(Kerckhoffs’ Principle):数据的安全基于密钥而不是算法的保密.信息论始祖香农将其改为敌人了解系统,这样的说法成为香农箴言.柯克霍夫原则是现代密码学设计的基本原则</li></ul>]]></content>
    
    
    <summary type="html">密码学定义与术语</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学发展历史</title>
    <link href="http://tanqidong1992.github.io/2021/01/24/2021/01/24/history-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/24/2021/01/24/history-of-cryptography/</id>
    <published>2021-01-24T15:47:01.000Z</published>
    <updated>2023-02-13T13:30:14.088Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码学发展历史"><a href="#密码学发展历史" class="headerlink" title="密码学发展历史"></a>密码学发展历史</h2><h3 id="手工加密阶段"><a href="#手工加密阶段" class="headerlink" title="手工加密阶段"></a>手工加密阶段</h3><p>使用手工方式完成加密操作,以确保战争中的军事信息的秘密传输,这一阶段称为手工加密.比如中国古代的阴符,阴书;</p><h3 id="机械加密阶段"><a href="#机械加密阶段" class="headerlink" title="机械加密阶段"></a>机械加密阶段</h3><p>19世纪至20世纪初,工业革命促进了机械和机电技术的发展,加速了密码设备的变革-转轮密码机的发明,密码学进入机械加密阶段.密码分析在第一次,第二次世界大战都扮演了重要角色.</p><h3 id="计算机加密阶段"><a href="#计算机加密阶段" class="headerlink" title="计算机加密阶段"></a>计算机加密阶段</h3><p>第二次世界大战之后,计算机与电子学快速发展,促进了密码学进入计算机加密阶段.计算机成为了密码设计与破译的平台.</p><ul><li>利用计算机可以设计出更复杂的加密算法,避免手工设计时容易造成错误.</li><li>利用计算机可以对加密算法进行破译,缩短了破译时间.</li></ul><p>1949年前,密码学是一门艺术,1949年-1975年,密码学成为科学,1976年以后,密码学有了新的方向-公钥密码学;1977年以后,密码学广泛应用到各种场所.</p><ul><li>1949年,信息论始祖香农发表&lt;&lt;保密系统的通信理论&gt;&gt;,把密码学建立在严格的数学基础上,为密码学的发展奠定了理论基础.密码学由此成为一门真正的科学,在此之前,密码学完全是一门艺术,密码的设计和分析完全依赖于密码专家的直觉</li><li>1976年,密码学专家迪菲和赫尔曼两人发表&lt;&lt;密码学的新方向&gt;&gt;,解决了密钥管理的难题,把密钥分为加密的公钥和解密的私钥,提出密钥交换算法(Diffie-Hellman D-H),这是密码学的一场革命.</li><li>1977年,美国国家标准技术研究所(NIST)制定数据加密标准(Data Encryption Standard,DES),将其颁布为国家标准,这是密码学历史上一个具有里程碑意义的事件.</li><li>1977年,密码学家李维斯特,沙米尔,阿德勒曼在麻省理工学院,共同提出第一个比较完善的公钥密码体制-RSA体制(建立在大数因子分解基础上的算法),RSA为数字签名奠定了基础,RSA源于整数因子分解问题,DSA源于离散对数问题.RSA和DSA是两种最流行的数字签名机制.数字签名是PKI,网络安全机制的基础.从此以后,密码学成为通信,计算机网络,计算机安全等方面的重要工具.</li><li>1985年,英国牛津大学物理学家戴维.多维奇提出量子计算机的初步设想.利用量子计算机,仅需30秒钟即可完成传统计算机花上100亿年才能完成的大数因子分解,从而破解RSA运用这个大数产生公钥来加密的信息.</li><li>1985年,物理学家贝内特根据多维奇关于量子密码术的协议,在实验室中第一次实现了量子密码加密信息通信.尽管通信距离只有30cm.</li><li>1997年1月,美国国家标准技术研究所征集新一代数据加密标准,即高级数据加密标准(Advanced Encryption Standard,AES).最终比利时密码学家兼计算机科学家Vincent Rihmen和Joan Daemen设计的Rijndael算法入选.高级数据加密标准用以替换原先的DES,2002年5月26日,美国国家标准技术研究所将其定位有效加密标准.</li><li>2003年,位于日内瓦的id Quantique公司和位于纽约的MagiQ技术公司,推出了传送量子密钥的距离超过贝内特实验室中30cm的商业产品.由此,量子密码学进入商业化.</li></ul><p>进入计算机加密阶段后,密码学的应用不再局限于军事,政治和外交领域,逐步扩大到商务,金融和社会的其他各个领域.密码学的研究和应用已大规模扩展到了民用方面.</p>]]></content>
    
    
    <summary type="html">密码学发展历史</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="历史" scheme="http://tanqidong1992.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础</title>
    <link href="http://tanqidong1992.github.io/2021/01/04/2021/01/04/base-of-rust/"/>
    <id>http://tanqidong1992.github.io/2021/01/04/2021/01/04/base-of-rust/</id>
    <published>2021-01-04T02:28:47.000Z</published>
    <updated>2023-02-13T13:30:14.146Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust基础"><a href="#Rust基础" class="headerlink" title="Rust基础"></a>Rust基础</h1><h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><p>在Rust中变量是默认不可变的,如果要定义一个可变变量必须使用<strong>mut</strong>修饰.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="number">5</span>; <span class="comment">//x是不可变的变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutable_variable</span>=<span class="number">6</span>; <span class="comment">// mutable_variable是可变变量</span></span><br></pre></td></tr></table></figure><h2 id="变量与常量的区别"><a href="#变量与常量的区别" class="headerlink" title="变量与常量的区别"></a>变量与常量的区别</h2><ol><li>常量不只是不可变,而是一直不可变.</li><li>你需要使用const而不是let声明一个常量,必须加上数据类型注解 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINT:<span class="type">u32</span>=<span class="number">12_000</span>;</span><br></pre></td></tr></table></figure></li><li>常量可以定义在任何作用域.</li><li>常量必须设定成一个常量表达式,既不是一个函数的结果,也不是其他只能在运行时计算出的结果.</li></ol><h2 id="Shadowing"><a href="#Shadowing" class="headerlink" title="Shadowing"></a>Shadowing</h2><p>同一个变量名可以多次定义,后一次定义会覆盖前一次的定义,如下所示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">i32</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>:<span class="type">u32</span>=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>备注: Shadowing不同与mut,Shadowing是定义一个新的变量.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Rust中有两种数据类型子集:标量(Scalar),混合量(Compound);</p><h3 id="标量-Scalar"><a href="#标量-Scalar" class="headerlink" title="标量(Scalar)"></a>标量(Scalar)</h3><p>标量类型代表单个值.Rust有四种基本的标量类型:整型,浮点型,字符型,布尔型.</p><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><table><thead><tr><th align="center">长度</th><th align="center">有符号</th><th align="center">无符号</th></tr></thead><tbody><tr><td align="center">8bit</td><td align="center">i8</td><td align="center">u8</td></tr><tr><td align="center">16bit</td><td align="center">i16</td><td align="center">u16</td></tr><tr><td align="center">32bit</td><td align="center">i32</td><td align="center">u32</td></tr><tr><td align="center">64bit</td><td align="center">i64</td><td align="center">u64</td></tr><tr><td align="center">128bit</td><td align="center">i128</td><td align="center">u128</td></tr><tr><td align="center">arch</td><td align="center">isize</td><td align="center">usize</td></tr></tbody></table><p>备注:</p><ul><li>有符号的取值范围为 -2^(n-1) – 2^(n-1)-1;</li><li>无符号的取值范围为 0 – 2^n-1</li><li>isize和usize的长度,取决于架构类型,如果是64位架构,那就是64bit,如果是32位架构,那就是32bit.</li></ul><h5 id="整数的字面量书写形式"><a href="#整数的字面量书写形式" class="headerlink" title="整数的字面量书写形式"></a>整数的字面量书写形式</h5><table><thead><tr><th align="center">字面量</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center">十进制(Decimal)</td><td align="center">10_000</td></tr><tr><td align="center">十六进制(Hex)</td><td align="center">0xff</td></tr><tr><td align="center">八进制(Octal)</td><td align="center">0o12</td></tr><tr><td align="center">二进制(Binary)</td><td align="center">0b111_000</td></tr><tr><td align="center">Byte(u8)</td><td align="center">b’A’</td></tr></tbody></table><h5 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h5><p>当发生整型溢出时,Debug模式下Rust会检查并抛出错误信息,而在Release(–release)模式下,Rust不会检查,Rust执行二进制补码包装.例如u8类型,256变成0,257变成1.</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>Rust支持单精度已经双精度的浮点类型分别为f32,f64,参考IEEE-754标准.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">f1</span>=<span class="number">3.0</span>; <span class="comment">// f1 data type is f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">f2</span>:<span class="type">f32</span>=<span class="number">3.0</span>; <span class="comment">//f2 data type is f32</span></span><br></pre></td></tr></table></figure><p><strong>备注:默认的浮点类型为f64,现代的cpu对于f64与f32的处理速度差不多,而f64进度更高.</strong></p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><h4 id="布尔类型-Boolean"><a href="#布尔类型-Boolean" class="headerlink" title="布尔类型(Boolean)"></a>布尔类型(Boolean)</h4><p>Rust中的布尔类型为bool,占用1个字节,可取值为false,true;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="字符类型-Character"><a href="#字符类型-Character" class="headerlink" title="字符类型(Character)"></a>字符类型(Character)</h4><p>Rust中的字符类型关键字为char,占用4个字节,存储Unicode标准值.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span>=<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="混合量-Compound"><a href="#混合量-Compound" class="headerlink" title="混合量(Compound)"></a>混合量(Compound)</h2><p>混合量表示可以含有多个值的数据类型.Rust支持两种基本的混合量:元组(Tuple),数组(Array)</p><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><p>元组是由不同类型的多个值组成的一个混合量,元组具有固定的长度,一旦声明,无法增加或者减少.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> (x,y,z)=tup;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">first_number</span>=tup.<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组是由多个同类型的值组成的一个混合量,不同于元组,数组的每一个值的类型都是一样的,数组的长度是固定的.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//指定类型为i32,长度为3</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span>[<span class="type">i32</span>;<span class="number">3</span>]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//重复5次填充3</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">repeat</span>=[<span class="number">3</span>;<span class="number">5</span>]; <span class="comment">// as [3,3,3,3,3];</span></span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first_element</span>=a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>备注:Rust会对数组访问进行越界检查,越界访问会抛出异常(panic)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数由fn关键字,函数名,参数列表,返回类型,函数体组成;其中参数列表,返回类型可以省略;<br>语法如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值,无参数</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">test</span>()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">area</span>(width:<span class="type">u32</span>,height:<span class="type">u32</span>)<span class="punctuation">-&gt;</span><span class="type">u32</span>&#123;</span><br><span class="line"><span class="keyword">return</span> width*height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>函数体可以包含语句以及表达式(表达式只能在尾部作为返回值)</p><p>备注:语句与表达式:语句是执行一些动作但没有返回值的指令;表达式被计算有一个结果.<br>例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line"><span class="comment">//error: expected expression, found statement (`let`)</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=(<span class="keyword">let</span> <span class="variable">y</span>=<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comment</span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span>=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">10</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> x&gt;<span class="number">5</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="let语句中使用if表达式"><a href="#let语句中使用if表达式" class="headerlink" title="let语句中使用if表达式"></a>let语句中使用if表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x=4;</span><br><span class="line">ley y= if x&gt;0 &#123;</span><br><span class="line">1</span><br><span class="line">&#125;else&#123;</span><br><span class="line">-1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注:各个分支的返回必须是相同的.</strong></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="无限循环-loop"><a href="#无限循环-loop" class="headerlink" title="无限循环(loop)"></a>无限循环(loop)</h4><p>loop关键字,循环执行一段指令,直到显示的停止;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;Again!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop循环体是可以返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let n=1;</span><br><span class="line">let sum=loop&#123;</span><br><span class="line">n=n+1;</span><br><span class="line">if n &gt;= 10 &#123;</span><br><span class="line">break n*2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件循环-while"><a href="#条件循环-while" class="headerlink" title="条件循环(while)"></a>条件循环(while)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">n</span>=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> n&gt;<span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>,n);</span><br><span class="line">n=n-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历-for"><a href="#遍历-for" class="headerlink" title="遍历(for)"></a>遍历(for)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> a.<span class="title function_ invoke__">iter</span>()&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value is :&#123;&#125;&quot;</span>,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="variable">number</span> <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>)&#123;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Rust基础语法</summary>
    
    
    
    
    <category term="Rust" scheme="http://tanqidong1992.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>进程内存</title>
    <link href="http://tanqidong1992.github.io/2020/12/21/2020/12/21/process-momory/"/>
    <id>http://tanqidong1992.github.io/2020/12/21/2020/12/21/process-momory/</id>
    <published>2020-12-20T23:20:17.000Z</published>
    <updated>2023-02-13T13:30:14.058Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程内存"><a href="#进程内存" class="headerlink" title="进程内存"></a>进程内存</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>进程内存占用主要由以下几部分组成:</p><ul><li>自身代码</li><li>共享库代码</li><li>运行过程中分配的堆和栈</li><li><del>通过mmap映射的磁盘文件内容</del></li></ul><h2 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h2><p>物理内存对于进程来说是透明的,进程直接操作的是虚拟内存.进程向操作系统申请内存的时候,分配的是虚拟内存(地址空间),只有当进程使用这部分内存时,操作系统才会将相应的物理内存与相应的虚拟内存关联(缺页中断).</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>从进程来看,虚拟内存是进程独立的,所有内存都是私有的,包括自身代码,共享库,堆栈等.但实际在物理层面很多东西是可以共享的,比如共享库,自身代码,甚至是自身私有的堆栈.</p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>同一个共享库的代码在物理内存中只存在一份,这块内存会映射到不同进程的虚拟内存中,对进程而言是自己的私有内存,对于操作系统而言,则是节省了内存的资源.</p><h3 id="进程的自身代码"><a href="#进程的自身代码" class="headerlink" title="进程的自身代码"></a>进程的自身代码</h3><p>当同一个程序运行多个进程时,其自身代码也被共享</p><h3 id="进程的私有内存"><a href="#进程的私有内存" class="headerlink" title="进程的私有内存"></a>进程的私有内存</h3><p>当从一个进程fork出一个子进程时,那么父进程的私有内存则会与子进程共享,但会被标记为copy-on-write.</p><h2 id="进程内存大小的度量方法"><a href="#进程内存大小的度量方法" class="headerlink" title="进程内存大小的度量方法"></a>进程内存大小的度量方法</h2><h3 id="VSZ-Virtual-Memory-Size"><a href="#VSZ-Virtual-Memory-Size" class="headerlink" title="VSZ(Virtual Memory Size)"></a>VSZ(Virtual Memory Size)</h3><p>虚拟内存大小,进程运行理论上需要内存的大小,形容进程运行时所需要的总内存大小,包括哪些还没有被加载到实际内存中的代码和数据.</p><h3 id="RSS-Resident-Set-Size"><a href="#RSS-Resident-Set-Size" class="headerlink" title="RSS(Resident Set Size)"></a>RSS(Resident Set Size)</h3><p>常驻内存大小(工作集),表示实际使用物理内存的大小,包含了共享库占用的内存,(不包括已经被置换到磁盘的内存)</p><h3 id="PSS-Proportional-Set-Size"><a href="#PSS-Proportional-Set-Size" class="headerlink" title="PSS(Proportional Set Size)"></a>PSS(Proportional Set Size)</h3><p>实际使用物理内存大小,比例分配共享库占用的内存,比如用到的某个100K共享库共有2个程序用到,那么被计算为100k&#x2F;2&#x3D;50k</p><h3 id="USS-Unique-Set-Size"><a href="#USS-Unique-Set-Size" class="headerlink" title="USS(Unique Set Size)"></a>USS(Unique Set Size)</h3><p>进程独占物理内存大小,不包含共享库.</p><h2 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h2><p>假如要度量进程占用的内存大小，较好的选择是使用PSS，用RSS也行，不过要注意有些内存是和别的进程共享的。</p><p>再举个例子总结一下前面三个概念，比方一个进程有500K的代码并且链接了2500K的共享库，而后有200K的堆栈分配。其中有400K自身的代码、1000K的共享库以100K的堆栈内存被加载在实际内存（RAM）中，并且系统中一共有两个进程用了同样的共享库。那么：</p><p>VSZ：500K + 2500K + 200K &#x3D; 3200K</p><p>RSS：400K + 1000K + 100K &#x3D; 1500K</p><p>PSS：400K + (1000K &#x2F; 2) + 100K &#x3D; 1000K</p><p>USS: 400K + 100K &#x3D; 500K</p>]]></content>
    
    
    <summary type="html">进程内存说明</summary>
    
    
    
    
    <category term="进程内存" scheme="http://tanqidong1992.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
</feed>
