<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>芷兰旧梦</title>
  
  <subtitle>偶尔记一些东西</subtitle>
  <link href="http://tanqidong1992.github.io/atom.xml" rel="self"/>
  
  <link href="http://tanqidong1992.github.io/"/>
  <updated>2021-10-12T07:44:15.584Z</updated>
  <id>http://tanqidong1992.github.io/</id>
  
  <author>
    <name>QidongTan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Modbus</title>
    <link href="http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/"/>
    <id>http://tanqidong1992.github.io/2021/09/02/2021/09/02/modbus/</id>
    <published>2021-09-02T13:51:33.000Z</published>
    <updated>2021-10-12T07:44:15.584Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Modbus"><a href="#Modbus" class="headerlink" title="Modbus"></a>Modbus</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Modbus是一个位于应用层的消息传递协议,位于OSI模型第七层.它为连接在不同总线或者网络上的设备之间提供客户端/服务器通信.</p><p>自1979年以来,Modbus一直是业界公认的串行标准,至今仍在为数以百万计的自动化设备提供通信服务.</p><p>Modbus是一种请求应答协议,提供功能代码(Function Code)指定的服务.</p><p>目前它主要基于以下几种媒介实现:</p><ul><li>TCP/IP over Ethernet.</li><li>Asynchronized serial transmission over a variety of media(EIA/TIA-232-E(RS-232),EIA-422,EIA/TIA-485-A(RS-485),光纤,无线广播等).</li><li>Modbus PLUS,高速令牌传递网络.<br>  备注: Modbus在TCP/IP协议栈上的保留端口为502.</li></ul><h2 id="Modbus通信协议栈"><a href="#Modbus通信协议栈" class="headerlink" title="Modbus通信协议栈"></a>Modbus通信协议栈</h2><p><img src="/2021/09/02/2021/09/02/modbus/13c1589682ee03c3f75e7d1bad2d648814404ea831a04a5b79844e3083235421.png"></p><h2 id="Modbus网络架构"><a href="#Modbus网络架构" class="headerlink" title="Modbus网络架构"></a>Modbus网络架构</h2><p><img src="/2021/09/02/2021/09/02/modbus/16f17ef21174125f87a87742bdc0505306493e192057aa0662ad440dc5f87fd8.png"></p><h2 id="协议描述"><a href="#协议描述" class="headerlink" title="协议描述"></a>协议描述</h2><h3 id="协议组成"><a href="#协议组成" class="headerlink" title="协议组成"></a>协议组成</h3><p>Modbus定义了一个简单,独立于通信层的协议数据单元(PDU).Modbus协议在特定总线或者网络上的实现,可以在应用数据单元(ADU)中引入额外的字段.一般的Modbus数据帧如下图所示:</p><p><img src="/2021/09/02/2021/09/02/modbus/50c74b7c1aff238ec130f2da8fe1ddb6ca022847605320ebaf0aff3015c855d2.png"></p><h4 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h4><p>PDU由功能码(Function Code)，数据组成：</p><ul><li>功能码指明了服务器应该执行何种操作.它被编码为1个字节,取值范围为[1,255]的整数(其中128-255被保留,作为异常码使用),<strong>在一些功能码中添加子功能码(子功能代码位于数据字段内),可以为一个功能码定义多个操作.</strong></li><li>数据是客户端传递给服务端为执行执行功能码指定操作的附带信息,可以是离散地址,寄存器地址,要处理项的数量等.在某些类型的请求中,数据字段可能不存在.</li></ul><p>PDU的最大值为256字节,这个最大值受限于第一个modbus在串口网络的实现(max RS485 ADU = 256 bytes)</p><p>因此:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modbus PDU for serial line communication = 256 - Server address (1 byte) - CRC(2 bytes) = 253 bytes</span><br></pre></td></tr></table></figure><p>故而</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RS232/RS485 ADU = 253 + Server Address (1 byte) + CRC (2 bytes) = 256 bytes</span><br><span class="line">TCP Modbus ADU = 253 bytes + MBAP( 7 bytes ) = 260 bytes</span><br></pre></td></tr></table></figure><p>Modbus 一共定义了三种PDU</p><ul><li>Modbus Request PDU, mb_req_pdu.</li><li>Modbus Response PDU, mb_rsp_pdu.</li><li>Modbus Exception Response PDU, md_excep_rsp_pdu.</li></ul><h5 id="Modbus-Request-PDU"><a href="#Modbus-Request-PDU" class="headerlink" title="Modbus Request PDU"></a>Modbus Request PDU</h5><p>由功能码 + 请求数据组成:<br>功能码: 1个字节,<br>请求数据: n个字节,可取值:变量引用,变量数量,数据偏移,子功能代码等.</p><h5 id="Modbus-Response-PDU"><a href="#Modbus-Response-PDU" class="headerlink" title="Modbus Response PDU"></a>Modbus Response PDU</h5><p>由功能码 + 响应数据组成:<br>功能码: 1个字节,<br>响应数据: n个字节,可取值:变量引用,变量数量,数据偏移,子功能代码等.</p><h5 id="Modbus-Exception-Response-PDU"><a href="#Modbus-Exception-Response-PDU" class="headerlink" title="Modbus Exception Response PDU"></a>Modbus Exception Response PDU</h5><p>由异常功能码 + 请求数据组成:<br>异常代码: 1个字节,是功能代码+0x80.</p><h4 id="ADU"><a href="#ADU" class="headerlink" title="ADU"></a>ADU</h4><h5 id="ADU-Modbus-Frame-with-Serial-Transmission"><a href="#ADU-Modbus-Frame-with-Serial-Transmission" class="headerlink" title="ADU(Modbus Frame with Serial Transmission)"></a>ADU(Modbus Frame with Serial Transmission)</h5><p>基于串口通信的ADU由设备地址(1 bytes),PDU(253 bytes),错误校验组成(2 bytes).</p><h5 id="ADU-Modbus-Frame-With-TCP-IP-Transmission"><a href="#ADU-Modbus-Frame-With-TCP-IP-Transmission" class="headerlink" title="ADU(Modbus Frame With TCP/IP Transmission)"></a>ADU(Modbus Frame With TCP/IP Transmission)</h5><p>基于TCP/IP实现的ADU由MBAP(7 bytes),PDU(253 bytes)组成.<br>MBAP由事务标识符,协议标识符,长度,单位标识符组成,如下图所示:</p><p><img src="/2021/09/02/2021/09/02/modbus/9455a09929f72233e465759915ee7948627087c5b82795e7dab873f2ebb7bd7e.png">- 事务标识符,用于事务匹配,服务器在响应中复制客户端请求中的值.如果客户端在每次查询时生成唯一的表示符,则可以为此查询分配唯一的响应.</p><ul><li>协议标识符,由于使用Modbus协议,因此此字段始终为0.</li><li>长度,数据长度,包括单位标识符(1 byte),函数代码(1 byte)和数据.</li><li>单位标识符,对应基于串口通信的Modbus协议ADU中的设备地址.此字段用于内部系统路由,如果控制器不支持路由,此字段始终为0.</li></ul><p>备注:由于TCP/IP数据链路层的校验机制保证了数据的完整性,因此Modbus TCP的报文中不再带有数据校验.</p><h3 id="数据编码字节序"><a href="#数据编码字节序" class="headerlink" title="数据编码字节序"></a>数据编码字节序</h3><p>Modbus协议在发送数据时,采用与网络一样大端字节序发送数据,首先发送MSB.</p><h3 id="Modbus数据模型"><a href="#Modbus数据模型" class="headerlink" title="Modbus数据模型"></a>Modbus数据模型</h3><p>|基本表|对象类型|访问类型|注释||:–|:–|:–|:–||离散量输入|单个位|只读|I/O系统可提供这种类型的数据|<br>|线圈|单个位|读写|通过应用程序可以改变这种类型的数据|<br>|输入寄存器|16位 字|只读|I/O系统可提供这种类型的数据|<br>|保持寄存器|16位 字|读写|通过应用程序可以改变这种类型数据|</p><p>对于每一个基本表,协议都允许单个地选择65535个数据项.</p><h4 id="实现示例"><a href="#实现示例" class="headerlink" title="实现示例"></a>实现示例</h4><p>设备组织数据的方法有很多种,每个设备根据其应用都有自己的组织数据的方法.</p><ol><li>示例1,含有四个独立块的设备</li></ol><p><img src="/2021/09/02/2021/09/02/modbus/0b8463c4bd849a2e69007ade2c98e3c1cf04cb30e193321e5fbc8c6908212be0.png">2. 示例2,含有单个独立块的设备</p><p><img src="/2021/09/02/2021/09/02/modbus/92551356980e4ac382c52bb769f792f81cd0e260df5d253c68164ae7d2764ba9.png"></p><h3 id="Modbus寻址模型"><a href="#Modbus寻址模型" class="headerlink" title="Modbus寻址模型"></a>Modbus寻址模型</h3><p>Modbus应用协议精确地定义了PDU寻址规则.<br>在Modbu PDU中,从0<del>65535寻址每一个数据.<br>Modbus应用协议明确地规定了由四个块构成的Modbus数据模型,每个块由几个编号为1</del>n的元素构成.<br>在Modbus数据模型中,从1~n来编号每一个元素.<br>Modbus数据模型和设备应用之间的映射完全与特定设备无关.</p><p><img src="/2021/09/02/2021/09/02/modbus/8f0ab1d31267153dff431af3b82d1274448c3343bc6e50118a028780600e80d0.png"></p><h3 id="Modbus事务定义"><a href="#Modbus事务定义" class="headerlink" title="Modbus事务定义"></a>Modbus事务定义</h3><p>如图所示描述了在服务侧Modbus事务处理的一般处理流程</p><p><img src="/2021/09/02/2021/09/02/modbus/efc2e1c2b08517a33cf1269b58fa432e46d19f4e848dc734779f438f4936fe2d.png"></p><p>一旦服务器处理请求,就必须使用相应的Modbus服务器事务处理生成Modbus响应.<br>根据处理结果,可以建立两种类型响应:</p><ol><li>一个正常的Modbus响应:响应功能码=请求功能码</li><li>一个异常的Modbus响应:异常功能码=请求功能码 + 0x80<br>用来为客户机提供处理过程中与所发现的差错相关的信息,提供异常码来表示发生差错的原因.</li></ol><h2 id="功能码类别"><a href="#功能码类别" class="headerlink" title="功能码类别"></a>功能码类别</h2><p>共有三类Modbus功能码,分为为:公共功能码,用户自定义功能码,保留功能码.它们的分布如下:</p><p><img src="/2021/09/02/2021/09/02/modbus/7d0c7f513bb19748d4874f4a7a22fabf1ef654a1bde7957a7e650c1911f655df.png"></p><h3 id="公共功能码"><a href="#公共功能码" class="headerlink" title="公共功能码"></a>公共功能码</h3><ol><li>被确切定义的功能码.</li><li>保证是唯一的.</li><li>由MODBUS.org组织验证.</li><li>公开文档.</li><li>可进行一致性测试.</li><li>包含已被定义的公共功能码和保留给未来使用的功能码.</li></ol><h3 id="用户自定义功能码"><a href="#用户自定义功能码" class="headerlink" title="用户自定义功能码"></a>用户自定义功能码</h3><ol><li>共有两个用户自定义功能码区域,即十进制的65-72,100-110.</li><li>用户无需Modbus组织的任何批准就可以选择和实现一个功能码.</li><li>不能保证被选用的功能码的使用是唯一的.</li><li>如果用户希望将某种功能设置为一个公共功能码,那么用户必须启动RFC,以便将这种变更引入公共分类中,并且指配一个新的公共功能码.</li></ol><h3 id="保留功能码"><a href="#保留功能码" class="headerlink" title="保留功能码"></a>保留功能码</h3><p>某些公司在传统产品上先行使用的功能码,不作为公共使用.</p><h2 id="公共功能码定义"><a href="#公共功能码定义" class="headerlink" title="公共功能码定义"></a>公共功能码定义</h2><p><img src="/2021/09/02/2021/09/02/modbus/public-function-codes.png"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://modbus.org/docs/Modbus_Application_Protocol_V1_1b3.pdf">Modbus_Application_Protocol_V1_1b3</a></li><li><a href="http://www.ad.siemens.com.cn/productportal/Prods/published/Comm/Comm_9.1/Comm_9.1.html">Modbus TCP通信概述</a></li><li><a href="https://en.nanotec.com/products/manual/PD4E_ModbusTCP_ZH/bus%2Fmodbus%2Fmbap_header.html">技术手册 PD4-E MODBUS TCP</a></li></ol>]]></content>
    
    
    <summary type="html">Modbus协议.</summary>
    
    
    
    
    <category term="Modbus" scheme="http://tanqidong1992.github.io/tags/Modbus/"/>
    
    <category term="IOT" scheme="http://tanqidong1992.github.io/tags/IOT/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg入门学习</title>
    <link href="http://tanqidong1992.github.io/2021/07/02/2021/07/02/introduction-of-ffmpeg/"/>
    <id>http://tanqidong1992.github.io/2021/07/02/2021/07/02/introduction-of-ffmpeg/</id>
    <published>2021-07-02T15:23:12.000Z</published>
    <updated>2021-10-12T07:34:24.420Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FFmpeg入门学习"><a href="#FFmpeg入门学习" class="headerlink" title="FFmpeg入门学习"></a>FFmpeg入门学习</h1><h2 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h2><p>这些天一直加班,把心情都加没了,只能写写代码来改善一下心情.流媒体一直是公司项目中最难啃的骨头,恰好上次找到一本好书&lt;&lt;FFmpeg从入门到精通&gt;&gt;,最近常跟同事聊起流媒体相关内容,我因此决定去探索一番.</p><h2 id="FFmpeg组成"><a href="#FFmpeg组成" class="headerlink" title="FFmpeg组成"></a>FFmpeg组成</h2><p>FFmpeg框架主要由AVFormat,AVCodec,AVFilter,AVDevice,AVUtil模块组成.</p><h3 id="AVFormat"><a href="#AVFormat" class="headerlink" title="AVFormat"></a>AVFormat</h3><p>AVFormat实现了目前主流多媒体封装格式,包括封装和解封装.比如常见的文件封装格式:MP4,FLV,KV,TS,网络封装格式:RTMP,RTSP,MMS,HLS.<br>备注:FFmpeg支持媒体封装格式拓展,用户可以自定义自己的媒体封装格式拓展.</p><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>AVCodec实现了目前主流的多媒体编解码格式,包括MPEG4,AAC,MJPEG,H.264(AVC),H.265(HEVC).用户可以扩展以支持自己的编码格式.</p><h3 id="AVFilter"><a href="#AVFilter" class="headerlink" title="AVFilter"></a>AVFilter</h3><p>AVFilter提供了一个通用的音频,视频,字幕等滤镜处理框架,该框架支持多个输入流,多个输出流以及流分割.FFmpeg内置多种滤镜.</p><h3 id="Swscale"><a href="#Swscale" class="headerlink" title="Swscale"></a>Swscale</h3><p>swsample提供了高级别的图像转化API.</p><h3 id="swresample"><a href="#swresample" class="headerlink" title="swresample"></a>swresample</h3><p>swresample提供了高级别的音频重采样API.</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://ffmpeg.org/">FFmpeg官网</a></li><li><a href="https://ffmpeg.org/ffmpeg-filters.html">FFmpeg Filters Documentation</a></li><li><a href="https://github.com/tanqidong1992/audio-video-learn">学习过程中编写的代码Java</a></li></ol>]]></content>
    
    
    <summary type="html">FFmpeg简介.</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="FFmpeg" scheme="http://tanqidong1992.github.io/tags/FFmpeg/"/>
    
    <category term="音视频" scheme="http://tanqidong1992.github.io/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集算法</title>
    <link href="http://tanqidong1992.github.io/2021/06/15/2021/06/15/algorithms-of-garbage-collector/"/>
    <id>http://tanqidong1992.github.io/2021/06/15/2021/06/15/algorithms-of-garbage-collector/</id>
    <published>2021-06-14T16:23:12.000Z</published>
    <updated>2021-10-12T07:34:24.404Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="Throughput收集器"><a href="#Throughput收集器" class="headerlink" title="Throughput收集器"></a>Throughput收集器</h2><p>Throughput收集器有两个基本的操作:</p><ul><li>回收新生代的垃圾</li><li>回收老年代的垃圾</li></ul><h3 id="新生代垃圾回收"><a href="#新生代垃圾回收" class="headerlink" title="新生代垃圾回收"></a>新生代垃圾回收</h3><p>通常新生代垃圾回收发生在Eden空间快用尽的时候,新生代垃圾收集会把Eden空间的所有对象挪走,一部分会被移动到Survivor空间,其他的会被移动到老年代.</p><h3 id="老年代垃圾回收"><a href="#老年代垃圾回收" class="headerlink" title="老年代垃圾回收"></a>老年代垃圾回收</h3><p>老年代垃圾收集会回收新生代中所有对象(包括Survivor空间中的对象),只有那些活跃引用的对象,或者已经经过压缩整理的对象会在老年代中继续保留,其余对象都会被回收.<br><strong>备注:永久代中的对象不会被Full GC回收,除非永久代的空间被耗尽,JVM会发起Full GC回收<br>永久代中的对象.</strong></p><p>小结:Throughput收集器会进行两种操作,分别是Full GC和Minor GC;通过GC日志中的时间输出,我们可以迅速地判断出Throughput收集器的GC操作对应用程序总体性能影响.</p><h3 id="堆大小的自适应调整和静态调整"><a href="#堆大小的自适应调整和静态调整" class="headerlink" title="堆大小的自适应调整和静态调整"></a>堆大小的自适应调整和静态调整</h3><p>Throughput收集器的调优几乎是围绕停顿时间进行,寻求堆的总大小,新生代的大小以及老年代大小之间的平衡.</p><p>调优时有两种取舍:一是编程技术上时间与空间的取舍,二是与完成垃圾回收所需的时长相关,增大堆可以减少GC停顿发生的频率,但GC的时长会变长,平均响应时间也会变长;同理给新生代分配更多的空间可以缩短Full GC的时长,不过会增加Full GC的频率.</p><p>为了达到停顿时间的指标,Throughput收集器的自适应调整会重新分配堆(以及代)的大小,自适应调优标志如下:</p><ul><li>-XX:MaxGCPauseMillis=N 最大停顿时长</li><li>-XX:GCTimeRatio=N 设置应用程序在垃圾回收上花费的多少时间,计算公式如下:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThroughputGoal = 1 - 1/(1+GCTimeRatio)</span><br></pre></td></tr></table></figure><p>GCTimeRatio初始值为99,计算出ThroughputGoal的值为0.99,意味着99%的时间用于应用程序,1%的时间用于垃圾回收.</p><p>JVM使用这两个标志在堆的初始值(-Xms)和最大值(-Xmx)之间设置堆大小.MaxGCPauseMillis的优先级最高,如果设置了,新生代和老年代会随之进行调整,直到满足对应的停顿目标,一旦目标达成,堆的总容量就开始逐渐增大,直到运行时间的比率达到设定值.这两个目标达成后,JVM会尝试缩小堆的大小,尽可能以最小的堆大小来满足这两个目标.</p><p>由于默认情况下不设置停顿时间目标,通常自动调整的效果是堆的大小会持续增大,直到满足设置的GCTimeRatio目标.不过,在实际操作中,该标志的默认值已经相当优化了.</p><p>一般应用程序在垃圾回收的消耗为总时间的3%-6%效果是相当不错的.不过在内存受限的环境下,这些应用程序一般会在垃圾回收上消耗总时间10%-15%的时间,垃圾回收对这些应用程序的性能影响巨大,不过整体性能目标还是能够达到的.根据应用程序的性能目标,最佳配置也有所不同.</p><p><strong>小结:采用动态调整是进行堆调优极好的入手点,对很多应用程序而言,采用动态调整已经足够,动态调整的配置能够有效地减少JVM的内存使用;静态地设置堆的大小也可能获得最优的性能.设置合理的性能目标,让JVM根据设置确定堆的大小是学习这种调优很好的入门.</strong></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>CMS收集器有三种基本操作:</p><ul><li>对新生代进行垃圾回收.</li><li>并发回收(启动一个并发线程对老年代空间的垃圾进行回收).</li><li>如有必要,发起Full GC.</li></ul><h3 id="对新生代进行垃圾回收"><a href="#对新生代进行垃圾回收" class="headerlink" title="对新生代进行垃圾回收"></a>对新生代进行垃圾回收</h3><p>CMS收集器的新生代垃圾回收与Throughput收集器的新生代垃圾回收非常相似:存活对象从Eden空间移动到Survivor空间,或者移动到老年代空间.</p><h3 id="并发回收"><a href="#并发回收" class="headerlink" title="并发回收"></a>并发回收</h3><p>CMS会根据堆的使用情况启动并发回收.当堆的占用达到某一个程度时,JVM启动后台线程扫描堆,回收不用的对象.<br><strong>注意:并发回收,并不会对老年代的空间进行压缩整理.</strong><br>并发回收的阶段</p><ol><li>初始标记阶段: 找到堆中所有垃圾回收根节点对象.应用程序线程被暂停</li><li>并发标记阶段: 应用程序继续运行,不会被中断.</li><li>并发预清理阶段 .</li><li>可中断预清理阶段</li><li>重新标记阶段. 应用程序线程被暂停</li><li>并发清除阶段.</li><li>并发重置阶段.</li></ol><p><strong>备注:重新标记阶段需要暂停应用线程,如果新生代收集刚刚结束,紧接着就是一个交际阶段的话,应用线程会遭遇两次连续停顿,CMS为了避免这种情况,因此引入可中断预清理阶段,目的就是缩短停顿的长度,避免连续的停顿.因此,可中断预清理阶段会等到新生代占到50%左右才开始,给了CMS收集器最好的机会避免发生连续停顿.</strong></p><h3 id="CMS-Full-GC"><a href="#CMS-Full-GC" class="headerlink" title="CMS Full GC"></a>CMS Full GC</h3><p>触发Full GC的原因</p><ul><li>并发模式失败: 当新生代垃圾回收完成,同时老年代没有足够的空间容纳晋升的对象.</li><li>晋升失败: 当新生代垃圾回收完成,老年代有足够的空间容纳晋升的对象,但是由于空闲空间碎片化,导致晋升失败.</li><li>永久代(元空间)用尽,</li></ul><p>并发模式导致的Full GC,仅需要回收堆内的无用对象,而晋升失败导致的Full GC需要对整个老年代空间进行整理和压缩,时间远远大于前者,压缩整理后就像Throughput收集器昨晚Full GC后,新生代完全空闲,老年代空间也已经整理过.</p><p><strong>备注:默认情况下,CMS收集器不会对永久代(元空间)进行收集,但是它一旦用尽,那就需要进行Full GC.</strong></p><p><strong>小结:CMS垃圾回收有多个操作,但是最期望发生的是Minor GC和并发回收;CMS收集过程中的并发模式失效以及晋升失败的代价都非常大,我们需要调优以避免这种情况;默认情况下,CMS不会对老年代(元空间)进行回收.</strong></p><h3 id="对并发模式失败的调优"><a href="#对并发模式失败的调优" class="headerlink" title="对并发模式失败的调优"></a>对并发模式失败的调优</h3><p>调优CMS收集器最重要的工作是避免发生并发模式失效以及晋升失败.<br>并发模式失效往往是由于CMS不能足够快的清理老年代空间,新生代需要垃圾回收时,CMS收集器计算发现老年代没有足够的空闲空间可以容纳这些晋升对象,不得不先对老年代进行垃圾回收.</p><p>初始时老年代空间的对象时一个接一个整齐有序排列的.当老年代的占用带到某个程度(默认70%)时,并发回收开始.一个CMS后台线程开始回收老年代空间,寻找无用的垃圾对象时,竞争就开始了:CMS必须在老年代剩余的空间(30%)用尽之前,完成老年代空间的扫描以及回收工作.如果并发回收在这场速度竞争中失败,CMS收集器就会发生并发模式失效.</p><p>以下途径可以避免发生这种失效:</p><ul><li>增大老年代空间,要么只移动部分新生代对象到老年代,要么增加堆空间.</li><li>以更高的频率运行后台回收线程.</li><li>使用更多的后台线程.</li></ul><p>如果有足够多的内存,更好的方案是增加堆的大小,否则尝试调整后台线程来解决这个问题.</p><h4 id="给后台线程更多的运行机会"><a href="#给后台线程更多的运行机会" class="headerlink" title="给后台线程更多的运行机会"></a>给后台线程更多的运行机会</h4><p>更早的启动并发周期,设置两个参数:-XX:CMSInitiatingOccupancyFraction=N和-XX:+UseCMSInitiatingOccupancyOnly,同时设置这两个标志,CMS就只根据设置的老年代空间占比率来决定何时启动后台线程.默认情况下UseCMSInitiatingOccupancyOnly标志为假,CMS会根据复杂算法判断何时启动并行收集线程.如有必要提前启动后台线程,推荐使用最简单的方法,将UseCMSInitiatingOccupancyOnly标志为真</p><p>CMSInitiatingOccupancyFraction参数的值的调整可能需要多次迭代才能确定.如果开启UseCMSInitiatingOccupancyOnly标志,CMSInitiatingOccupancyFraction的默认值就被置为70,即CMS收集器在老年代空间占用比达到70%时,启动并发收集周期.</p><p>这里有一个取舍,给后台线程更多的运行机会,意味着,需要更多的CPU周期,导致更多的CMS并发周期中的停顿.</p><h4 id="调整CMS后台线程"><a href="#调整CMS后台线程" class="headerlink" title="调整CMS后台线程"></a>调整CMS后台线程</h4><p>每一个CMS后台线程都会100%的占用机器上的一颗CPU,如果应用程序发生并发模式失效,同时有额外的CPU可用,可以设置-XX:ConcGCThreads=N标志,增加后台线程数,默认情况下,ConcGCThreads是根据ParallelGCThreads标志的值计算得到的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcGCThreads=(3+ParallelGCThreads)/4</span><br></pre></td></tr></table></figure><p>调整这一标志的要点在于判断是否有可用的CPU周期,如果ConcGCThreads的值设置的偏大,垃圾收集会占用本来能用于运行应用线程的CPU周期,最终导致应用程序略微的停顿.此外,在一个配备了大量CPU的系统上,ConcGCThreads参数的默认值会偏大.如果没有并发模式失效,可以考虑较少后台线程数,释放这部分CPU周期用于一个应用线程运行.</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol><li>避免并发模式失效是提升CMS收集器处理能力,获得高性能的关键.</li><li>避免并发模式失效最简单的方式是增大最大堆的容量.</li><li>否则,我们只能通过调整CMSInitiatingOccupancyFraction参数,尽早启动并发后台线程的运行.</li><li>另外.调整后台线程数目对解决这个问题也有帮助.</li></ol><h3 id="CMS收集器的永久代的调优"><a href="#CMS收集器的永久代的调优" class="headerlink" title="CMS收集器的永久代的调优"></a>CMS收集器的永久代的调优</h3><p>如果永久代需要进行垃圾回收就会触发Full GC.Java 7默认情况下,CMS垃圾收集线程不会处理永久代中的垃圾.如果永久代的空间用尽,CMS会发起Full GC来回收其中的垃圾对象,此外,可以通过启用标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSPermGenSweepingEnabled</span><br></pre></td></tr></table></figure><p>开启后,永久代的垃圾使用与老年代一样的方式进行垃圾回收:通过一组后台线程并发地回收永久代中的垃圾.触发永久代垃圾回收的标志与老年代垃圾回收的标志相互独立为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSInitiatingPermOccupancyFraction=N</span><br></pre></td></tr></table></figure><p>这个参数指定了CMS收集器在永久代空间占比达到设定值时启动永久代垃圾回收线程,默认值为80%.</p><p>为了真正释放不再引用的类,我们还需要启用标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSClassUnloadingEnabled</span><br></pre></td></tr></table></figure><p>否则,即使启用了永久代垃圾回收也只能释放少量的无效对象,类的元数据并不会被释放.由于永久代中大量的数据都是类的元数据,因此开启CMS永久代垃圾回收时,这个标志也应该开启.</p><p>Java 8中,CMS收集器默认就会收集元空间中不再载入的类,如果处于某些原因,你希望关闭次功能,你可以通过</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-CMSClassUnloadingEnabled</span><br></pre></td></tr></table></figure><p>进行关闭,默认情况下这个标志是开启的.</p><h3 id="增量式CMS垃圾收集"><a href="#增量式CMS垃圾收集" class="headerlink" title="增量式CMS垃圾收集"></a>增量式CMS垃圾收集</h3><p>如果只有一个单CPU的机器,或者你有多个非常忙碌的CPU,但是希望使用低延迟的垃圾收集器.这种情况下,使用CMS收集器进行增量式的垃圾收集,即只要有后台线程运行,垃圾收集器就不会对整个堆进行回收.这个后台线程间断性地暂停,有助于整个系统吞吐量的提高.</p><p>启动标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+CMSIncrementalMode</span><br></pre></td></tr></table></figure><p>开启增量式CMS垃圾收集,通过改变标志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-XX:CMSIncrementalSafetyFactory=N</span><br><span class="line">-XX:CMSIncrementalDutyCycleMin=N</span><br><span class="line">-XX:CMSIncrementalPacing=N</span><br></pre></td></tr></table></figure><p>可以控制垃圾收集线程为应用程序让出多少CPU.</p><p>增量式CMS垃圾收集依据责任周期(duty cycle)原则进行工作.这个原则决定了CMS垃圾收集器的后台线程在释放CPU周期给应用线程前,每隔多长时间扫描一次堆.换言之,这些标志实际控制着主动暂停运行,释放资源给应用线程运行之前,后台线程持续运行的时间.</p><p>责任周期的时长是以新生代相邻两次垃圾收集之间的时间长度计算得出的;默认情况下增量式CMS垃圾收集持续的时间是该时长的20%左右(初始时是这个值,CMS会不断调整该值以适应不断晋升到老年代的对象数目).如果这个时间不够长,就会发生并发模式失效.我们的目的就是通过调整增量式CMS垃圾收集,避免发生这个GC.</p><p>我们可以从调整CMSIncrementalSafetyFactory参数入手,这个参数可以增大到默认责任周期的时间百分比.责任周期的默认值为10%.默认情况下,安全因子的值是在增加10%(默认责任周期所占用的时间百分比变为20%),可以让后台线程有更多的运行时间.</p><p>此外,如果参数CMSIncrementalDutyCycleMin设置得比默认值(10)更大也可以调整责任周期的长度.不过这个参数值会受JCM自动调节机制影响,因为JVM的自动调整机制会监控由新生代晋升到老年代的对象数并进行相应的调节.即使增大这个值,JVM可能还是根据自身的判断,如果增量式垃圾收集不需要运行得过于频繁,从而减少这个值.如果应用程序运行时操作有爆发式的波峰,通过自动调节机制计算出的结果通常不正确,你需要显式地设置责任周期,同时调整CMSIncrementalDutyCycle标志关闭自动参数调节(CMSIncrementalDutyCycle的值默认为真,即开启).</p><p><strong>小结:应用在CPU资源受限的机器上运行,同时要求较小的停顿,这时使用增量式CMS收集器是一个不错的选择;通过责任周期可以调整增量式CMS收集器,增加责任周期的运行时间可以避免CMS收集器发生并发模式失效.</strong></p><p>备注:</p><ol><li>增量式CMS收集在Java 8中已经不推荐使用,在Java 9中已经被移除.</li><li>随着多核技术的发展,使得iCMS存在的意义变得不那么重要了.</li><li>如果系统确实只配备了极其有限的CPU,作为替代方案,可以考虑使用G1收集器.G1收集器的后台线程在垃圾收集过程中也会周期性地暂停,客观上减少了与应用线程竞争CPU资源的情况.</li></ol><h3 id="自适应调优和CMS垃圾收集"><a href="#自适应调优和CMS垃圾收集" class="headerlink" title="自适应调优和CMS垃圾收集"></a>自适应调优和CMS垃圾收集</h3><p>CMS收集器使用两个配置MaxGCPauseMllis=N和GCTimeRatio=N来确定使用多大的堆和多大的代空间.</p><p>CMS收集器与其他的垃圾收集方法一个显著不同的地方在于除非发生Full GC否则CMS的新生代不会做调整,由于CMS的目标是尽量避免发生Full GC,因此使用精细调优的CMS收集器的应用程序永远不会调整它的新生代大小.</p><p>程序启动时可能频发并发模式失效,因为CMS收集器需要调整堆和永久代的大小,使用CMS收集器,初始时,采用一个比较大的堆(以及一个更大的永久代或元空间)是一个很好的主意,这是一个特例,增大堆的大小而帮助避免那些失效.</p><h2 id="G1垃圾收集器"><a href="#G1垃圾收集器" class="headerlink" title="G1垃圾收集器"></a>G1垃圾收集器</h2><p>G1收集器是一种工作在堆内不同分区上的并发收集器.分区既可以属于老年代也可以属于新生代(默认分区数为2048),同一个代的分区不需要保持连续.<br>老年代分区设计初衷:发现后台线程在回收老年代的垃圾时:有的分区垃圾对象比较多,另一些分区垃圾比较少.</p><p>虽然分区的垃圾收集工作仍然会暂定应用线程,但G1收集器专注于收集垃圾最多的分区,最终的效果是花费较少的时间就能回收这些分区垃圾.</p><p>这种只专注于垃圾最多的分区的方式就是G1垃圾收集器名称的由来,即首先收集垃圾最多的分区.</p><p>这种算法不适用与新生代.新新代也采用分区设计的原因是:采用预定义的分区能够便于代的大小调整.</p><p>G1收集器的收集活动主要包括四种操作:</p><ul><li>新生代垃圾收集.</li><li>并发垃圾回收(后台收集,并发周期).</li><li>混合式垃圾收集.</li><li>必要时的Full GC.</li></ul><h3 id="G1新生代垃圾回收"><a href="#G1新生代垃圾回收" class="headerlink" title="G1新生代垃圾回收"></a>G1新生代垃圾回收</h3><p>Eden空间耗尽时,触发G1新生代垃圾回收.新生代收集之后不会有一个分区马上分配到Eden空间(因为这时Eden为空),不过至少会有一个分区分配到Survivor空间,一部分数据会移动到老年代.</p><h3 id="G1并发垃圾收集"><a href="#G1并发垃圾收集" class="headerlink" title="G1并发垃圾收集"></a>G1并发垃圾收集</h3><ul><li>初始标记阶段(initial-mark),暂停应用线程.</li><li>扫描根分区(concurrent-root-region-scan-start),并发执行.</li><li>并发标记阶段(concurrent-mark-start)–&gt;(concurrent-mark-end),可以中断,可能发生新生代垃圾回收.</li><li>重新标记阶段(remark),暂停应用线程.</li><li>清理阶段(cleanup)(concurrent-cleanup-start –&gt; concurent-cleanup-end),暂停应用线程.<br>  到此,G1的周期就结束了,清理阶段真正回收的内存数量很少,G1到这个点为止真正做的事就是定位出那些老的分区可回收垃圾最多.</li></ul><h3 id="G1混合式垃圾回收"><a href="#G1混合式垃圾回收" class="headerlink" title="G1混合式垃圾回收"></a>G1混合式垃圾回收</h3><p>G1并发周期结束后,G1会进行一系列的混合式垃圾回收,不仅进行正常的新生代垃圾回收,同时也回收部分后台扫描线程标记的分区.</p><p>同新生代垃圾收集行为一样,G1收集器清空Eden空间,同时调整Survivor空间的大小.此外<strong>部分</strong>标记的分区也被回收,绝大部分空间被释放,剩余的对象被移动到其他分区.这也是为什么G1收集器最终出现碎片化堆的频率比CMS收集器要小得多的原因,G1垃圾回收以这种方式移动对象,实际伴随着压缩.</p><p>混合式垃圾回收周期会持续到(几乎)所有的标记分区被回收.之后,G1收集器会恢复常规的新生代垃圾回收机制.最终G1收集器会启动再一次的并发周期</p><h3 id="G1-Full-GC"><a href="#G1-Full-GC" class="headerlink" title="G1 Full GC"></a>G1 Full GC</h3><p>触发G1进行Full GC有以下四种情况</p><ul><li>并发模式失效:G1垃圾收集启动标记周期,但老年代在周期完成之前被填满(concurrent-mark-start –&gt; concurrent-mark-abort).</li><li>晋升失败:G1收集器完成标记阶段,开始启动混合式垃圾回收,清理老年代的分区,老年代在释放出足够的内存之前就被耗尽( pause(mixed) –&gt; Allocation Failure).</li><li>疏散失败:进行新生代垃圾收集时,Survivor空间和老年代中没有足够的空间容纳所有的幸存对象.( pause young (to-space overflow)),此时堆已经被耗尽或者碎片化了.</li><li>巨型对象分配失败:分配非常大的对象时,可能会遭遇另一种Full GC.</li></ul><p><strong>小结:G1垃圾收集包含多个周期(以及并发周期内的阶段),调优良好的JVM运行G1收集器时应该只经历新生代周期,混合式周期和并发周期;G1并发阶段会产生少量的停顿;恰当的时候,我们需要对G1进行调优,才能避免Full GC周期发生;</strong><br><strong>备注:如果进行根分区扫描时,新生代空间刚好用尽,新生代垃圾回收必须等待根扫描结束才能完成.</strong></p><h3 id="G1垃圾收集器调优"><a href="#G1垃圾收集器调优" class="headerlink" title="G1垃圾收集器调优"></a>G1垃圾收集器调优</h3><p>G1垃圾收集器调优的主要目的:避免发生并发模式失败或者疏散失败,一旦发生这些失败会导致Full GC.<br>备注: 避免发生Full GC的方法也适用于频繁发生的新生代垃圾收集.<br>以下方法可以避免发生Full GC:</p><ul><li>增加堆空间的大小或者调整老年代,新生代之间的比例来增加老年代的大小.</li><li>增加后台线程的数目(如果有足够多的CPU资源).</li><li>以更高的频率进行G1的后台垃圾收集活动.</li><li>在混合式垃圾回收周期中完成更多的垃圾收集工作</li></ul><h3 id="调整最大停顿时间"><a href="#调整最大停顿时间" class="headerlink" title="调整最大停顿时间"></a>调整最大停顿时间</h3><p>G1收集器最主要通过调整</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=N</span><br></pre></td></tr></table></figure><p>标志,来达到性能目标.如果G1收集器发生时空停顿(stop-the-world)的时长超过该值,G1收集器就会尝试各种方式进行弥补:</p><ul><li>调整新生代与老年代的比例.</li><li>调整堆大小.</li><li>调整更早地启动后台线程.</li><li>改变晋升阀值.</li><li>在混合垃圾收集周期中处理更多或更少的老年代分区.<br>这里需要权衡的是: 减少参数值,为了达到停顿目标,新生代的大小会相应的减少,不过新生代垃圾收集的频率会更加频繁.此外,为了达到停顿目标,混合式GC收集的老年代分区数也会减少,而这会增大并发模式失败发生的机会.</li></ul><p>如果设置停顿时间无法避免Full GC,我们可以进一步针对不同方面逐一调优.</p><h3 id="调整G1垃圾收集的后台线程数"><a href="#调整G1垃圾收集的后台线程数" class="headerlink" title="调整G1垃圾收集的后台线程数"></a>调整G1垃圾收集的后台线程数</h3><p>如果有足够的空闲CPU,可以增加后台标记线程数目.</p><ul><li>对于应用程序暂停运行的周期,可以通过ParallelGCThreads标志设置运行的线程数;</li><li>对于并发运行阶段,可以使用ConcGCThreads标志设置运行线程数.<br>备注: ConcGCThreads标志的默认值为</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcGCThreads = (ParallelGCThreads + 2) /4</span><br></pre></td></tr></table></figure><h3 id="调整垃圾收集器运行的频率"><a href="#调整垃圾收集器运行的频率" class="headerlink" title="调整垃圾收集器运行的频率"></a>调整垃圾收集器运行的频率</h3><p>如果G1收集器更早的启动垃圾收集,有助于避免并发模式失效.G1垃圾收集周期通常在堆的占用达到参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=N</span><br></pre></td></tr></table></figure><p>设置的比率时启动,默认情况下该值为45.<br>备注:该值是指整个堆的占用率,而不是单指老年代.</p><p>InitiatingHeapOccupancyPercent是一个常数,G1收集器自身不会为了达到停顿时间而修改整个值.</p><ul><li>如果设置的过高,应用程序会陷入Full GC的泥潭,因为并发阶段没有足够的时间在剩下的堆空间被填满之前完成垃圾收集.</li><li>如果设置的过低,应用程序又会以超过实际需要的节奏进行大量的后台处理.这会导致非常严重的结果,因为并发阶段会出现越来越多的短暂应用线程的停顿.</li></ul><p>因此,使用G1收集器时要避免频繁地进行后台清理,并发周期结束后,检查堆的大小,确保InitiatingHeapOccupancyPercent的值大于此时堆的大小.</p><h3 id="调整G1收集器的混合式垃圾收集器周期"><a href="#调整G1收集器的混合式垃圾收集器周期" class="headerlink" title="调整G1收集器的混合式垃圾收集器周期"></a>调整G1收集器的混合式垃圾收集器周期</h3><p>并发周期后,老年代标记分区回收完成前,G1收集器无法启动新的并发周期,因此,让G1收集器更早的启动标记周期的另一方法是:混合式垃圾回收周期尽量处理更多分区,进而减少混合式GC周期数.<br>混合式垃圾收集要处理的工作量取决于三个因素:</p><ol><li>有多少分区被发现大部分是垃圾对象.目前没有标志能够直接调节这个因素.混合垃圾收集中,如果分区的垃圾占比达到35%,那么这个分区被标记为可以进行垃圾回收.</li><li>G1垃圾收集器回收分区时的最大混合式GC周期数,通过参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1MixedGCCounttarget=N</span><br></pre></td></tr></table></figure><p>进行调节,默认值为8,减少该参数有助于解决晋升失败的问题,代价是混合式GC周期的停顿时间会更长.另一方面,如果混合式GC的时间过长,可以增大这个参数的值,减少每次混合式GC周期的工作量,不过需要确保调整最大值后不会对下一次GC并发周期带来太大的延迟,否则会导致并发模式失败.<br>3. GC停顿可忍受最大时长(通过MaxGCPauseMillis参数设定),MaxGCPauseMillis标志设定的混合式周期是向上规整的,如果实际停顿时间在停顿最大时长以内,G1收集器能够收集超过八分之一标记的老年代分区.增大MaxGCPauseMillis能在每次混合式GC中收集更多的老年代分区,而这反过来又能帮助G1收集器在更早的时候启动并发周期.</p><h3 id="G1垃圾调优小结"><a href="#G1垃圾调优小结" class="headerlink" title="G1垃圾调优小结"></a>G1垃圾调优小结</h3><ol><li>作为G1收集器调优的第一步,首先是设定一个合理的停顿时间作为目标.</li><li>如果使用这个设置后,还是频繁发生Full GC,并且堆的大小没有扩大的可能,这时候需要针对特定的失败,采用特定的方法进行调优.</li></ol><ul><li>通过InitiatingHeadpOccupancyPercent标志可以调整G1收集器,更频繁地启动后台垃圾收集线程.</li><li>如果有足够的CPU资源,可以考虑调整ConcGCThreads标志,增加垃圾收集线程数.</li><li>减少G1MixedGCCountTarget参数可以避免晋升失败.</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://blogs.oracle.com/poonam/understanding-cms-gc-logs">understanding-cms-gc-logs</a></li></ol>]]></content>
    
    
    <summary type="html">垃圾收集算法.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>GC调优基础</title>
    <link href="http://tanqidong1992.github.io/2021/06/12/2021/06/12/base-of-gc-tuning/"/>
    <id>http://tanqidong1992.github.io/2021/06/12/2021/06/12/base-of-gc-tuning/</id>
    <published>2021-06-12T13:39:31.000Z</published>
    <updated>2021-10-12T07:34:24.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC调优基础"><a href="#GC调优基础" class="headerlink" title="GC调优基础"></a>GC调优基础</h2><p>虽然处理堆时各种GC算法有所差异,但是它们的基本配置参数是一致的.很多情况下,我们只需要这些基本的配置就能运行应用程序.</p><h3 id="调整堆的大小"><a href="#调整堆的大小" class="headerlink" title="调整堆的大小"></a>调整堆的大小</h3><p>选择堆的大小是一种平衡,如果分配的堆过小,程序的大部分时间可能消耗在GC上,没有足够的时间去运行应用程序逻辑.<br>如果粗暴地设置一个大堆,将有以下风险:</p><ul><li>GC停顿的时间取决于堆的大小,如果增加堆的大小,停顿的持续时长也会变长.这种情况下,虽然停顿的频率会变得更少,但是他们持续的时间会让程序的整体性能变慢.</li><li>如果JVM使用的内存超过计算机的物理内存,部分不活跃的内存可能会被操作系统置换到交换分区(页面文件)中,JVM不会了解到这些细节.由于Full GC会访问整个JVM堆,那么内存交换一定会发生.Full GC停顿的时间将会以正常停顿时间的数个数量级的增长.类似的如果使用Concurrent收集器,后台线程在回收堆的时候,它的速度会被拖慢,因为要等待从磁盘复制数据到内存,结果导致发生代价昂贵的并发模式失败.<br>因此,调整堆的大小时,永远不要把堆的大小设置的超过物理内存,另外如果同一台机器运行多个JVM,那么这个规则适用于所有堆的和.除此之外,你还必须为JVM自身以及其他应用程序预留部分内存,通常情况下,对于一般操作系统,应该至少预留1G的内存空间.</li></ul><p>堆的大小由两个参数控制:</p><ul><li>最小值:-Xms(-XX:InitialHeapSize)</li><li>最大值:-Xmx(-XX:MaxHeapSize)</li></ul><p>默认值的调整取决于多个因素,包括操作系统的类型,系统内存大小,使用的JVM,其他命令行标志也会对该值造成影响;堆的大小是JVM自适应调优的核心.</p><p>Windows下Java11,物理内存为32G的情况下,初始值为512mb,最大值为8G,</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D:\me\blog<span class="literal">-test</span>&gt;java <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr InitialHeapSize</span><br><span class="line">   size_t InitialHeapSize                          = <span class="number">534773760</span>                                 &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version <span class="string">&quot;11.0.11&quot;</span> <span class="number">2021</span><span class="literal">-04</span><span class="literal">-20</span></span><br><span class="line">OpenJDK Runtime Environment GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci</span><span class="literal">-21</span>.<span class="number">1</span><span class="literal">-b05</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci</span><span class="literal">-21</span>.<span class="number">1</span><span class="literal">-b05</span>, mixed mode, sharing)</span><br><span class="line"></span><br><span class="line">D:\me\blog<span class="literal">-test</span>&gt;java <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr MaxHeapSize     </span><br><span class="line">   size_t MaxHeapSize                              = <span class="number">8541700096</span>                                &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version <span class="string">&quot;11.0.11&quot;</span> <span class="number">2021</span><span class="literal">-04</span><span class="literal">-20</span></span><br><span class="line">OpenJDK Runtime Environment GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci</span><span class="literal">-21</span>.<span class="number">1</span><span class="literal">-b05</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM GraalVM CE <span class="number">21.1</span>.<span class="number">0</span> (build <span class="number">11.0</span>.<span class="number">11</span>+<span class="number">8</span><span class="literal">-jvmci</span><span class="literal">-21</span>.<span class="number">1</span><span class="literal">-b05</span>, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>堆的大小具有初始值和最大值,JVM的目标是根据系统可用资源情况找到一个合理的默认值.堆的大小具有初始值和最大值的这种设计让JVM能够根据实际的负荷情况更灵活地调整JVM的行为,如果JVM发现使用初始的堆的大小,频繁地发生GC,它会尝试增大堆的空间,直到JVM的GC的频率回归到正常的范围,或者直到堆的大小增大到它的上限值.</p><p>通常,如果应用程序运行所需要的堆不超过运行平台默认的最大值,这个方法就可以工作的很好.<br>然后,如果应用程序在GC时消耗了太长的时间,你有可能需要通过设置-Xmx标志增大堆的大小.选择怎样的大小,没有硬性或者简单的法则.一个经验的法则是,一次Full GC后,应该释放出70%的空间.</p><p>即使显式地设置了堆的大小,还是会发生堆的自动调节,初始时堆以默认的大小开始运行,为了达到根据垃圾收集算法设置的性能目标,JVM会逐步增大堆的大小.将堆的大小设置的比实际需要更大不一定会带来性能损失.堆不会无限制地增大,JVM会调节堆的大小直到其满足GC的性能目标.</p><p>备注:如果你确切地直到应用程序需要多大的堆,那么你可以将堆的初始值和最大值设置成对应值,这种设置可以稍微提高GC的运行效率,因为它不需要估算堆是否需要调整大小了.</p><p>总结:JVM会根据其运行的机器,尝试估算合适的最大,最小堆的大小;除非应用程序需要比默认值更大的堆,否则在调优时,尽量考虑通过调整GC算法的性能目标,而非微调堆的大小来改善程序性能.</p><h3 id="代空间的调整"><a href="#代空间的调整" class="headerlink" title="代空间的调整"></a>代空间的调整</h3><p>堆的大小被确定后,我们还学要确定代的大小,如果新生代的大小分配的过小,那么会频繁地发生Minor GC,同样老年代就会比较大,发生的Full GC的频率较低,这里需要找到一个平衡.<br>调整代空间标识</p><ul><li>设置新生代与老年代的空间比率: -XX:NewRatio=N</li><li>设置新生代的初始大小: -XX:NewSize=N</li><li>设置新生代的最大大小: -XX:MaxNewSize=N</li><li>将新生代的最大最小值设置为同一值的快捷方法 -XmnN</li></ul><p>NewRation的默认值为2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/mnt/d/me/blog-test$ java -XX:+PrintFlagsFinal -version | grep NewRatio</span><br><span class="line">    uintx NewRatio                                 = 2                                         &#123;product&#125; &#123;default&#125;</span><br><span class="line">openjdk version &quot;11.0.11&quot; 2021-04-20</span><br><span class="line">OpenJDK Runtime Environment GraalVM CE 21.1.0 (build 11.0.11+8-jvmci-21.1-b05)</span><br><span class="line">OpenJDK 64-Bit Server VM GraalVM CE 21.1.0 (build 11.0.11+8-jvmci-21.1-b05, mixed mode, sharing)</span><br></pre></td></tr></table></figure><p>新生代初始大小计算公式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Initial Young Generation Size = Initial Heap Size / ( 1 + NewRatio )</span><br></pre></td></tr></table></figure><p>默认情况下新生代的初始大小为初始堆的33%.</p><p>我们也可以通过设置NewSize的值,显式地设定新生代的初始大小,其优先级高于通过NewRatio计算出来的值.虽然NewSize有默认值,但是在未设置的情况下,以NewRatio计算出来的为准</p><p><strong>小结:整个堆范围内,不同代的大小划分是由新生代所占用的空间控制的;新生代的大小会随着整个堆的增大而增长,但是也是随着整个堆的空间比率波动变化的(依据新生代的初始值和最大值)</strong></p><h3 id="永久代和元空间的调整"><a href="#永久代和元空间的调整" class="headerlink" title="永久代和元空间的调整"></a>永久代和元空间的调整</h3><p>JVM载入类的时候,它需要记录这些类的元数据.这些数据被保留在单独的堆空间中,在Java7中称为永久代(Permanent Generation),在Java8中称为元空间(Metaspace).<br>永久代与元空间不完全一样,在Java7中,永久代还保存了一些与类无关的杂项数据.这些数据在Java8中被移动到了普通的堆空间,Java8还在根本上改变了保存在这个特殊区域内的元数据的类型.</p><p>目前没有一个好算法可以提前计算出程序永久代/元空间需要多大空间的好算法.<br>永久代/元空间的大小与程序使用类的数量成正比例,应用程序越复杂,使用的对象越多,永久代/元空间就越大.<br>备注:使用元空间替换掉永久代的优势之一是我们不需要对其进行调整.<br>配置标志:</p><ul><li>永久代初始大小: -XX:PermSize=N</li><li>永久代最大值: -XX:MaxPermSize=N</li><li>元空间初始大小: -XX:MetaspaceSize=N</li><li>元空间最大值: -XX:MetaspaceSize=N<br>备注:元空间默认是没有大小限制的,Java8的应用可能由于元空间被填满而耗尽内存,可以使用NMT(Native Memory Tracking)诊断这类问题.通过设置MaxMetaspaceSize调整元空间的上限,一旦超过会触发OutOfMemoryError错误.解决此类问题需要定位出为什么类的元空间这么大.</li></ul><p>虽然名叫永久代,元空间,但其中的数据并不会被永久保存,保存在其中的类会像对象一样会经历垃圾回收,当类加载器不再被引用时,其加载的类,会等待GC回收.</p><p>堆转储信息可以用于诊断存在那些类加载器.而这些信息放过来可以帮助确定是否存在类加载的泄露,最终导致永久代/元空间被耗尽,除此之外使用jmap和-permstat参数(Java7)或者clstats参数(Java8)可以输出类加载器相关信息.这些命令不稳定,不推荐使用.</p><p><strong>小结:永久代/元空间保存着类的元数据(并非类的本体数据),他以分离的堆的形式存在;典型的应用在启动后不需要载入新的类,这个区域的初始值可以根据所有类都加载后的情况设置,使用优化的初始值能够加快启动的过程;开发中的应用服务器(或者任何需要频繁载入类的环境)上经常能碰到永久代或元空间耗尽而触发的Full GC,这时老的元数据会被回收.</strong></p><h2 id="控制并发"><a href="#控制并发" class="headerlink" title="控制并发"></a>控制并发</h2><p>除了Serial收集器,几乎所有的收集器使用的算法都是基于多线程.启动线程的数量由-XX:ParallelGCThreads=N参数控制,这个参数会影响以下操作:</p><ul><li>使用-XX:+UseParallelGC收集新生代.</li><li>使用-XX:+UseParallelOldGC收集老年代.</li><li>使用-XX:+UseParNewGC收集新生代.</li><li>使用-XX:+UseConcMarkSweepGC收集老年代时空停顿阶段.</li><li>使用-XX:+UseG1GC收集老年代时空停顿阶段.</li><li>使用-XX:UseG1GC收集新生代.<br>由于GC操作会暂停所有应用程序线程,JVM为了缩短停顿时间就必须尽可能地利用更多的CPU资源,默认情况下JVM会在每一个CPU上运行一个垃圾收集线程,最多不超过8个,一旦超过8个,则采用以下公式计算:</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ParallelGCThreads = 8 + (N-8)*5/8, N表示CPU的数量</span><br></pre></td></tr></table></figure><p><strong>小结: 几乎所有的垃圾收集算法中基本的垃圾回收线程都依据机器上CPU的数目计算得出;多个JVM运行在同一个机器上,依据公式计算出的线程数量可能过高,必须进行优化(减少).</strong></p><h3 id="自适应调整"><a href="#自适应调整" class="headerlink" title="自适应调整"></a>自适应调整</h3><p>自适应调整策略,JVM会不断地尝试,寻找优化性能的机会,JVM运行的过程中,堆,代以及Survivor空间的大小都可能发生变化.</p><p>这是一种尽力而为的方案,它根据过往的性能历史,假设即将来的GC周期跟最近的历史GC周期的状况可能很相似.事实证明,在多种负荷下这一假设是正确的.即使某个时刻内存的分配发生突变的情况,JVM也能依据最新的情况重新调整它的大小.</p><p>自适应调整有两方面的好处:</p><ul><li>小型的应用程序不需要再为指定过大的堆而担心.</li><li>很多应用程序不需要担心他们堆的大小,如果使用堆的大小超过平台默认值,他们可以放心地分配更大的堆,而不用关心其中的细节.JVM会自动调整堆和代的大小,根据垃圾回收算法的性能目标,使用优化的内存量,自适应调整就是让自动调整生效的法宝.</li></ul><p>空间的调整终归需要花费一定的时间开销,这部分时间大多数消耗在GC停顿的时候,如果你投注了大量的时间精细地调优了垃圾回收参数,定义了堆的大小限制,可以考虑关闭自适应调整.如果应用程序的运行明显划分为不同的阶段,你希望对这些阶段中的某个阶段进行垃圾回收的优化,那么关闭自适应调优也是很有帮助的.</p><p>使用-XX:-UseAdaptiveSizePolicy标志关闭自适应调整功能(默认开启);如果堆容量的最大值,最小值设置为一样,同时新生代的初始值和最大值也设置为同样大小,自适应功能会被关闭,不过此时Survivor空间是个意外.</p><p>可以启用标志-XX:+PrintAdaptiveSizePolicy标志,了解应用程序运行时JVM是如何调整的,一旦发生垃圾回收,GC的日志中包含不同代进行空间调整的细节信息.</p><p><strong>小结: JVM在堆内部如何调整新生代与老年代的百分比是由自适应调整机制控制的;通常情况下我们应该开启自适应调整,垃圾回收算法依赖于调整后的代的大小来达到它停顿的性能目标;对于已经精细优化过的堆,关闭自适应调整能获得一定的性能提升.</strong></p><h2 id="垃圾回收工具"><a href="#垃圾回收工具" class="headerlink" title="垃圾回收工具"></a>垃圾回收工具</h2><h3 id="输出垃圾回收日志"><a href="#输出垃圾回收日志" class="headerlink" title="输出垃圾回收日志"></a>输出垃圾回收日志</h3><p>垃圾回收对JVM性能影响至关重要,观察垃圾回收对应用程序性能的最好方法就是尽量熟悉垃圾回收的日志.垃圾回收日志中包含了程序运行过程中的每一次垃圾回收操作.</p><p>垃圾回收日志的细节依据使用的垃圾回收算法各有不同,不过垃圾回收日志的基本结构是一致的.</p><h3 id="开启垃圾回收日志"><a href="#开启垃圾回收日志" class="headerlink" title="开启垃圾回收日志"></a>开启垃圾回收日志</h3><ul><li>开启基本日志 -verbose:gc 或者 -XX:+PrintGC (默认关闭)</li><li>开启详细日志 -XX:+PrintGCDetails (默认关闭)</li></ul><p>备注:出了详细日志,我们还需要开启-XX:+PrintGCTimeStamps 或者 -XX:+PrintGCDateStamps,便于我们精准地判断几次GC操作的时间,时间戳是相对JVM启动的时间,日期戳是实际的日期字符串</p><h3 id="垃圾回收日志输出到文件"><a href="#垃圾回收日志输出到文件" class="headerlink" title="垃圾回收日志输出到文件"></a>垃圾回收日志输出到文件</h3><p>默认情况下垃圾回收日志直接输出到控制台,使用-Xloggc:filename标志能修改输出到某个文件(除非显示的启动PrintGCDetails,不然仅输出基本日志).使用日志循环(Log rotation)标志限制保存在GC日志文件中的数据量,标志如下:</p><ul><li>启用日志文件循环 -XX:+UseGCLogfileRotation</li><li>设置日志文件数量限制 -XX:NumberOfGCLogfiles=N</li><li>设置日志文件大小限制 -XX:GCLogfileSize=N</li></ul><p><strong>备注: 默认情况下UseGCLogfileRotation是关闭的,开启UseGCLogfileRotation后,文件的数量为0,即为不限制数量,默认的文件大小也为0,即为不限制大小,如果设置的文件大小不足8K,那么日志文件的大小也会以8K为单位进行规整.</strong></p><h3 id="阅读垃圾回收日志"><a href="#阅读垃圾回收日志" class="headerlink" title="阅读垃圾回收日志"></a>阅读垃圾回收日志</h3><p>我们可以手工解析,阅读垃圾回收的日志,也可以借助外部工具.</p><ul><li>GC Histogram可以根据日志文件生成对于的图表与表格.</li><li>jconsole可以查看堆的实时使用情况</li><li>jstat 可以使用脚本的方式获取堆的使用信息,比如选项-gcutil,它能输出消耗在GC上的时间,以及每个GC区域使用的百分比.</li></ul><p>备注 jstat接受一个可选的参数,指定每隔多少毫秒重复执行这个命令.</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>GC日志是分析GC相关问题的重要线索;我们应该开启GC日志标志(即使在生产服务器上).</li><li>使用PrintGCDetails标志能获得更详尽的GC日志信息.</li><li>使用工具能很有效地帮助我们解析和理解GC日志的内容,尤其是在对GC日志中的数据进行归纳汇总时,他们非常有帮助.</li><li>使用jstat能动态地观察程序的垃圾回收操作.</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对任何一个Java应用程序,垃圾收集的性能都是其构成整体性能的关键一环.虽然对大多数的应用程序来说,调优的工作仅仅是选择合适的垃圾收集算法,或者在需要的时候,增大应用程序的堆空间.</p><p>自适应调整让JVM能够自动调整它的行为,使用给定的堆,提供尽可能好的性能.</p>]]></content>
    
    
    <summary type="html">GC调优基础.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>HarmonyOS</title>
    <link href="http://tanqidong1992.github.io/2021/05/29/2021/05/29/harmonyOS_architecture/"/>
    <id>http://tanqidong1992.github.io/2021/05/29/2021/05/29/harmonyOS_architecture/</id>
    <published>2021-05-28T17:35:11.000Z</published>
    <updated>2021-10-12T07:34:25.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HarmonyOS"><a href="#HarmonyOS" class="headerlink" title="HarmonyOS"></a>HarmonyOS</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>HarmonyOS是华为开发的,一款面向未来的全场景分布式智慧操作系统,将逐步覆盖1+8+N全场景终端设备</p><h3 id="1-8-N"><a href="#1-8-N" class="headerlink" title="1+8+N"></a>1+8+N</h3><ul><li>1: 手机.</li><li>8: PC,平板,手表,智慧屏,AI音箱,耳机,AR/VR眼镜,车机.</li><li>N: IoT生态产品.</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li>消费者<br>  HarmonyOS用一个统一的软件系统,从根本上解决消费者面对大量智能终端体验割裂的问题,为消费者带来统一,便利,安全的智慧化全场景体验.</li><li>开发者<br>  HarmonyOS通过多种分布式技术,整合不同终端硬件能力,形成一个虚拟的”超级终端”,应用开发者可基于超级终端开发应用,聚焦上层业务逻辑,无需关注硬件差异,设备开发者可以按需调用其他终端能力,带来基于超级终端的创新服务体验</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>HarmonyOS作为一款面向未来的崭新操作系统,必将在万物互联,万物智能的全联接世界中发挥至关重要的作用,期待广大开发者伙伴积极加入我们,共同见证全场景智慧生态的无限可能.</p><h2 id="HarmonyOS-Architecture"><a href="#HarmonyOS-Architecture" class="headerlink" title="HarmonyOS Architecture"></a>HarmonyOS Architecture</h2><p><img src="/2021/05/29/2021/05/29/harmonyOS_architecture/1df249e302b8c523f2efe706c0680a1eb9afd0121fffda7d451cad27fe514989.svg"></p>]]></content>
    
    
    <summary type="html">HarmonyOS概念以及架构.</summary>
    
    
    
    
    <category term="HarmonyOS" scheme="http://tanqidong1992.github.io/tags/HarmonyOS/"/>
    
  </entry>
  
  <entry>
    <title>垃圾收集入门</title>
    <link href="http://tanqidong1992.github.io/2021/05/24/2021/05/24/introduction-to-garbage-collection/"/>
    <id>http://tanqidong1992.github.io/2021/05/24/2021/05/24/introduction-to-garbage-collection/</id>
    <published>2021-05-24T13:55:11.000Z</published>
    <updated>2021-10-12T07:34:24.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾收集入门"><a href="#垃圾收集入门" class="headerlink" title="垃圾收集入门"></a>垃圾收集入门</h1><h2 id="主流垃圾收集器"><a href="#主流垃圾收集器" class="headerlink" title="主流垃圾收集器"></a>主流垃圾收集器</h2><p>Java主流的垃圾收集器分别是:</p><ul><li>Serial收集器.</li><li>Parallel(Throughput)收集器.</li><li>Concurrent收集器,CMS.</li><li>Concurrent收集器,G1.</li></ul><h2 id="垃圾收集概述"><a href="#垃圾收集概述" class="headerlink" title="垃圾收集概述"></a>垃圾收集概述</h2><p>Java最诱人的特性之一便是不需要显式地管理对象的生命周期,JVM会在后台自动回收不再使用的对象.<br>垃圾收集主要由两部分构成:</p><ul><li>查找不再使用的对象.</li><li>释放这些对象所管理的内存</li><li>有时候,还需要进行内存整理防止内存碎片.</li></ul><p>在垃圾收集进行时,所有应用线程都停止运行所产生的的停顿被称为时空停顿(stop-the-world),通常这些停顿对应用的性能影响最大,调优垃圾收集时,尽量减少这种停顿是最为关键的因素.</p><h3 id="分代垃圾收集器"><a href="#分代垃圾收集器" class="headerlink" title="分代垃圾收集器"></a>分代垃圾收集器</h3><p>虽然不同垃圾收集器实现细节千差万别,但都遵循同一个方式,即根据情况将堆分为不同的代(Generation),被分为老年代(Old Generation)和新生代(Young Generation),新生代又被分为Eden空间以及Survivor空间.</p><p>采用分代机制的原因是很多对象的生存周期非常短.采用分代设计主要有两个性能优势:</p><ul><li>新生代仅是堆的一部分,处理新生代更快.</li><li>对象分配于新生代,垃圾收集时,新生代被清空,Eden空间对象要么被移走,要么被回收;所有存活对象要么被移动到老年代,要么被移动到Survivor空间,由于所有对象被移走,相当于新生代空间在垃圾收集时,自动进行了一次垃圾整理.</li></ul><p>回收新生代空间,不用的对象被回收,存活的对象被移动到其他空间,这种操作称为Minor GC.<br>对象不断移动到老年代,最终老年代空间也会被占满,JVM需要找出老年代中不再使用的对象,并对它们进行回收,接着对对空间进行整理,这是垃圾收集算法差异最大的地方,这个过程称为Full GC,通常会导致应用程序线程长时间的停顿,</p><p>另一方面,通过更复杂的计算,我们还可能在应用程序运行的同时,找出不再使用的对象;CMS和G1收集器便是通过这种方式进行垃圾回收.由于它们不需要停止应用线程就能找出不再使用的对象,它们也被称为Concurrent收集器.Concurrent收集器采用不同的方法对老年代进行压缩.</p><p>使用CMS或G1收集器时,应用程序经历的停顿会更少(也更短),其代价便是消耗更多的CPU,CMS和G1收集器也可能遭受长时间的Full GC(调优算法以尽量避免出现这种情况).</p><p>评估垃圾收集器,要想达到整体的性能目标,每一个决定都需要取舍,如果应用对单个响应时间有要求,主要考虑以下方面:</p><ul><li>单个请求会受停顿时间的影响(受Full GC长时间停顿的影响更大),如果目标是尽可能地缩短响应时间,那么采用Concurrent收集器更为合适.</li><li>如果平均响应时间比最大响应时间更为重要(譬如90%地响应时间),那么采用Throughput收集器通常就能满足需要.</li><li>使用Concurrent收集器来避免长时间Full GC的代价便是消耗更多的CPU.</li></ul><p>为批量应用选择垃圾收集器遵守以下规则:</p><ul><li>如果CPU足够强劲,使用Concurrent收集器避免发生Full GC可以让任务运行更快.</li><li>如果CPU有限,那么Concurrent收集器额外的CPU消耗会让批量任务消耗更多的时间.</li></ul><p>备注:</p><ul><li>所有GC算法都将堆划分为新生代和老年代.</li><li>所有GC算法都在清理新生代对象时,都使用了”时空停顿”(Stop-The-World)方式收集垃圾,这通常是一个较快便能完成的操作.</li></ul><h2 id="GC算法"><a href="#GC算法" class="headerlink" title="GC算法"></a>GC算法</h2><p>JVM提供四种不同的垃圾收集算法</p><h3 id="Serial垃圾收集器"><a href="#Serial垃圾收集器" class="headerlink" title="Serial垃圾收集器"></a>Serial垃圾收集器</h3><p>Serial收集是四种收集器中最简单的一种,如果运行在Client型虚拟机,这也是默认的垃圾收集器.<br>Serial收集器采用单线程清理堆内容,无论是Minor GC还是Full GC,所有应用线程都会被暂停,进行Full GC时,会对老年代的对象进行压缩整理,使用-XX:+UseSerialGC标志启用Serial收集器.</p><h3 id="Throughput收集器"><a href="#Throughput收集器" class="headerlink" title="Throughput收集器"></a>Throughput收集器</h3><p>Thoughput收集器是Server虚拟机的默认收集器,Throughput收集器采用多线程回收新生代空间和老年代空间,Minor GC比Serial收集器快的多,Throughput收集器在Minor GC和Full GC时会暂停所有应用线程.在Full GC时会对老年代空间进行压缩整理.使用标志-XX:+UseParallelGC,-XX:+UseParallelOldGC启用Throughput收集器.由于Throughput收集器采用多线程,因此也被称为Parallel收集器.</p><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><p>CMS收集器设计的初衷是为了解决Serial以及Throughput收集器Full GC周期长时间的停顿.CMS会在Minor GC中停止所有的应用线程,并采用多线程的方式回收新生代空间,不同于Throughput收集器的-XX:+UseParallelGC,改用新的算法来回收新生代对象(-XX:+UseParNewGC)</p><p>CMS在Full GC时,不再停止应用线程,而是使用多个后台线程定期地对老年代进行扫描,及时回收其中不再使用的对象.这种算法帮助CMS收集器成为一个低延迟的收集器.应用线程只在Minor GC以及后台线程扫描老年代时发生及其短暂的停顿.应用线程的停顿的总时长比Throughput收集器短得多.</p><p>这里需要付出的代价是更高的CPU使用:必须有足够的CPU资源用于后台的垃圾收集线程.<br>除此之外,后台线程不再进行任何压缩整理操作,这意味堆会逐渐变得碎片化,如果CMS的后台线程无法获得完成他们任务的CPU资源或者堆过于碎片化以至于无法找到连续空间分配对象.CMS就会蜕化到Serial收集器行为:暂停所有应用线程,使用单线程回收,整理老年代空间.这之后又恢复到并发运行,再次启动后台线程.使用-XX:+UseConcMarkSweepGC,-XX:+UseParNewGC启用CMS垃圾收集器.</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1垃圾收集器设计的初衷是为了尽量缩短处理超大堆(大于4G)时产生的停顿,G1收集器将堆分为多个区域(Region),不过它仍属于分代收集器,在进行Minor GC时,暂停所有的应用线程,采用多线程方式回收垃圾,将存活对象移动到老年代或者Survivor空间.</p><p>G1垃圾收集器属于Concurrent收集器:老年代的垃圾收集由后台线程完成,大多数工作不需要停止应用线程.由于老年代被分为多个区域,G1收集器通过将对象从一个区域复制到另一个区域,完成对象清理,同时也完成了堆的压缩整理.因此,G1收集器的堆不太容易发生碎片化.</p><p>同CMS收集器一样,避免Full GC的代价是消耗额外的CPU,负责垃圾收集的多个后台线程必须在应用线程运行的同时获得足够多的CPU运行周期,通过标志-XX:+UseG1GC启用</p><h3 id="触发及禁用显示的垃圾回收"><a href="#触发及禁用显示的垃圾回收" class="headerlink" title="触发及禁用显示的垃圾回收"></a>触发及禁用显示的垃圾回收</h3><p>通常情况下垃圾收集是由JVM在需要的时候触发:新生代快用尽时会触发Minor GC,老年代快用尽的时候会触发Full GC,或者堆空间即将填满时会触发Concurrent垃圾收集.</p><p>JVM提供一种机制让应用程序强制进行GC.</p><ul><li>System.gc()</li><li>jcmd <pid> GC.run</pid></li><li>RMI作为分布式垃圾收集器的一部分,每隔一个小时它会调用System.gc()一次,可以通过-Dsum.rmi.dgc.server.gcInterval=N和-Dsum.rmi.dgc.client.gcInterval=N进行修改,N的单位为毫秒.Java 7中N默认为3600000(1小时).<br>可以通过配置JVM参数-XX:+DisableExplicitGC显式地禁用这种类型的GC</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>四种垃圾收集器分别采用了不同的方法来缓解GC对应用的影响.</li><li>Serial收集器常用于仅有单CPU可用以及当其他程序会干扰GC的情况.</li><li>Throughput收集器能够在其他的虚拟机上是默认值,它能最大化应用程序的总吞吐量,但有些操作会遭遇较长的停顿.</li><li>CMS收集器能够在应用线程运行的同时并发地对老年代的垃圾进行收集,.如果CPU的计算能力足够支持后台垃圾收集线程的运行,该算法能够有效避免应用程序发生Full GC.</li><li>G1收集器也能在应用线程运行的同时并发地对老年代的垃圾进行收集,在某种程度上能够减少发生Full GC的风险.G1的设计理念使得它比CMS更不容易遭遇Full GC.</li></ol><h2 id="选择GC算法"><a href="#选择GC算法" class="headerlink" title="选择GC算法"></a>选择GC算法</h2><p>Serial收集器适用于应用程序的内存小于100MB的场景.这种情况下应用程序只需要很小的堆,无论是Throughput收集器的并行收集,还是CMS和G1收集器的后台收集都发挥不了太大的作用.</p><h3 id="GC算法及批量任务"><a href="#GC算法及批量任务" class="headerlink" title="GC算法及批量任务"></a>GC算法及批量任务</h3><p>对于批处理任务而言,Throughput收集器所引入的停顿,尤其是Full GC停顿是主要的顾虑.如果有额外的CPU处理能力,那么Concurrent收集器将极大提高应用程序的性能.关键在于我们是否能够提供足够的CPU给Concurrent收集器的线程进行.<br><strong>备注:使用Throughput收集器处理应用程序线程的批量任务能最大程度的利用CPU的处理能力,通常能获得更好的性能;如果批处理任务并没有使用机器上的所有可用CPU资源,那么切换到Concurrent收集器往往能获得更好的性能.</strong></p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ol><li>衡量标准是响应时间或者吞吐量,在Throughput收集器和Concurrent收集器之间做选择的依据主要是有多少空闲的CPU资源能够用于运行后台的并发线程.</li><li>通常情况下,Throughput收集器的平均响应时间比Concurrent收集器要差,但是在90%的响应时间或者99%的响应时间这几项指标上,Throughput收集器比Concurrent收集器要好些.</li><li>使用Throughput收集器会超负荷地进行大量的Full GC,切换到Concurrent收集器通常会获得更低的响应时间.</li><li>选择Concurrent收集器时,如果堆较小,推荐使用CMS收集器.</li><li>G1的设计使得它能够在不同的分区处理堆,因此它的扩展性更好,比CMS更容易于处理超大堆的情况.</li></ol>]]></content>
    
    
    <summary type="html">垃圾收集入门.</summary>
    
    
    
    
    <category term="读书笔记" scheme="http://tanqidong1992.github.io/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM调优" scheme="http://tanqidong1992.github.io/tags/JVM%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>基于CentOS7制作带Docker的Vagrant基础Box</title>
    <link href="http://tanqidong1992.github.io/2021/03/12/2021/03/12/make-vagrant-base-box/"/>
    <id>http://tanqidong1992.github.io/2021/03/12/2021/03/12/make-vagrant-base-box/</id>
    <published>2021-03-12T13:33:45.000Z</published>
    <updated>2021-10-12T07:34:24.593Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化Vagrant工程并启动虚拟机"><a href="#初始化Vagrant工程并启动虚拟机" class="headerlink" title="初始化Vagrant工程并启动虚拟机"></a>初始化Vagrant工程并启动虚拟机</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vagrant init <span class="string">&quot;centos/7&quot;</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure><p>Vagrantfile内容如下</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vagrant.configure(<span class="string">&quot;2&quot;</span>) <span class="keyword">do</span> <span class="params">|config|</span></span><br><span class="line">  config.vm.box = <span class="string">&quot;centos/7&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="虚拟机中安装VBoxGuestAdditions"><a href="#虚拟机中安装VBoxGuestAdditions" class="headerlink" title="虚拟机中安装VBoxGuestAdditions"></a>虚拟机中安装VBoxGuestAdditions</h2><ol><li>将VBoxGuestAdditions.iso解压到Vagrant工程目录</li><li>执行安装命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install kernel-headers kernel-devel gcc make</span><br><span class="line">sudo /VBoxGuestAdditions/VBoxLinuxAdditions.run</span><br></pre></td></tr></table></figure><p>备注: VBoxGuestAdditions.iso可以从Virtualbox安装目录下找到.</p><h2 id="虚拟机中安装Docker"><a href="#虚拟机中安装Docker" class="headerlink" title="虚拟机中安装Docker"></a>虚拟机中安装Docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line">sudo usermod -aG docker $USER</span><br><span class="line">newgrp docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="设置不安全的ssh公钥"><a href="#设置不安全的ssh公钥" class="headerlink" title="设置不安全的ssh公钥"></a>设置不安全的ssh公钥</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA6NF8iallvQVp22WDkTkyrtvp9eWW6A8YVr+kz4TjGYe7gHzIw+niNltGEFHzD8+v1I2YJ6oXevct1YeS0o9HZyN1Q9qgCgzUFtdOKLv6IedplqoPkcmF0aYet2PkEDo3MlTBckFXPITAMzF8dJSIFo9D8HfdOV0IAdx4O7PtixWKn5y2hMNG0zQPyUecp4pzC6kivAIhyfHilFR61RGL+GPXQ2MWZWFYbAGjyiYJnAmCP3NOTd0jMZEnDkbUvxhMmBYSdETk1rRgm+R4LOzFUGaHqHDLKLX+FIPKcF96hrucXzcWyLbIbEgE98OHlnVYCzRdK8jlqm8tehUc9c9WhQ== vagrant insecure public key</span><br><span class="line">&quot; &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p><strong>备注:此步骤如果不进行,会导致基于此Box的虚拟机无法启动(ssh认证失败).</strong></p><h2 id="导出box"><a href="#导出box" class="headerlink" title="导出box"></a>导出box</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#vagrant package --base &lt;Your VM Name&gt;</span></span><br><span class="line">vagrant package -<span class="literal">-base</span> centos<span class="literal">-with</span><span class="literal">-docker_default_1615543273586_25894</span></span><br></pre></td></tr></table></figure><p>在Vagrant工程目录可以看到导出的package.box.</p><h2 id="测试Box"><a href="#测试Box" class="headerlink" title="测试Box"></a>测试Box</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add -<span class="literal">-name</span> my<span class="literal">-box</span> package.box</span><br><span class="line">mkdir <span class="built_in">test-box</span></span><br><span class="line"><span class="built_in">cd</span> <span class="built_in">test-box</span></span><br><span class="line">vagrant init my<span class="literal">-box</span></span><br><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.vagrantup.com/docs/boxes/base">General Guide to Creating Base Box</a></li><li><a href="https://www.vagrantup.com/docs/providers/virtualbox/boxes">Creating a Virtualbox Base Box</a></li><li><a href="https://github.com/hashicorp/vagrant/tree/main/keys">insecure keypair</a></li></ol>]]></content>
    
    
    <summary type="html">基于CentOS7制作带Docker的Vagrant基础Box</summary>
    
    
    
    
    <category term="Vagrant" scheme="http://tanqidong1992.github.io/tags/Vagrant/"/>
    
    <category term="Vagrant Box" scheme="http://tanqidong1992.github.io/tags/Vagrant-Box/"/>
    
  </entry>
  
  <entry>
    <title>密码学的分类</title>
    <link href="http://tanqidong1992.github.io/2021/01/26/2021/01/26/category-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/26/2021/01/26/category-of-cryptography/</id>
    <published>2021-01-25T16:50:11.000Z</published>
    <updated>2021-10-12T07:34:24.652Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学的分类"><a href="#密码学的分类" class="headerlink" title="密码学的分类"></a>密码学的分类</h1><p>密码学起源于古代,发展于现代,随时间推移,密码学不断完善,拥有众多分支,可以从时间上,保密内容,密码体制等方面进行划分.</p><h2 id="分类的划分"><a href="#分类的划分" class="headerlink" title="分类的划分"></a>分类的划分</h2><h3 id="按时间划分"><a href="#按时间划分" class="headerlink" title="按时间划分"></a>按时间划分</h3><ul><li>古典密码:以字符为基本加密单元</li><li>现代密码:以信息块为加密单元</li></ul><h3 id="按保密内容的算法划分"><a href="#按保密内容的算法划分" class="headerlink" title="按保密内容的算法划分"></a>按保密内容的算法划分</h3><ul><li>受限(Restricted)算法:算法的保密性基于保持算法的秘密,一般不赞成使用这种算法,除非用于军事一类的应用,算法由专业机构开发,验证,确保其算法的安全性,这是古典密码学的主要特征.</li><li>基于密钥(Key-Based)算法:算法的保密性基于对密钥的保密.这是基于柯克霍夫原则设计的算法,算法的公开有助于算法安全性的验证,算法的漏洞得以及时修正,避免算法的设计者在算法上留下后门等.这是现代密码学的主要特征.</li></ul><h3 id="按密码体制划分"><a href="#按密码体制划分" class="headerlink" title="按密码体制划分"></a>按密码体制划分</h3><ul><li>对称密码体制:也称为单钥密码体制或私钥密码体制.指该密码体制中的加密密钥与解密密钥相同.</li><li>非对称密码体制:也称为双钥密码体制或者公钥密码体制.指该密码体制的加密密钥与解密密钥不同,密钥分公钥与私钥,公钥对外开放,私钥对外保密.</li></ul><p>备注:与上述密码体制对应的算法有对称密码算法和非对称密码算法.</p><ul><li>对称密码算法:也称为单钥密码算法或私钥密码算法,指对应于对称密码体制的加密,解密算法,常见的有DES,AES.</li><li>非对称密码算法:也称为双钥密码算法或公钥密码算法,指对于非对称密码体制的加密,解密算法,常见的算法有RSA,DSA,常用于数字签名,身份认证.</li></ul><p>非对称加密对于对称加密算法有着更高的安全性,却同时有着不可回避的加密解密耗时时长.</p><h3 id="按明文的处理方法划分"><a href="#按明文的处理方法划分" class="headerlink" title="按明文的处理方法划分"></a>按明文的处理方法划分</h3><ul><li>分组密码(Block Cipher):指加密时,将明文划分成固定长度的组,用同一个密钥和算法对每一块加密,输出也是固定长度的密码,分组加密多用于网络.</li><li>流密码(Stream Cipher):也称为序列密码,指加密时每次加密一位或一个字节的明文.手机平台对应用使用的系统资源有着极为苛刻的要求,流密码对于系统资源要求极低.RC4是相当有名的流密码算法.</li></ul><p>备注:手工加密阶段和机械加密阶段,流密码曾是当时的主流.现代密码学研究的主要关注点时分组密码和流密码及其应用,在对称密码体制中,大部分加密算法属于分组密码.</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><p>古典密码起始于古代终止于19世纪末,是现代密码学的基础.古典密码受限于当时的环境,以语言学为基础对文字进行字符变化(对字符加密),以达到信息加密的目的.古典密码加密算法最常用,最核心的两种加密技巧是位移和替代,这同样是对称加密算法最常用的方法.</p><ul><li>位移密码(Transposition Cipher):错位密码,将字符重新排序,例如”123456” 变成 “321654”.</li><li>替代密码(Substitution Cipher):也称置换密码,将明文中的一组字符替代为其他的字符,形成密文,例如”hello” 变成 “ifmmp”(每个字母使用下一个字母替代).著名的凯撒密码就应用了替代法.</li></ul><p>在古典加密时期,替代密码发展迅速,拥有众多分支,又分为以下几种:</p><ul><li>单表替代密码:也称为简单替代密码,明文的一个字符用相应的一个密文字符代替.加密过程是从明文字母表到密文字母表的一一映射.主要包括位移(shift)密码,乘数(multiplicative)密码,仿射(affine)密码,多项式(Polynomial)密码,密钥短语(Key Word)密码.</li><li>同音替代密码:也称多名替代密码.与单表替代系统相似,唯一不同的是单个字符明文可以映射成密文的几个字符之一.</li><li>多表替代密码(Polyalphabetic Substitution Cipher):明文中的字符映射到密文空间还依赖与它在上下文中的位置,由多个简单的替代密码构成.例如,可能有五个被使用的不同的简单替代密码,单独的一个字符用来改变明文的每个字符的位置.弗吉尼亚密码,博福特密码,滚动密钥密码,弗纳姆密码,转子机密码均为多表替代密码.第二次世界大战中,德军用的转子加密机Enigma,正是多表替代密码应用的典范.</li><li>多字母替代密码(Polygram Substitution Cipher):明文中的字符被成组加密,例如’ABA’可能对应于’RTQ’.希尔密码,Playfair密码均为多字母替代密码.第一次世界大战中英国人就采用这种密码.</li></ul><p>备注: 不管是位移密码还是替代密码,终究脱离不了人类的语言.针对该特点,通过对密文进行语义分析使得古典密码在破译上有章可循.例如凯撒密码是单表替代密码,要破解凯撒密码,只要以语言学为基础,找出使用频度最高的字符,例如’’和e’,用ascii码表示就是32和101,差值69,如果明文中两个出现最高的字符的ascii码相差69,那么对应加密后密文中相应出现频度最高的字符的ascii相差也一定是69,很显然,通过这样的分析方法,只要找出密文中与之对应的字符,计算偏移量(密钥),就可以破解密文,这就是著名的频度分析法.</p><h3 id="对称密码体制"><a href="#对称密码体制" class="headerlink" title="对称密码体制"></a>对称密码体制</h3><p>对称密码体制并不是现代密码学的新生事物,它是古典密码学的进一步延续.古典密码学常用的两种技巧替代和位移,仍然是对称加密体制中最重要的加密技巧.</p><p>对称密码体制要求加密和解密使用同一个密钥,解密时加密的逆运算,由于双方需要共享同一个密钥,这就要求双方必须在通信前商定该密钥,并妥善保存该密钥,该密钥称为秘密密钥,秘密密钥的存在使得对称加密体制开放性变差.</p><p>对称密码体制分为两种:一种是对明文的单个位(或字节)进行运算,称为流密码,也称为序列密码;另一种是把明文信息划分为不同的组(块)结构,分别对每个组(或块)进行加密和解密,称为分组密码.</p><h4 id="流密码"><a href="#流密码" class="headerlink" title="流密码"></a>流密码</h4><p>流密码是军事,外交等机要部门中应用最广泛的对称密码体制,同时,它也是手机上应用平台最常用的加密手段.流密码实现较为简单,加密时将明文按字符(或字节)逐位进行加密,解密时将密文按字符(字节)逐位解密.加密和解密都是简单的位运算.明文加密后,生成的密文几乎和明文保持相同的长度.</p><p>流密码分为同步流密码和自同步流密码</p><h5 id="同步流密码"><a href="#同步流密码" class="headerlink" title="同步流密码"></a>同步流密码</h5><p>信息发送方与接收方在传递信息时,同步进行加密和解密操作,明文与密文一一对应.密文如果在传播过程中被篡改,删除或插入,可导致同步失效,以致密文解密失败,必须重新同步来实现解析,恢复密文.在密文传输过程中,如果某个位发生改变,那么该位的变化只影响该位的恢复,对后续密文位不受影响,这是同步流密码的一个重要特点.但是,根据该特性主动攻击者可以有选择地对密文字符进行改动,并准确知道这些改动对明文的影响.因此,同步流密码具有同步性,无错误传递及主动攻击性三种特性.同步流密码适用于为音频和视频数据提供版权保护.</p><h5 id="自同步流密码"><a href="#自同步流密码" class="headerlink" title="自同步流密码"></a>自同步流密码</h5><p>与同步流密码相比,自同步流密码是一种有记忆变换的密码.每一个密钥与已产生的固定数量的密文位有关,密钥由已生成的密文决定.在密文传输过程中,如果一个密文位发生改变,那么该位的变化会影响到后续有限位(如n位)的密文位的正确解密.所以自同步流密码具有错误传递现象,但是在接受n位正确密文字符后,密码会自身实现重新同步.基于这一特点,如果主动攻击者对密文做了修改,接收方仍然不能检测出密文的完整性.与同步流密码相比,自同步流密码的密码分析更加困难,安全性更高.因此自同步流具有自同步性,错误传递有限性,主动攻击性及明文统计扩散四种特征.</p><p>流密码实现简单,便于硬件计算,加密与解密处理速度快,错误传播率低等优点.但是,流密码对错误的产生不够敏感,这是流密码的缺点.流密码通常配合其他技术验证消息的完整性.流密码涉及大量的理论知识,受限于应用场景(目前主要运用与军事和外交等机要部门),许多研究成果并未完全公开.目前使用较多的流密码是自同步流密码.流密码的常用算法有RC4和SEAL.</p><p>流密码的安全强度依赖于密钥流生成器所产生的密钥流序列的特征,关键在与密钥生成器的设计以及消息收发两端密钥流产生的同步技术.</p><h4 id="分组密码"><a href="#分组密码" class="headerlink" title="分组密码"></a>分组密码</h4><p>分组密码多应用于网络加密,是对称密码体制中发展最为完善的密码体制.分组密码对固定长度的一组明文进行加密,这一固定长度称为分组长度.分组长度是分组密码的一个参数,它与算法的安全性成正比,其取值范围取决于实际应用的环境.</p><p>为保证分组算法的安全性,分组长度越长越好,分组长度越长,则密码分析越困难;为保证分组密码的实用性,分组长度越短越好,分组长度越短,则越便于操作和运算.分组长度的设定需要权衡分组算法的安全性与实用性,一般设置为56.随着密码学的发展,分组长度只有56位的分组密码已不能确保算法的安全性,目前,分组密码多选择128位作为算法的分组长度.</p><p>分组密码的加密过程是对一个分组长度为n位的明文进行加密操作,相应地产生一个n位的密文分组,由此可见不同的n位密文共有2^n个,考虑到加密算法的可逆性,每一个不同的n位明文都应该产生一个唯一的密文分组,加密过程对于的变换称为可逆变换或非奇异变换.所以,分组密码从本质上来说是定义了一种从分组的明文到相应密文的可逆变换.</p><p>分组密码是现代密码学的重要组成部分,具有代表的分组加密算法有DES,AES.</p><h5 id="分组密码设计原则"><a href="#分组密码设计原则" class="headerlink" title="分组密码设计原则"></a>分组密码设计原则</h5><p>分组密码的设计原则包括安全性和实现性两个方面.前者主要研究如何设计安全算法,分组长度和密钥长度;后者主要讨论如何提供算法的执行速度.</p><ol><li>针对于安全的一般设计原则</li></ol><blockquote><blockquote><p>安全性原则,也称为不可破译原则,它包含理论上不可破译和实际上不可破译两重含义.香农认为:在理想密码系统中,密文的所有统计特性都与所使用的密钥独立.关于实用密码的两个一般原则是香农提出的混乱原则和扩散原则.</p><ul><li>扩散(Diffusion)原则:人们所设计的密码应使得密钥的每一位数字影响到密文的多位数字,以防止对密钥进行逐段破译,而且明文的每一位数字也影响密文的多位数字以便隐藏明文数字的统计性.</li><li>混乱(Confusion)原则:人们所设计的密码应使得密钥和明文之间的信赖关系相当复杂以至于这种信赖对密码分析者来说是无法利用的.<br>衡量密码体制的安全性,主要提现在以下几个方面:</li><li>密码体制的破译所需要的时间和费用超过了现有的资源和能力.</li><li>密码体制的破译所需要的时间超过了该体制保护的信息的有效时间.</li><li>密码体制的破译所需要的费用超过了该体制所保护信息的价值.</li></ul><ol start="2"><li>针对实现的设计原则<br>分组密码可以用软件和硬件来实现.硬件实现的优点是可获得高效率,而软件实现的优点是灵活性高,代价低.</li></ol><ul><li>软件设计原则:使用子块和简单的运算,密码运算在子块上进行,要求子块的长度能自然地适应软件编程,如8,16,32位等.应避免按位置换,在子块所进行的密码运算尽量采用易于软件实现的运算.最好是使用处理器的基本运算,如加法,乘法,移位.</li><li>硬件设计原则:加密和解密的相似性,即加密和解密的过程的不同应局限于密钥使用方式上,以便采用同样的器件来实现加密和解密,以节省费用和体积.尽量采用标准组件结构,以便适应于在超大规模集成电路中实现.</li></ul><h5 id="分组密码的工作模式"><a href="#分组密码的工作模式" class="headerlink" title="分组密码的工作模式"></a>分组密码的工作模式</h5><p>我们以DES算法工作模式为例,DES算法根据其加密算法所定义的明文分组长度(56位),将数据分为若干56位的加密区块,再以区块为单位,分别进行加密处理.如果最后剩下不足一个区块的大小,我们称之为短块,短块的处理方法有填充法,流密码加密法,密文挪用技术.</p></blockquote></blockquote><p>1980年12月,DES算法工作模式被美国联邦信息处理标准组织(FIPS)标准化.加密算法应用的复杂性,有的强调效率,有的强调安全,有的强调容错性.根据数据加密时每个加密区块间的关联方式来区别,可以分为四种工作模式:电子密码本模式(Electronic Code Book,ECB),密文链接模式(Cipher Book Chaining,CBC),密文反馈模式(Cipher Feed Back,CFB),输出反馈模式(Output Feed Back,OFB),AES标准除了推荐上述四种工作模式外,还推荐一种新的工作模式:计数器模式(Counter,CTR).这些工作模式可适用于各种分组密码算法.</p><ul><li>电子密码本模式(ECB)</li></ul><blockquote><blockquote><p>电子密码本模式,它是最基本,最简单的工作模式.每次加密均产生独立的密文分组,每组的加密结果不会对其他分组产生影响,相同的明文加密后对应产生相同的密文,无初始化向量(也称为加密向量).可以认为有一个非常大的电码本,对任意一个可能的明文分组,电码本都有一项对应它的密文,这也是该模式名称的由来.</p><p>优点:易于理解且简单易行;便于实现并行操作;没有误差传播;</p><p>缺点:不能隐藏明文的模式,如果明文重复,对应的密文也会重复,密文内容很容易被替换,重排,剔除,重放,对明文进行主动攻击的可能性较高.</p><p>用途:适合加密密钥,随机数等短数据.例如安全传递DES密钥,ECB模式是最合适的.</p><ul><li>密文链接模式(CBC)<br>密文链接模式,它是目前应用最广泛的工作模式.明文加密前先需先与前面的密文进行异或(XOR)运算然后再加密,因此只要选择不同的初始向量,相同的明文加密后产生不同的密文.</li></ul><p>优点: 密文链接模式加密后的密文上下文关联,即使明文中出现重复的信息也不会产生相同的明文;密文内容如果被替换,重排,删除,重放或者网络传输过程中发生错误,后续密文即被破坏,无法完成解密还原;对明文的主动攻击性较低.</p><p>缺点: 不利于并行计算,目前没有已知的并行运算算法;误差传递,如果在加密过程中发生错误,则错误将被无限放大,导致加密失败;需要初始化向量.</p><p>用途: 可加密任意长度消息;适用于计算产生检测数据完整性的消息认证码MAC</p><ul><li>密文反馈模式(CFB)<br>密文反馈模式,它类似于自同步流密码,分组加密后,按8位分组将密文和明文进行移位异或后得到输出同时反馈回移位寄存器.它的有点是可以按字节逐个进行加密解密,也可以按n位字节处理.CFB是上下文关联的,明文的一个错误会影响后面的密文(错误扩散).CFB需要一个初始化向量,加密后与第一个分组进行异或运算产生第一组密文;然后对第一组密文进行加密后在与第二组进行异或运算取得第二组密文,以此类推,直到加密完成.<br>优点: 隐藏了明文的模式,每一个分组的加密结果必受其前面所有分组内容的影响,即使出现多次相同的明文,均产生不同的密文;分组密码转化为流模式,可产生密钥流;可以及时加密传送小于分组的数据</li></ul><p>缺点: 与CBC类似.不利于并行计算,目前没有已知的并行运算算法;存在误差传播,一个单元的损坏影响多个单元;需要初始化向量.</p><p>用途: 因错误传播无解,可用于检查发现明文密文的篡改.</p><ul><li>输出反馈模式(OFB)<br>输出反馈模式,它将分组密码作为同步流密码运行,和CFB相似,不过OFB用的是前一个n位密文输出分组反馈回移位寄存器,OFB没有错误扩散问题.该模式产生与明文异或运算的密钥流,从而产生密文,这一点与CFB相似,唯一不同的差异是与明文分组进行异或的输入那部分是反复加密后得到的.<br>优点: 隐藏明文的模式;分组密码转化为流模式;无误差传递问题;可以及时加密传送小于分组的数据.</li></ul><p>缺点: 不利于并行计算;对明文的主动攻击是可能的,安全性较CFB差.</p><p>用途: 适用于加密冗余性较大的数据,比如语言和图像数据.</p><ul><li>计数器模式(CTR)<br>计数器模式,它的特点是将计数器从初始值开始计数所得到的值发送给分组密码算法.随着计数器的增加,分组密码算法输出连续的分组来构成一个位串,该位串被用来与分组明文进行异或操作.计数器模式是用来提取分组密码的最大能效以实现保密性.在AES的实际应用中,经常会选择CBC和CTR模式,但更多的是选择CTR模式.<br>优点: 可并行计算;安全性至少和CBC一样好;加密和解密仅涉及密码算法的加密</li></ul><p>缺点: 没有错误传播,因此不易确保数据完整性.</p><p>用途: 适用于各种加密.</p><h3 id="非对称密码体制"><a href="#非对称密码体制" class="headerlink" title="非对称密码体制"></a>非对称密码体制</h3><p>1976年,密码学专家diffie和hellman在&lt;&lt;密码学的新方向&gt;&gt;一文中提出公开密钥体制的思想,开创了现代密码学的新领域,非对称密码体制的篇章由此揭开.</p></blockquote></blockquote><p>非对称密码体制与对称密码体制相对;其主要区别是:非对称密码体制的加密密钥与解密密钥不相同,分为两个密钥,一个公开,一个保密.公开的密钥称为公钥,保密的密钥称为私钥.因此,非对称密码体制也称为公钥密码体制.非对称密码体制使得发送者与接受者无密钥传输的保密通信成为可能,弥补了对称密码体制的缺陷.</p><p>非对称密码体制的主要优点是可以适应开发性的使用环境,密钥管理问题相对简单,可以方便,安全地实现数字签名和验证.RSA是非对称密码体制的典范,它不仅可以完成一般的数据保密操作,同时它也支持数字签名与验证.</p><p>非对称密码算法的安全性完全依赖于基于计算复杂度上的难题,通常来自于数论.例如RSA源于整数因子分解问题;DSA数字签名算法,源于离散对数问题;ECC椭圆曲线加密算法,源于离散对数问题.由于这些数学难题的实现涉及底层模数乘法或指数运算,相对于分组密码需要使用更多的计算,为了弥补这一缺陷,非对称密码系统通常是复合式的:用高效率的对称密码算法对信息进行加密解密处理;用非对称密钥加密对称密码系统所使用的密钥.通过这种复合方式增进效率.</p>]]></content>
    
    
    <summary type="html">密码学的分类</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学定义与术语</title>
    <link href="http://tanqidong1992.github.io/2021/01/25/2021/01/25/terms-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/25/2021/01/25/terms-of-cryptography/</id>
    <published>2021-01-24T16:20:01.000Z</published>
    <updated>2021-10-12T07:34:24.655Z</updated>
    
    <content type="html"><![CDATA[<h1 id="密码学定义与术语"><a href="#密码学定义与术语" class="headerlink" title="密码学定义与术语"></a>密码学定义与术语</h1><h2 id="密码学的定义"><a href="#密码学的定义" class="headerlink" title="密码学的定义"></a>密码学的定义</h2><p>密码学:主要研究保密通信和信息保密的问题,包括信息保密传输和信息加密存储等.密码学包括密码编码学(Cryptography)和密码分析学(Cryptanalyst).编码学与分析学相互促进,又相互制约.一方面,两者在加强密码分析的安全上相互促进;另一方面,两者在实施更为有效的攻击方面也相互影响.</p><ul><li>密码编码学:主要研究对信息进行编码,实现对信息的隐蔽,是密码学理论的基础,也是保密系统设计的基础.</li><li>密码分析学:主要研究加密信息的破译或信息的伪造,是校验密码体制安全性最直接的手段,只有通过实际密码分析考验的密码体制,才是真正可用的.</li></ul><h2 id="密码学常用术语"><a href="#密码学常用术语" class="headerlink" title="密码学常用术语"></a>密码学常用术语</h2><ul><li>明文(plaintext):待加密信息,明文可以是文本文件,图像文件,二进制数据等.</li><li>密文(ciphertext):经过加密后的明文,密文通常以文本,二进制数据等形式存在.</li><li>发送者(sender):指发送消息的人.</li><li>接受者(receiver):指接受消息的人.</li><li>加密(Encryption):指将明文转化为密文的过程.</li><li>加密算法(Encryption Algorithm):指将明文变化为密文的转化算法.</li><li>解密(Decryption):指将密文转化为明文的过程.</li><li>解密算法(Decryption Algorithm):指将密文转化为明文的转化算法.</li><li>解密密钥(Decryption Key):指通过解密算法进行解密操作用的密钥.</li><li>密码分析(Cryptanalysis):指截获密文者试图通过分析截获的密文从而推断出原来的明文或者密钥的过程.</li><li>密码分析者(Cryptanalyst):等同于密码破译者,指从事密码分析的人.</li><li>被动攻击(Passive Attack):指对一个保密系统采取截获密文并对其进行分析和攻击.这种攻击对密文没有破坏作用.</li><li>主动攻击(Active Attack):指攻击者非法入侵密码系统,采用伪造,修改,删除等手段向系统注入假消息进行欺骗.这种攻击对密文具有破坏作用.</li><li>密码体制(Cipher System):由明文空间,密文空间,密钥空间,加密算法和解密算法五部分构成.</li><li>密码协议(Cryptographic Protocol):有时也称为安全协议,指以密码学为基础的信息交换的通信协议,其目的是在网络环境中提供各种安全服务.密码协议与密码算法同等重要,堪称当今密码学研究的两大课题.密码学是网络安全的基础,但网络安全不能单纯依赖安全的密码算法.密码协议是网络安全的一个重要组成部分,通过密码协议进行实体间的认证,在实体间安全地分配密钥或其他各种秘密,确认发生和接受的消息的不可否认性等.</li><li>密码系统(Cryptography):指用于加密和解密的系统.加密时,系统输入明文和加密密钥,加密变化后,输出密文;解密时,系统输入密文和解密密钥,解密变换后,系统输出明文.一个密码系统由信源,加密变换,解密变换,信宿和攻击者组成.密码系统强调密码方案的实际应用,通常应当是一个包含软,硬件的系统.</li><li>柯克霍夫原则(Kerckhoffs’ Principle):数据的安全基于密钥而不是算法的保密.信息论始祖香农将其改为敌人了解系统,这样的说法成为香农箴言.柯克霍夫原则是现代密码学设计的基本原则</li></ul>]]></content>
    
    
    <summary type="html">密码学定义与术语</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>密码学发展历史</title>
    <link href="http://tanqidong1992.github.io/2021/01/24/2021/01/24/history-of-cryptography/"/>
    <id>http://tanqidong1992.github.io/2021/01/24/2021/01/24/history-of-cryptography/</id>
    <published>2021-01-24T15:47:01.000Z</published>
    <updated>2021-10-12T07:34:24.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="密码学发展历史"><a href="#密码学发展历史" class="headerlink" title="密码学发展历史"></a>密码学发展历史</h2><h3 id="手工加密阶段"><a href="#手工加密阶段" class="headerlink" title="手工加密阶段"></a>手工加密阶段</h3><p>使用手工方式完成加密操作,以确保战争中的军事信息的秘密传输,这一阶段称为手工加密.比如中国古代的阴符,阴书;</p><h3 id="机械加密阶段"><a href="#机械加密阶段" class="headerlink" title="机械加密阶段"></a>机械加密阶段</h3><p>19世纪至20世纪初,工业革命促进了机械和机电技术的发展,加速了密码设备的变革-转轮密码机的发明,密码学进入机械加密阶段.密码分析在第一次,第二次世界大战都扮演了重要角色.</p><h3 id="计算机加密阶段"><a href="#计算机加密阶段" class="headerlink" title="计算机加密阶段"></a>计算机加密阶段</h3><p>第二次世界大战之后,计算机与电子学快速发展,促进了密码学进入计算机加密阶段.计算机成为了密码设计与破译的平台.</p><ul><li>利用计算机可以设计出更复杂的加密算法,避免手工设计时容易造成错误.</li><li>利用计算机可以对加密算法进行破译,缩短了破译时间.</li></ul><p>1949年前,密码学是一门艺术,1949年-1975年,密码学成为科学,1976年以后,密码学有了新的方向-公钥密码学;1977年以后,密码学广泛应用到各种场所.</p><ul><li>1949年,信息论始祖香农发表&lt;&lt;保密系统的通信理论&gt;&gt;,把密码学建立在严格的数学基础上,为密码学的发展奠定了理论基础.密码学由此成为一门真正的科学,在此之前,密码学完全是一门艺术,密码的设计和分析完全依赖于密码专家的直觉</li><li>1976年,密码学专家迪菲和赫尔曼两人发表&lt;&lt;密码学的新方向&gt;&gt;,解决了密钥管理的难题,把密钥分为加密的公钥和解密的私钥,提出密钥交换算法(Diffie-Hellman D-H),这是密码学的一场革命.</li><li>1977年,美国国家标准技术研究所(NIST)制定数据加密标准(Data Encryption Standard,DES),将其颁布为国家标准,这是密码学历史上一个具有里程碑意义的事件.</li><li>1977年,密码学家李维斯特,沙米尔,阿德勒曼在麻省理工学院,共同提出第一个比较完善的公钥密码体制-RSA体制(建立在大数因子分解基础上的算法),RSA为数字签名奠定了基础,RSA源于整数因子分解问题,DSA源于离散对数问题.RSA和DSA是两种最流行的数字签名机制.数字签名是PKI,网络安全机制的基础.从此以后,密码学成为通信,计算机网络,计算机安全等方面的重要工具.</li><li>1985年,英国牛津大学物理学家戴维.多维奇提出量子计算机的初步设想.利用量子计算机,仅需30秒钟即可完成传统计算机花上100亿年才能完成的大数因子分解,从而破解RSA运用这个大数产生公钥来加密的信息.</li><li>1985年,物理学家贝内特根据多维奇关于量子密码术的协议,在实验室中第一次实现了量子密码加密信息通信.尽管通信距离只有30cm.</li><li>1997年1月,美国国家标准技术研究所征集新一代数据加密标准,即高级数据加密标准(Advanced Encryption Standard,AES).最终比利时密码学家兼计算机科学家Vincent Rihmen和Joan Daemen设计的Rijndael算法入选.高级数据加密标准用以替换原先的DES,2002年5月26日,美国国家标准技术研究所将其定位有效加密标准.</li><li>2003年,位于日内瓦的id Quantique公司和位于纽约的MagiQ技术公司,推出了传送量子密钥的距离超过贝内特实验室中30cm的商业产品.由此,量子密码学进入商业化.</li></ul><p>进入计算机加密阶段后,密码学的应用不再局限于军事,政治和外交领域,逐步扩大到商务,金融和社会的其他各个领域.密码学的研究和应用已大规模扩展到了民用方面.</p>]]></content>
    
    
    <summary type="html">密码学发展历史</summary>
    
    
    
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="密码学" scheme="http://tanqidong1992.github.io/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
    <category term="历史" scheme="http://tanqidong1992.github.io/tags/%E5%8E%86%E5%8F%B2/"/>
    
  </entry>
  
  <entry>
    <title>Rust基础</title>
    <link href="http://tanqidong1992.github.io/2021/01/04/2021/01/04/base-of-rust/"/>
    <id>http://tanqidong1992.github.io/2021/01/04/2021/01/04/base-of-rust/</id>
    <published>2021-01-04T02:28:47.000Z</published>
    <updated>2021-10-12T07:34:24.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Rust基础"><a href="#Rust基础" class="headerlink" title="Rust基础"></a>Rust基础</h1><h2 id="变量与可变性"><a href="#变量与可变性" class="headerlink" title="变量与可变性"></a>变量与可变性</h2><p>在Rust中变量是默认不可变的,如果要定义一个可变变量必须使用<strong>mut</strong>修饰.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">5</span>; <span class="comment">//x是不可变的变量</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> mutable_variable=<span class="number">6</span>; <span class="comment">// mutable_variable是可变变量</span></span><br></pre></td></tr></table></figure><h2 id="变量与常量的区别"><a href="#变量与常量的区别" class="headerlink" title="变量与常量的区别"></a>变量与常量的区别</h2><ol><li>常量不只是不可变,而是一直不可变.</li><li>你需要使用const而不是let声明一个常量,必须加上数据类型注解</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">       <span class="keyword">const</span> MAX_POINT:<span class="built_in">u32</span>=<span class="number">12_000</span>;</span><br><span class="line">   ```<span class="number">3</span>. 常量可以定义在任何作用域.</span><br><span class="line"><span class="number">4</span>. 常量必须设定成一个常量表达式,而不是一个函数的结果,或者其他只在运行时计算出的结果.</span><br><span class="line"></span><br><span class="line">## Shadowing</span><br><span class="line"></span><br><span class="line">同一个变量名可以多次定义,后一次定义会覆盖前一次的定义,如下所示</span><br><span class="line"></span><br><span class="line">```rust</span><br><span class="line">    <span class="keyword">let</span> x:<span class="built_in">i32</span>=<span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> x:<span class="built_in">u32</span>=<span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>备注: Shadowing不同与mut,Shadowing是定义一个新的变量.</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Rust中有两种数据类型子集:标量(Scalar),混合量(Compound);</p><h3 id="标量-Scalar"><a href="#标量-Scalar" class="headerlink" title="标量(Scalar)"></a>标量(Scalar)</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>|长度|有符号|无符号||:–:|:–:|:–:||8bit|i8|u8|<br>|16bit|i8|u8|<br>|32bit|i32|u32|<br>|64bit|i64|u64|<br>|128bit|i128|u128|<br>|arch|isize|usize|</p><p>备注:</p><ul><li>有符号的取值范围为 -2^(n-1) – 2^(n-1)-1;</li><li>无符号的取值范围为 0 – 2^n-1</li><li>isize的长度,取决于架构类型,如果是64位架构,那就是64bit,如果是32位架构,那就是32bit.</li></ul><h5 id="整数的字面量书写形式"><a href="#整数的字面量书写形式" class="headerlink" title="整数的字面量书写形式"></a>整数的字面量书写形式</h5><p>|字面量|示例||:–:|:–:||十进制(Decimal)|10_000|<br>|十六进制(Hex)|0xff|<br>|八进制(Octal)|0o12|<br>|二进制(Binary)|0b111_000|<br>|Byte(u8)|b’A’|</p><h5 id="整型溢出"><a href="#整型溢出" class="headerlink" title="整型溢出"></a>整型溢出</h5><p>当发生整型溢出时,Debug模式下Rust会检查并抛出错误信息,而在Release(–release)模式下,Rust不会检查,Rust执行二进制补码包装.例如u8类型,256变成0,257变成1.</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>Rust支持单精度已经双精度的浮点类型分别为f32,f64,参考IEEE-754标准.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f1=<span class="number">3.0</span>; <span class="comment">// f1 data type is f64</span></span><br><span class="line"><span class="keyword">let</span> f2:<span class="built_in">f32</span>=<span class="number">3.0</span>; <span class="comment">//f2 data type is f32</span></span><br></pre></td></tr></table></figure><p><strong>备注:默认的浮点类型为f64,现代的cpu对于f64与f32的处理速度差不多,而f64进度更高.</strong></p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><h4 id="布尔类型-Boolean"><a href="#布尔类型-Boolean" class="headerlink" title="布尔类型(Boolean)"></a>布尔类型(Boolean)</h4><p>Rust中的布尔类型为bool,占用1个字节,可取值为false,true;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> y=<span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4 id="字符类型-Character"><a href="#字符类型-Character" class="headerlink" title="字符类型(Character)"></a>字符类型(Character)</h4><p>Rust中的字符类型关键字为char,占用4个字节,存储Unicode标准值.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c=<span class="string">&#x27;a&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="混合量-Compound"><a href="#混合量-Compound" class="headerlink" title="混合量(Compound)"></a>混合量(Compound)</h2><p>Rust支持两种基本的混合量:元组(Tuple),数组(Array)</p><h3 id="元组-Tuple"><a href="#元组-Tuple" class="headerlink" title="元组(Tuple)"></a>元组(Tuple)</h3><p>元组是由不同类型的多个值组成的一个混合量,元组具有固定的长度,一旦声明,无法增加或者减少.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tup=(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> (x,y,z)=tup;</span><br><span class="line"><span class="keyword">let</span> first_number=tup.<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="数组-Array"><a href="#数组-Array" class="headerlink" title="数组(Array)"></a>数组(Array)</h3><p>数组是由多个同类型的值组成的一个混合量,不同于元组,数组的每一个值的类型都是一样的,数组的长度是固定的.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//指定类型为i32,长度为3</span></span><br><span class="line"><span class="keyword">let</span> b[<span class="built_in">i32</span>;<span class="number">3</span>]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="comment">//重复5次填充3</span></span><br><span class="line"><span class="keyword">let</span> repeat=[<span class="number">3</span>;<span class="number">5</span>]; <span class="comment">// as [3,3,3,3,3];</span></span><br><span class="line"><span class="comment">//访问数组</span></span><br><span class="line"><span class="keyword">let</span> first_element=a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>备注:Rust会对数组访问进行越界检查,越界访问会抛出异常(panic)</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数由fn关键字,函数名,参数列表,返回类型,函数体组成;其中参数列表,返回类型可以省略;<br>语法如下</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无返回值,无参数</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>()&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(width:<span class="built_in">u32</span>,height:<span class="built_in">u32</span>)-&gt;<span class="built_in">u32</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> width*height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h3><p>函数体可以包含语句以及表达式(表达式只能在尾部作为返回值)</p><p>备注:语句与表达式:语句是执行一些动作但没有返回值的指令;表达式被计算有一个结果.<br>例如</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> y=<span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line">``````rust</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>()&#123;</span><br><span class="line">    <span class="comment">//error: expected expression, found statement (`let`)</span></span><br><span class="line">    <span class="keyword">let</span> x=(<span class="keyword">let</span> y=<span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// haha</span></span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><h4 id="if表达式"><a href="#if表达式" class="headerlink" title="if表达式"></a>if表达式</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">if</span> x&gt;<span class="number">10</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> x&gt;<span class="number">5</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="let语句中使用if表达式"><a href="#let语句中使用if表达式" class="headerlink" title="let语句中使用if表达式"></a>let语句中使用if表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x=4;</span><br><span class="line">ley y= if x&gt;0 &#123;</span><br><span class="line">    1</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>备注:各个分支的返回必须是相同的.</strong></p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="无限循环-loop"><a href="#无限循环-loop" class="headerlink" title="无限循环(loop)"></a>无限循环(loop)</h4><p>loop关键字,循环执行一段指令,直到显示的停止;</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">loop</span>&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Again!&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loop循环体是可以返回值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let n=1;</span><br><span class="line">let sum=loop&#123;</span><br><span class="line">    n=n+1;</span><br><span class="line">    if n &gt;= 10 &#123;</span><br><span class="line">        break n*2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="条件循环-while"><a href="#条件循环-while" class="headerlink" title="条件循环(while)"></a>条件循环(while)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> n&gt;<span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>,n);</span><br><span class="line">    n=n-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="遍历-for"><a href="#遍历-for" class="headerlink" title="遍历(for)"></a>遍历(for)</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> a.iter()&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value is :&#123;&#125;&quot;</span>,element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Rust基础语法</summary>
    
    
    
    
    <category term="Rust" scheme="http://tanqidong1992.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>进程内存</title>
    <link href="http://tanqidong1992.github.io/2020/12/21/2020/12/21/process-momory/"/>
    <id>http://tanqidong1992.github.io/2020/12/21/2020/12/21/process-momory/</id>
    <published>2020-12-20T23:20:17.000Z</published>
    <updated>2021-10-12T07:34:24.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程内存"><a href="#进程内存" class="headerlink" title="进程内存"></a>进程内存</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><p>进程内存占用主要由以下几部分组成:</p><ul><li>自身代码</li><li>共享库代码</li><li>运行过程中分配的堆和栈</li><li><del>通过mmap映射的磁盘文件内容</del></li></ul><h2 id="虚拟内存与物理内存"><a href="#虚拟内存与物理内存" class="headerlink" title="虚拟内存与物理内存"></a>虚拟内存与物理内存</h2><p>物理内存对于进程来说是透明的,进程直接操作的是虚拟内存.进程向操作系统申请内存的时候,分配的是虚拟内存(地址空间),只有当进程使用这部分内存时,操作系统才会将相应的物理内存与相应的虚拟内存关联(缺页中断).</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>从进程来看,虚拟内存是进程独立的,所有内存都是私有的,包括自身代码,共享库,堆栈等.但实际在物理层面很多东西是可以共享的,比如共享库,自身代码,甚至是自身私有的堆栈.</p><h3 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h3><p>同一个共享库的代码在物理内存中只存在一份,这块内存会映射到不同进程的虚拟内存中,对进程而言是自己的私有内存,对于操作系统而言,则是节省了内存的资源.</p><h3 id="进程的自身代码"><a href="#进程的自身代码" class="headerlink" title="进程的自身代码"></a>进程的自身代码</h3><p>当同一个程序运行多个进程时,其自身代码也被共享</p><h3 id="进程的私有内存"><a href="#进程的私有内存" class="headerlink" title="进程的私有内存"></a>进程的私有内存</h3><p>当从一个进程fork出一个子进程时,那么父进程的私有内存则会与子进程共享,但会被标记为copy-on-write.</p><h2 id="进程内存大小的度量方法"><a href="#进程内存大小的度量方法" class="headerlink" title="进程内存大小的度量方法"></a>进程内存大小的度量方法</h2><h3 id="VSZ-Virtual-Memory-Size"><a href="#VSZ-Virtual-Memory-Size" class="headerlink" title="VSZ(Virtual Memory Size)"></a>VSZ(Virtual Memory Size)</h3><p>虚拟内存大小,进程运行理论上需要内存的大小,形容进程运行时所需要的总内存大小,包括哪些还没有被加载到实际内存中的代码和数据.</p><h3 id="RSS-Resident-Set-Size"><a href="#RSS-Resident-Set-Size" class="headerlink" title="RSS(Resident Set Size)"></a>RSS(Resident Set Size)</h3><p>常驻内存大小(工作集),表示实际使用物理内存的大小,包含了共享库占用的内存,(不包括已经被置换到磁盘的内存)</p><h3 id="PSS-Proportional-Set-Size"><a href="#PSS-Proportional-Set-Size" class="headerlink" title="PSS(Proportional Set Size)"></a>PSS(Proportional Set Size)</h3><p>实际使用物理内存大小,比例分配共享库占用的内存,比如用到的某个100K共享库共有2个程序用到,那么被计算为100k/2=50k</p><h3 id="USS-Unique-Set-Size"><a href="#USS-Unique-Set-Size" class="headerlink" title="USS(Unique Set Size)"></a>USS(Unique Set Size)</h3><p>进程独占物理内存大小,不包含共享库.</p><h2 id="计算示例"><a href="#计算示例" class="headerlink" title="计算示例"></a>计算示例</h2><p>假如要度量进程占用的内存大小，较好的选择是使用PSS，用RSS也行，不过要注意有些内存是和别的进程共享的。</p><p>再举个例子总结一下前面三个概念，比方一个进程有500K的代码并且链接了2500K的共享库，而后有200K的堆栈分配。其中有400K自身的代码、1000K的共享库以100K的堆栈内存被加载在实际内存（RAM）中，并且系统中一共有两个进程用了同样的共享库。那么：</p><p>VSZ：500K + 2500K + 200K = 3200K</p><p>RSS：400K + 1000K + 100K = 1500K</p><p>PSS：400K + (1000K / 2) + 100K = 1000K</p><p>USS: 400K + 100K = 500K</p>]]></content>
    
    
    <summary type="html">进程内存说明</summary>
    
    
    
    
    <category term="进程内存" scheme="http://tanqidong1992.github.io/tags/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Shell变量</title>
    <link href="http://tanqidong1992.github.io/2020/12/12/2020/12/Shell%E5%8F%98%E9%87%8F/"/>
    <id>http://tanqidong1992.github.io/2020/12/12/2020/12/Shell%E5%8F%98%E9%87%8F/</id>
    <published>2020-12-12T05:22:47.000Z</published>
    <updated>2021-10-12T07:34:24.621Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h1><h2 id="Bash中的参数扩展"><a href="#Bash中的参数扩展" class="headerlink" title="Bash中的参数扩展"></a>Bash中的参数扩展</h2><p>参数是一个存储数值的实体，并由名称,数字或特定符号所引用。</p><ul><li>被名称引用的参数称为变量。</li><li>被数字引用的参数称为位置参数。</li><li>被特定符号引用的参数具有特殊的含义和用途，被称为Bash的特殊内部变量引用。</li></ul><p>参数扩展是从引用的实体取值的过程，就像扩展变量打印它的值。<br>字符’$’会引导参数扩展。将要扩展的参数名或者符号可以放到大括号中。大括号是可选的，但却可以保护待扩展的变量，使得紧跟大括号后的内容不会被扩展</p><h3 id="基本参数扩展"><a href="#基本参数扩展" class="headerlink" title="基本参数扩展"></a>基本参数扩展</h3><p>基本参数扩展形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">parameter</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter&#125;</span></span><br></pre></td></tr></table></figure><p>如果参数名后还有其他字符，这时候大括号是必须的。示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name=&#x27;tqd&#x27;</span><br><span class="line">echo $names </span><br><span class="line"><span class="meta">#</span><span class="bash">输出内容为空</span></span><br><span class="line">echo $&#123;name&#125;s</span><br><span class="line"><span class="meta">#</span><span class="bash">输出内容为tqds</span></span><br></pre></td></tr></table></figure><p>上述示例 第一个echo命令的输出为空，是因为参数名names是未定义的。对于未使用大括号的参数扩展，Bash会从字符’$’开始到最后一个有效字符结束的所有可用的字符序列解释为参数名。当使用大括号时，会强制Bash只解释大括号内的名称。<br>备注：对于访问$9之后的位置参数也同样需要使用大括号，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set 1a 2a 3a 4a 5a 6a 7a 8a 9a 10a 11a</span><br><span class="line">echo $10</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为1a0</span></span><br><span class="line">echo $&#123;10&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为10a</span></span><br></pre></td></tr></table></figure><p><strong>注意:参数名是大小写敏感的。</strong></p><h3 id="间接参数扩展"><a href="#间接参数扩展" class="headerlink" title="间接参数扩展"></a>间接参数扩展</h3><p>间接参数扩展的基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;!parameter&#125;</span></span><br></pre></td></tr></table></figure><p>上述语句，被引用的参数不是parameter自身，而是parameter的值。示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">temp=&#x27;tqd&#x27;</span><br><span class="line">userName=&#x27;temp&#x27;</span><br><span class="line">echo $&#123;!userName&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为tqd</span></span><br><span class="line">echo $&#123;userName&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为temp</span></span><br></pre></td></tr></table></figure><h3 id="大小写扩展"><a href="#大小写扩展" class="headerlink" title="大小写扩展"></a>大小写扩展</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter^&#125;    <span class="comment">#将参数值中的第一个字符改为大小(对字母才有效）</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter^^&#125;   <span class="comment">#将参数值中的所有字符改为大写</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter,&#125;    <span class="comment">#将参数值中的第一个字符改为小写</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter,,&#125;   <span class="comment">#将参数值中的所有字符改为小写</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter~&#125;    <span class="comment">#将参数值中的第一个字符的大小写取反</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter~~&#125;   <span class="comment">#将参数值中的所有字符的大小写取反</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">person_alias=&quot;QidongTan&quot;</span><br><span class="line">echo $&#123;person_alias^&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为QidongTan</span></span><br><span class="line">echo $&#123;person_alias^^&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为QIDONGTAN</span></span><br><span class="line">echo $&#123;person_alias,&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为qidongTan</span></span><br><span class="line">echo $&#123;person_alias,,&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为qidongtan</span></span><br><span class="line">echo $&#123;person_alias~&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为qidongTan</span></span><br><span class="line">echo $&#123;person_alias~~&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为qIDONGtAN</span></span><br></pre></td></tr></table></figure><h3 id="变量名扩展"><a href="#变量名扩展" class="headerlink" title="变量名扩展"></a>变量名扩展</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;!PREFIX@&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;!PREFIX*&#125; 列出所有以PREFIX开头的变量名，并以空格隔开</span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;!BASH@&#125;</span><br><span class="line">输出为：BASH BASHOPTS BASHPID BASH_ALIASES BASH_ARGC BASH_ARGV BASH_ARGV0 BASH_CMDS BASH_COMMAND BASH_COMPLETION_VERSINFO BASH_LINENO BASH_REMATCH BASH_SOURCE BASH_SUBSHELL BASH_VERSINFO BASH_VERSION</span><br><span class="line">for parameter in $&#123;!BASH*&#125;</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value of $&#123;parameter&#125; is $&#123;!parameter&#125;&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="字符串移除"><a href="#字符串移除" class="headerlink" title="字符串移除"></a>字符串移除</h3><p>基本形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter<span class="comment">#PATTERN&#125;    #从参数值的开始，移除最短匹配PATTERN的子串</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter<span class="comment">##PATTERN&#125;   #从参数值的开始，移除最长匹配PATTERN的子串</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter%PATTERN&#125;    <span class="comment">#从参数值的结尾向前，移除最短匹配PATTERN的子串</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter%%PATTERN&#125;   <span class="comment">#从参数值的结尾向前，移除最长匹配PATTERN的子串</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str=test.tar.gz</span><br><span class="line">echo $&#123;str#*.&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为tar.gz</span></span><br><span class="line">echo $&#123;str##*.&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为gz</span></span><br><span class="line">echo $&#123;str%.*&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为test.tar</span></span><br><span class="line">echo $&#123;str%%.*&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为<span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><h3 id="字符串搜索与替换"><a href="#字符串搜索与替换" class="headerlink" title="字符串搜索与替换"></a>字符串搜索与替换</h3><p>基本形式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter/PATTERN/STRING&#125;    <span class="comment"># 将参数值中第一个匹配PATTERN的子串替换为STRING</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter//PATTERN/STRING&#125;   <span class="comment"># 将参数值中所有匹配PATTERN的子串替换为STRING</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter/PATTERN&#125;           <span class="comment"># 将参数值中第一个匹配PATTERN的子串删除</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter//PATTERN&#125;          <span class="comment"># 将参数值中所有匹配PATTERN的子串删除</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;You are a beautiful girl,I do love You&quot;</span><br><span class="line">echo $&#123;str/You/She&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为She are a beautiful girl,I <span class="keyword">do</span> love You</span></span><br><span class="line">echo $&#123;str//You/She&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为She are a beautiful girl,I <span class="keyword">do</span> love She</span></span><br><span class="line">echo $&#123;str/You&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为are a beautiful girl,I <span class="keyword">do</span> love You</span></span><br><span class="line">echo $&#123;str//You&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为are a beautiful girl,I <span class="keyword">do</span> love</span></span><br></pre></td></tr></table></figure><h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;<span class="comment">#parameter&#125; #获取参数值的长度</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;You,a beautiful girl!&quot;</span><br><span class="line">echo $&#123;#str&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为21</span></span><br></pre></td></tr></table></figure><h3 id="子字符串扩展"><a href="#子字符串扩展" class="headerlink" title="子字符串扩展"></a>子字符串扩展</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;str:OFFSET&#125;        <span class="comment">#从OFFSET开始，到参数值的结尾的子字符串</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;str:OFFSET:LENGTH&#125; <span class="comment">#从OFFSET开始，获取长度为LENGTH的子字符串</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str=&quot;12345678&quot;</span><br><span class="line">echo $&#123;str:2:2&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为34</span></span><br><span class="line">echo $&#123;str:7&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为8</span></span><br><span class="line">echo $&#123;str:9&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为空</span></span><br><span class="line">echo $&#123;str:7:10&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为8</span></span><br></pre></td></tr></table></figure><h3 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:-defaultValue&#125; <span class="comment">#当parameter未定义或者为空时,扩展为defaultValue</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter-defaultValue&#125;  <span class="comment">#当parameter未定义时，扩展为defaultValue</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">t=&#x27;&#x27;</span><br><span class="line">echo &quot;empty t:- $&#123;t:-defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t:- defaultValue</span></span><br><span class="line">echo &quot;empty t- $&#123;t-defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t-</span></span><br><span class="line">echo &quot;empty t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t</span> </span><br><span class="line">unset t</span><br><span class="line">echo &quot;undefined t:- $&#123;t:-defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undifined t:- defaultValue</span></span><br><span class="line">echo &quot;undefined t- $&#123;t-defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undifined t- defaultValue</span></span><br><span class="line">echo &quot;undefined t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t</span></span><br></pre></td></tr></table></figure><h3 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:=defaultValue&#125; <span class="comment">#当parameter未定义或者为空时，将parameter的值赋值为defaultValue并且扩展为defaultValue</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter=defaultValue&#125;  <span class="comment">#当parameter未定义时，将parameter的值赋值为defaultValue并且扩展为defaultValue</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">t=&#x27;&#x27;</span><br><span class="line">echo &quot;empty t:= $&#123;t:=defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t:= defaultValue</span></span><br><span class="line">echo &quot;empty t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t defaultValue</span></span><br><span class="line">t=&#x27;&#x27;</span><br><span class="line">echo &quot;empty t= $&#123;t=defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t=</span> </span><br><span class="line">echo &quot;empty t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t</span> </span><br><span class="line">unset t</span><br><span class="line">echo &quot;undefined t:= $&#123;t:=defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t:= defaultValue</span></span><br><span class="line">echo &quot;undefined t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t defaultValue</span></span><br><span class="line">unset t</span><br><span class="line">echo &quot;undefined t= $&#123;t=defaultValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t= defaultValue</span></span><br><span class="line">echo &quot;undefined t $&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t defaultValue</span></span><br></pre></td></tr></table></figure><h3 id="使用替代值"><a href="#使用替代值" class="headerlink" title="使用替代值"></a>使用替代值</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:+replaceValue&#125; <span class="comment"># 当parameter不为空时，扩展为替代值</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter+replaceValue&#125;  <span class="comment"># 当parameter为空或者不为空时，扩展为替代值</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">t=&quot;1&quot;</span><br><span class="line">echo &quot;no empty t:+$&#123;t:+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为no empty t:+replaceValue</span></span><br><span class="line">echo &quot;no empty t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为no empty t1</span></span><br><span class="line">t=&quot;1&quot;</span><br><span class="line">echo &quot;no empty t+$&#123;t+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为no empty t+replaceValue</span></span><br><span class="line">echo &quot;no empty t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为no empty t1</span></span><br><span class="line">t=&quot;&quot;</span><br><span class="line">echo &quot;empty t:+$&#123;t:+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t:+</span></span><br><span class="line">echo &quot;empty t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t</span></span><br><span class="line">t=&quot;&quot;</span><br><span class="line">echo &quot;empty t+$&#123;t+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t+replaceValue</span></span><br><span class="line">echo &quot;empty t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为empty t</span></span><br><span class="line">unset t</span><br><span class="line">echo &quot;undefined t:+$&#123;t:+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t:+</span></span><br><span class="line">echo &quot;undefined t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t</span></span><br><span class="line">unset t</span><br><span class="line">echo &quot;undefined t+$&#123;t+replaceValue&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t+</span></span><br><span class="line">echo &quot;undefined t$&#123;t&#125;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为undefined t</span></span><br></pre></td></tr></table></figure><h3 id="缺失或者为空错误提示"><a href="#缺失或者为空错误提示" class="headerlink" title="缺失或者为空错误提示"></a>缺失或者为空错误提示</h3><p>基本形式如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:?Error:parameter is undefined or empty&#125; <span class="comment">#当parameter未定义或者为空时，报错</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">&#123;parameter:Error:parameter is undefined&#125;           <span class="comment">#当parameter未定义时，报错</span></span></span><br></pre></td></tr></table></figure><p>示例如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">t=&quot;&quot;</span><br><span class="line">echo $&#123;t:?Error t is empty or undefined&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">报错 ./use-error.sh: line 3: t: Error t is empty or undefined</span></span><br><span class="line">t=&quot;&quot;</span><br><span class="line">echo $&#123;t?Error t is undefined&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">不报错</span></span><br><span class="line">unset t</span><br><span class="line">echo $&#123;t:?Error t is empty or undefined&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">报错 ./use-error.sh: line 3: t: Error t is empty or undefined</span></span><br><span class="line">unset t</span><br><span class="line">echo $&#123;t?Error t is undefined&#125;</span><br><span class="line">./use-error.sh: line 8: t: Error t is undefined</span><br><span class="line"><span class="meta">#</span><span class="bash">报错</span></span><br></pre></td></tr></table></figure><h2 id="Bash的内部变量"><a href="#Bash的内部变量" class="headerlink" title="Bash的内部变量"></a>Bash的内部变量</h2><h3 id="常用内部变量"><a href="#常用内部变量" class="headerlink" title="常用内部变量"></a>常用内部变量</h3><p>|变量名|备注|值||:–|:–|:–||$BASH|Bash实例的全路径名|/bin/bash|<br>|$HOME|当前用户的home目录|一般是/home/${USER}|<br>|$IFS|此变量决定当Bash解析字符串时，如何失败字段或者单词分割线|默认为空格，制表符和换行|<br>|$OSTYPE|操作系统的类型||<br>|$SECONDS|当前脚本已执行的秒数||<br>|$TMOUT|作为Bash内部命令read的默认超时值,指定秒数内未输入，跳过输入，值为空||<br>|$UID|当前用户的帐号标识码，与/etc/passwd记录相同||</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">echo $BASH</span><br><span class="line">echo $HOME</span><br><span class="line">set 1 2 3</span><br><span class="line">IFS=&#x27;,:&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash">这里再一次体现<span class="string">&quot;<span class="variable">$@</span>&quot;</span>与<span class="string">&quot;@*&quot;</span>的区别<span class="string">&quot;<span class="variable">$@</span>&quot;</span>=<span class="string">&quot;<span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span> <span class="variable">$4</span>...&quot;</span> <span class="string">&quot;$*&quot;</span>=<span class="string">&quot;<span class="variable">$&#123;1&#125;</span><span class="variable">$&#123;IFS&#125;</span><span class="variable">$&#123;2&#125;</span><span class="variable">$&#123;IFS&#125;</span>...&quot;</span></span>  </span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo $*</span><br><span class="line">echo $TMOUT</span><br><span class="line">TMOUT=3</span><br><span class="line">read a;</span><br><span class="line">echo &quot;The value of a is:$&#123;a&#125;&quot;</span><br><span class="line"></span><br><span class="line">echo $UID</span><br></pre></td></tr></table></figure><h2 id="Bash中的位置参数和特殊参数"><a href="#Bash中的位置参数和特殊参数" class="headerlink" title="Bash中的位置参数和特殊参数"></a>Bash中的位置参数和特殊参数</h2><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>Bash的位置参数是除了0以外的一个或者多个数字表示的参数。</p><p>位置参数是当Shell或者Shell的函数被引用时由Shell或者Shell函数的参数赋值，并且可以使用Bash内部命令set来重新赋值，位置参数可以被引用为${N},当N只有一个数字时，可写成$N</p><p><strong>注意：多于一个数字的位置参数在扩展时必须放到大括号中，比如位置参数10，写成${10}</strong>.</p><p>位置参数不能通过赋值语句来赋值，只能通过Bash内部命令set和shift来设置和取消它们，当shell运行时，位置参数会被临时替换。</p><ul><li>set用法为 set 1 2 3..N;设置1，2，3…N位置的参数。</li><li>shift用法为： shift N;删除前N个参数。ff</li></ul><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set 1a 2b 3c 4d 5e 6f 7g 8h 9i 10j</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为1a 2b 3c 4d 5e 6f 7g 8h 9i 10j</span></span><br><span class="line">echo $&#123;10&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为10j</span></span><br><span class="line">shift 2</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash">输出为3c 4d 5e 6f 7g 8h 9i 10j</span></span><br></pre></td></tr></table></figure><h3 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数"></a>特殊参数</h3><p>|符号|描述||:–:|:–||<em>|扩展为从1开始的所有位置参数，如果在双引号之间,即”$</em>“,则扩展为包含每一个参数值的单词，每个参数值之间用特殊变量IFS的第一个字符隔开，即”$*“=”$1c$2c$3”|<br>|@|扩展为从1开始的所有位置参数，如果在双引号之间，即”$@”等价于”$1” “$2” …|<br>|#|扩展为位置参数的个数，十进制表示|<br>|?|最近一个前台命令的推出状态，通常状态0表示已经没有任何错误地结束运行|<br>|-|扩展为当前的选项标志，这些选项是在调用时，或者由内部命令set指定，或者shell自身指定|<br>|$|扩展为当前脚本的进程号|<br>|!|扩展为上一个后台命令的进程号|<br>|0|扩展为Shell或者Shell脚本的名称，它是Shell初始化时设置的。如果Bash调用时带有脚本文件作为参数,那么$0就设置为脚本的文件名|<br>|_|在Shell启动时，它被设为开始运行Shell脚本或者脚本的路径，随后，扩展为上一个命令的最后一个参数|</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例@,*,"></a>示例@,*,</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">set 1a 2b 3c 4d 5f &#x27;6d d&#x27;</span><br><span class="line">oldIfs=$IFS</span><br><span class="line">IFS=&quot;,&quot;</span><br><span class="line">echo $*</span><br><span class="line">echo &quot;$*&quot;</span><br><span class="line">echo $@</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;arg count:$#&quot;</span><br><span class="line">echo &#x27;for arg in $*&#x27;</span><br><span class="line">i=1;</span><br><span class="line">for arg in $* </span><br><span class="line">do</span><br><span class="line">    echo &quot;arg $&#123;i&#125;: $&#123;arg&#125;&quot;</span><br><span class="line">    let i++</span><br><span class="line">done</span><br><span class="line">i=1</span><br><span class="line">echo &#x27;for arg in &quot;$*&quot;&#x27;</span><br><span class="line">for arg in &quot;$*&quot; </span><br><span class="line">do</span><br><span class="line">    echo &quot;arg $&#123;i&#125;: $&#123;arg&#125;&quot;</span><br><span class="line">    let i++</span><br><span class="line">done</span><br><span class="line">echo &#x27;for arg in $@&#x27;</span><br><span class="line">i=1</span><br><span class="line">for arg in $@ </span><br><span class="line">do</span><br><span class="line">    echo &quot;arg $&#123;i&#125;: $&#123;arg&#125;&quot;</span><br><span class="line">    let i++</span><br><span class="line">done</span><br><span class="line">echo &#x27;for arg in &quot;$@&quot;&#x27;</span><br><span class="line">i=1</span><br><span class="line">for arg in &quot;$@&quot; </span><br><span class="line">do</span><br><span class="line">    echo &quot;arg $&#123;i&#125;: $&#123;arg&#125;&quot;</span><br><span class="line">    let i++</span><br><span class="line">done</span><br><span class="line">IFS=&quot;$oldIfs&quot;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">1a 2b 3c 4d 5f 6d d</span><br><span class="line">1a,2b,3c,4d,5f,6d d</span><br><span class="line">1a 2b 3c 4d 5f 6d d</span><br><span class="line">1a 2b 3c 4d 5f 6d d</span><br><span class="line">arg count:6</span><br><span class="line">for arg in $*</span><br><span class="line">arg 1: 1a</span><br><span class="line">arg 2: 2b</span><br><span class="line">arg 3: 3c</span><br><span class="line">arg 4: 4d</span><br><span class="line">arg 5: 5f</span><br><span class="line">arg 6: 6d d</span><br><span class="line">for arg in &quot;$*&quot;</span><br><span class="line">arg 1: 1a,2b,3c,4d,5f,6d d</span><br><span class="line">for arg in $@</span><br><span class="line">arg 1: 1a</span><br><span class="line">arg 2: 2b</span><br><span class="line">arg 3: 3c</span><br><span class="line">arg 4: 4d</span><br><span class="line">arg 5: 5f</span><br><span class="line">arg 6: 6d d</span><br><span class="line">for arg in &quot;$@&quot;</span><br><span class="line">arg 1: 1a</span><br><span class="line">arg 2: 2b</span><br><span class="line">arg 3: 3c</span><br><span class="line">arg 4: 4d</span><br><span class="line">arg 5: 5f</span><br><span class="line">arg 6: 6d d</span><br></pre></td></tr></table></figure><h4 id="示例0"><a href="#示例0" class="headerlink" title="示例0"></a>示例0</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo $0</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/work/study/shell-learn/variable$ . arg0.sh</span><br><span class="line">/bin/bash</span><br><span class="line">tqd@tqd-pc:/work/study/shell-learn/variable$ ./arg0.sh</span><br><span class="line">./arg0.sh</span><br></pre></td></tr></table></figure><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例_"></a>示例_</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo $_</span><br><span class="line">echo &quot;underscore msg&quot;</span><br><span class="line">echo $_</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/work/study/shell-learn/variable$ ./underscore.sh</span><br><span class="line">./underscore.sh</span><br><span class="line">underscore msg</span><br><span class="line">underscore msg</span><br></pre></td></tr></table></figure><h2 id="使用declare指定变量的类型"><a href="#使用declare指定变量的类型" class="headerlink" title="使用declare指定变量的类型"></a>使用declare指定变量的类型</h2><p>declare是Bash的内部命令，它与Bash的另一个内部命令typeset的用法与用途完全相同。</p><ol><li>直接使用declare将打印所有变量的值</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   tqd@tqd-pc:/data/me/blog-test$ declare | more</span><br><span class="line">   BASH=/bin/bash</span><br><span class="line">   BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:e   xtglob:extquote:force_fignore:globasciiranges:histappend:interact   ive_comments:progcomp:promptvars:sourcepath</span><br><span class="line">   BASH_ALIASES=()</span><br><span class="line">   BASH_ARGC=([0]=&quot;0&quot;)</span><br><span class="line">   BASH_ARGV=()</span><br><span class="line">   BASH_CMDS=()</span><br><span class="line">   BASH_COMPLETION_VERSINFO=([0]=&quot;2&quot; [1]=&quot;10&quot;)</span><br><span class="line">   BASH_LINENO=()</span><br><span class="line">   BASH_SOURCE=()</span><br><span class="line">   BASH_VERSINFO=([0]=&quot;5&quot; [1]=&quot;0&quot; [2]=&quot;17&quot; [3]=&quot;1&quot; [4]=&quot;release&quot; [5]   =&quot;x86_64-pc-linux-gnu&quot;)</span><br><span class="line">   BASH_VERSION=&#x27;5.0.17(1)-release&#x27;</span><br><span class="line">   CHROME_DESKTOP=code-url-handler.desktop</span><br><span class="line">   CINNAMON_VERSION=4.6.7</span><br><span class="line">   --More--</span><br><span class="line">   ```2. -r 将指定变量定义为只读变量</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line"><span class="meta">   #</span><span class="bash">!/bin/bash</span></span><br><span class="line">   declare -r a=1;</span><br><span class="line">   echo &quot;The readonly variable is:$&#123;a&#125;&quot;</span><br><span class="line">   a=2</span><br><span class="line">   unset a</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   tqd@tqd-pc:/work/study/shell-learn/variable$ ./declare-test.sh</span><br><span class="line">   The readonly variable is:1</span><br><span class="line">   ./declare-test.sh: line 4: a: readonly variable</span><br><span class="line">   ./declare-test.sh: line 5: unset: a: cannot unset: readonly variable</span><br><span class="line">   ```3. -i将变量定义为整型变量，赋予整型变量的任何类型的值都将转化为整数</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   declare -i n;</span><br><span class="line">   n=1</span><br><span class="line">   echo &quot;n=1 is $n&quot;</span><br><span class="line">   n=2</span><br><span class="line">   echo &quot;n=2 is $n&quot;</span><br><span class="line">   n=&#x27;a&#x27;;</span><br><span class="line">   echo &quot;n=a is $n&quot;</span><br><span class="line">   n=&#x27;b&#x27;;</span><br><span class="line">   echo &quot;n=b is $n&quot;</span><br><span class="line">   n=&#x27;abc&#x27;;</span><br><span class="line">   echo &quot;n=abc is $n&quot;</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   n=1 is 1</span><br><span class="line">   n=2 is 2</span><br><span class="line">   n=a is 1</span><br><span class="line">   n=b is 0</span><br><span class="line">   n=abc is 0</span><br><span class="line">   ```3. -x 将指定变量通过环境变量输出到后续命令</span><br><span class="line">4. -p 显示指定变量的属性和值</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   declare -i m=1;</span><br><span class="line">   declare -p m</span><br></pre></td></tr></table></figure><p>输出为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -i m=&quot;1&quot;</span><br></pre></td></tr></table></figure><h2 id="Bash中的数组变量"><a href="#Bash中的数组变量" class="headerlink" title="Bash中的数组变量"></a>Bash中的数组变量</h2><p>一个数组时包含多个值的变量，任何变量都可以作为一个数组使用，数组的大小没有限制，成员变量也不需要连续分配。数组的索引是从0开始。声明一个数组变量的语法如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">index必须是正数，或是一个值为正数的算术表达式</span></span><br><span class="line">arrayName[index]=value</span><br><span class="line">declare -a arrayName=(&#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27;)</span><br></pre></td></tr></table></figure><p>数组变量可以使用复合赋值格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrayName=(value1,value2,value3...valueN)</span><br></pre></td></tr></table></figure><p>引用数组中的某一项的值，必须时哟哦那个花括号，如果索引编号是‘@’或者’*’时，这些属性都会被应用到数组变量中。如果索引时不指定索引编号，则引用的数组第一项的值，即使用索引编号0.使用unset可以取消一个数组或数组的成员变量，如下所示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">取消数组变量array1的定义</span></span><br><span class="line">unset array1</span><br><span class="line"><span class="meta">#</span><span class="bash">取消数组成员变量2的定义</span></span><br><span class="line">unset array1[2]</span><br></pre></td></tr></table></figure><p><strong>备注：Bash的各种参数扩展也可以用于数组变量</strong><br>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=(1 2 3)</span><br><span class="line">echo &quot;$&#123;a[1]&#125;&quot;</span><br><span class="line">echo &quot;a is $&#123;a&#125;&quot;</span><br><span class="line">unset a[1]</span><br><span class="line">echo &quot;$&#123;a[1]&#125;&quot;</span><br><span class="line">for item in $&#123;a[*]&#125;</span><br><span class="line">do</span><br><span class="line">   echo $&#123;item&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">a=(1 2 3)</span><br><span class="line">echo &quot;$&#123;a[1]&#125;&quot;</span><br><span class="line">echo &quot;a is $&#123;a&#125;&quot;</span><br><span class="line">unset a[1]</span><br><span class="line">echo &quot;$&#123;a[1]&#125;&quot;</span><br><span class="line">for item in $&#123;a[*]&#125;</span><br><span class="line">do</span><br><span class="line">   echo $&#123;item&#125;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Shell变量</summary>
    
    
    
    
    <category term="Linux" scheme="http://tanqidong1992.github.io/tags/Linux/"/>
    
    <category term="知识梳理" scheme="http://tanqidong1992.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
    <category term="Shell" scheme="http://tanqidong1992.github.io/tags/Shell/"/>
    
    <category term="Shell变量" scheme="http://tanqidong1992.github.io/tags/Shell%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM编译器调优</title>
    <link href="http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/"/>
    <id>http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/</id>
    <published>2020-11-18T15:11:47.000Z</published>
    <updated>2021-10-12T07:34:24.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM编译器调优"><a href="#JVM编译器调优" class="headerlink" title="JVM编译器调优"></a>JVM编译器调优</h1><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>即时（Just-In-Time，JIT）编译器是Java虚拟机的核心。对JVM的性能影响最大的莫过于编译器，而选择编译器是运行Java程序的首要选择之一。幸运的是在绝大多数情况下，我们只需要对编译器做一些基本的调优。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机的CPU只能执行相对较少的特定的指令，这些指令称为汇编码或者二进制码，因此CPU执行的所有程序都必须翻译成这种指令。</p><ul><li>有像C++，Fortran这样的语言被称为编译型语言，因为它们的程序都已二进制形式交付,并且这种二进制中的汇编码是针对特定CPU的,只要是兼容的CPU，都可以执行相同的二进制代码</li><li>还有像PHP，Perl这样的解释型语言，只要机器上有相应的解释器，相同的程序可以在任何CPU上执行.</li></ul><p>每种类型的编程语言都各有长处和不足，解释型的编程语言具有良好的可移植性，相同的代码可以在任何有适当解释器的机器上运行，但它执行起来可能就慢，因为每次执行前都必须要先解释。</p><p>Java试图走一条中间路线，Java应用会被编译成一种理想化的汇编语言，然后该汇编语言可以用Java执行，这使得Java成为一门平台独立的解释型语言。</p><p>Java程序运行的是理想化的二进制代码，所以它能在代码执行时将其编译成平台特定的二进制代码，由于这个编译是在程序执行时进行的，因此称为”即时编译“（JIT）。</p><h3 id="热点编译"><a href="#热点编译" class="headerlink" title="热点编译"></a>热点编译</h3><p>对程序而言，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行有多快，这些关键代码段被称为应用的热点，代码执行的越多就被认为是越热。<br>因此JVM执行代码时只会编译热点代码，一般是经常执行的方法或者多次执行的循环体，这样才有意义。JVM执行特定的方法或者循环越多，它就越了解这段代码，使得JVM可以在编译时，做更多的优化,例如编译器和主内存优化。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li>Java的设计结合了脚本语言的平台独立性和编译型语言的本地性能。</li><li>Java文件被翻译成中间语言（Java字节码），然后运行时被JVM进一步编译成汇编语言。</li><li>字节码编译成汇编语言的过程中有大量的优化，极大地改善了性能。</li></ol><h2 id="调优入门"><a href="#调优入门" class="headerlink" title="调优入门"></a>调优入门</h2><h3 id="编译器类型"><a href="#编译器类型" class="headerlink" title="编译器类型"></a>编译器类型</h3><p>有两种JIT编译器：</p><ul><li>client,也被成为C1</li><li>server，也被成为C2</li></ul><h4 id="编译器标志"><a href="#编译器标志" class="headerlink" title="编译器标志"></a>编译器标志</h4><ul><li>标准的编译器标志：<br>  -client,-server,-d64</li><li>分层编译<br>  -XX:+TieredCompilation<br>  备注：分层编译必须启用server编译器，如下启动参数意味着关闭分层编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -client -XX:+TieredCompilation other_args</span><br></pre></td></tr></table></figure><p>两种编译器的主要差别是：</p><ul><li>client编译器比server编译器开启编译的时机要早。意味着在代码执行的开始阶段client编译器比server编译器要快(因为client编译的代码相对server编译器而言要多)。</li><li>server编译器在编译代码时可以更好的优化，最终server编译器生成的代码要比client编译器生成的代码要快。</li></ul><p>从用户的角度来说，权衡的取舍在于程序要运行多久，程序的启动时间有多重要。</p><p>分层编译：前期采用client编译，随着代码变热，由server编译器重新编译，分层编译从Java7开始引入,7u4版本开始可以发挥较好性能，默认关闭(-XX:+TieredCompilation为false),server编译器在编译代码时可以更好的优化，最终server编译器生成的代码要比client编译器生成的代码要快。Java8开始,分层编译默认启用。</p><h3 id="优化启动"><a href="#优化启动" class="headerlink" title="优化启动"></a>优化启动</h3><ul><li>如果应用的启动时间是首要的性能考量,那么client编译器就是最佳的选择.</li><li>分层编译的启动时间非常接近于client编译器所获得的启动时间.</li></ul><h3 id="优化批处理"><a href="#优化批处理" class="headerlink" title="优化批处理"></a>优化批处理</h3><ul><li>对于计算量固定的任务来说,应该选择执行实际任务最快的编译器.</li><li>分层编译是批处理任务合理的默认选择.</li></ul><h3 id="优化长时间运行的应用"><a href="#优化长时间运行的应用" class="headerlink" title="优化长时间运行的应用"></a>优化长时间运行的应用</h3><ul><li>对于长时间运行的应用来说,应该一直使用server编译器,最好配合分层编译.</li></ul><h2 id="Java和JIT编译器的版本"><a href="#Java和JIT编译器的版本" class="headerlink" title="Java和JIT编译器的版本"></a>Java和JIT编译器的版本</h2><h3 id="编译器一共有三个版本"><a href="#编译器一共有三个版本" class="headerlink" title="编译器一共有三个版本"></a>编译器一共有三个版本</h3><ul><li>32位client(-client)</li><li>32位server(-server)</li><li>64位server(-d64)</li></ul><h3 id="虚拟选择32位或者64位"><a href="#虚拟选择32位或者64位" class="headerlink" title="虚拟选择32位或者64位"></a>虚拟选择32位或者64位</h3><p>如果是32位的操作系统必须使用32位的JVM,如果是64位的操作系统,你可以选择32位或者64位的JVM,如果堆小于3G,32位的Java会更快一些,因为JVM内部的指针只有32位,操作32位指针的代价要少于64位指针,而且32位指针占用的内存也少.虽然有普通对象指针压缩技术,但是64位JVM占用内存仍然大于32位的JVM,因为它所用的本地代码还是64位寻址.</p><p>32位JVM最大的不足是最多只能用4GB内存,有一个非常特殊的案例:因为32位JVM无法使用64位寄存器,所以大量使用long或者double变量的程序在32位JVM上就会比较慢.</p><p>在32位JVM运行的程序,只要与32位寻址空间吻合,无论机器是32位还是64位,都比在类似配置的64位JVM运行时快5%到%20.</p><p><strong>在Java8中,所有JVM中默认的编译器为server编译器,并默认开启分层编译.Java8是最后一个Oracle官方提供32位jdk下载的版本,从Jdk9开始,Oracle官网不再提供32bit Jdk下载</strong></p><h2 id="编译器中级调优"><a href="#编译器中级调优" class="headerlink" title="编译器中级调优"></a>编译器中级调优</h2><h3 id="调优代码缓存"><a href="#调优代码缓存" class="headerlink" title="调优代码缓存"></a>调优代码缓存</h3><p>JVM编译代码时,会在代码缓存中保留编译之后的汇编语言指令集,代码缓存的大小固定,一旦充满,JVM就无法编译更多代码了.<br>这个问题在使用client编译器和启动分层编译时很常见,使用常规的server编译器时,只有少量的类会被编译,不太可能充满代码缓存.<br>执行以下命令查看默认的代码缓存大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep CodeCacheSize</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    uintx InitialCodeCacheSize                     = 2555904                                &#123;pd product&#125; &#123;default&#125;</span><br><span class="line">    uintx ReservedCodeCacheSize                    = 251658240                              &#123;pd product&#125; &#123;ergonomic&#125;</span><br><span class="line">```- -XX:InitialCodeCacheSize=N 用于指定代码缓存的初始大小.</span><br><span class="line">- -XX:ReservedCodeCacheSize=N 用户指定代码缓存的最大值.</span><br><span class="line"></span><br><span class="line">为了永远不超过空间而将代码缓存的最大值设得很大,这取决于目标机器有多少可用资源,例如代码缓存被设置为1GB,JVM会保留1GB的本地内存空间,虽然用的时候才会分配,但是它仍然会被保留,为了满足保留内存,你的机器必须有充足的虚拟内存.</span><br><span class="line"></span><br><span class="line">**备注: 保留内存是分配地址空间,已提交内存是分配内存(只有访问时,才会将分配实际的物理内存页)**</span><br><span class="line"></span><br><span class="line">代码缓存是一种有最大值的资源,它会影响JVM可运行的编译代码总量,分层编译很容易达到代码缓存默认配置的上限,使用分层编译时,应该监控代码缓存,必要时增加它的最大值.</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 编译阈值</span></span></span><br><span class="line"></span><br><span class="line">当代码执行的次数达到编译阈值后,编译器就可以获得足够的信息编译代码了.</span><br><span class="line">编译时基于两种JVM计数器:</span><br><span class="line">- 方法计数器</span><br><span class="line">- 方法中的循环回边计数器(回边实际可看作循环完成执行的次数)</span><br><span class="line"></span><br><span class="line">JVM执行某个方法时,会检查两种计数器总数,判断是否适合编译,如果合适,就进入编译队列,这种编译称为标准编译.</span><br><span class="line"></span><br><span class="line">如果循环比较长,或者所包含程序逻辑永远不退出,这个情况下JVM不等方法调用就会编译循环,所以循环每完成一次,回边计数器会被增加并被检测,如果循环的回边计数器超过阈值,那么这个循环(不是整个方法)就可以被编译,这种编译称为栈上替换(On-StackReplacement,OSR).</span><br><span class="line"></span><br><span class="line">标准编译由 -XX:CompileThreshold=N 标志触发,client的默认值为1500,server默认值为10000.这个标志的值等于回边计数器加上方法计数器的总和.</span><br><span class="line">运行以下命令查看默认值</span><br><span class="line">Linux下</span><br><span class="line"></span><br><span class="line">```shelll</span><br><span class="line">tqd@tqd-pc:/mnt/c/Users/tqd$ java -client -XX:+PrintFlagsFinal --version | grep CompileThreshold</span><br><span class="line">     intx CompileThreshold                         = 10000                                  &#123;pd product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure><p>Windows 下</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;CompileThreshold&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07</span><span class="literal">-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">     intx CompileThreshold                         = <span class="number">1500</span>                                   &#123;pd product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure><p>OSR编译的阈值为 OSR trigger = (CompileThreshold*(OnStackReplacePercentage - InterpreterProfilePercentage)/100)</p><p>所有编译器中的 -XX:InterpreterProfilePercentage=N 标志的默认值为33,client编译器中的-XX:OnStackReplacePercentage=N的默认值为933<br>server编译器中的-XX:OnStackReplacePercentage的默认值为140;</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;OnStackReplacePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07</span><span class="literal">-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">     intx OnStackReplacePercentage                 = <span class="number">933</span>                                    &#123;pd product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-server</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;OnStackReplacePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07</span><span class="literal">-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">     intx OnStackReplacePercentage                 = <span class="number">140</span>                                    &#123;pd product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-server</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;InterpreterProfilePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07</span><span class="literal">-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">     intx InterpreterProfilePercentage             = <span class="number">33</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;InterpreterProfilePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07</span><span class="literal">-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">     intx InterpreterProfilePercentage             = <span class="number">33</span>                                        &#123;product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure><p>client编译器与server编译器的性能有很大的差异,这些差异很大程度上取决于编译方法时所获得的信息.降低编译阈值,特别是对server编译器来说,可能会减少编译代码的优化.不过应用测试表明,事实上几乎没有差别,比如8000次和10000次调用差别微乎其微.</p><p>使用较低的配置主要原因如下</p><ul><li>节约一点应用热身的时间</li><li>使得某些原本可能不会被server编译器编译的方法得以编译</li></ul><p>每种计数器的值都会周期性减少(特别是JVM达到安全点时),计数器只是方法的最新热度的度量,执行不太频繁的代码永远不会编译,即便是永远运行的程序(相对于热,这些方法被称为温热).一般通过减少编译阀值来优化,这也是分层编译通常比单独的server编译器更快的原因之一.</p><p><strong>小结:当方法和执行循环达到某个阀值的时候,就会发生编译;改变阀值会导致代码提前或者推后编译;由于计数器会随时间而减少,以至于”温热”的方法可能永远都达不到编译的阈值(特别对于server编译器来说).</strong></p><h3 id="检测编译过程"><a href="#检测编译过程" class="headerlink" title="检测编译过程"></a>检测编译过程</h3><h4 id="PrintCompilation打印"><a href="#PrintCompilation打印" class="headerlink" title="PrintCompilation打印"></a>PrintCompilation打印</h4><p>启用标志: -XX:+PrintCompilation(默认为false)<br>开启PrintCompilation后,每编译一个方法就会打印一行被编译的内容信息,输出的信息在不同的Java发行版本有所不同,Java7中的标准化输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">timestamp compilation_id attributes (tiered_level) method_name size deopt</span><br><span class="line">```- timestamp:编译时间戳,相对于JVM启动的时间.</span><br><span class="line">- compilation_id:内部任务Id,通常这个数字只是单调增长,使用server编译器会乱序输出(多个编译线程).</span><br><span class="line">- attributes: 是一组5个字符长的串,表示编译状态,如果给定编译被赋予特定属性,就会打印一下字符串,否则打印空格,5个字符属性串可以同时出现多个:</span><br><span class="line">- % :编译为OSR.</span><br><span class="line">- s :方法是同步的.</span><br><span class="line">- ! :方法有异常处理器.</span><br><span class="line">- b :阻塞模式发生的编译.</span><br><span class="line">- n :为封装本地方法所发生的编译.</span><br><span class="line">    备注:前三个可以自解释,阻塞标志(b)在当前版本的Java中默认用于不会打印,表明编译不会发生在后台.n标志表明JVM生成了一些编译代码以便于调用本地方法.</span><br><span class="line">- tiered_level: 完成编译的级别.如不启用分层编译,这个字段为空.</span><br><span class="line">- method_name: 被编译方法的名称.</span><br><span class="line">- size: 编译代码的大小,这是java字节码的大小,不是编译后的代码的大小</span><br><span class="line">- deopt: 表明发生某种逆优化,通常是&quot;made not entrant&quot;或者&quot;made zombie&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">### jstat打印编译日志</span></span></span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">jstat -compiler [jvm pid]</span><br><span class="line">jstat -compiler [jvm pid] [interval]</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">打印进程号为5003的编译日志</span></span><br><span class="line">jstat -compiler 5003</span><br><span class="line"><span class="meta">#</span><span class="bash">每1000ms打印一次</span></span><br><span class="line">jstat -printcompilation 5003 1000</span><br></pre></td></tr></table></figure><p>有时候有如下输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp compile_id COMPILE SKIPPED: reason</span><br></pre></td></tr></table></figure><p>这行信息表明编译的给定方法有误,出现这种情况的原因有以下两种:</p><ul><li>代码缓存满了,可以通过ReservedCodeCacheSize标志增加</li><li>编译的同时加载类:编译类的时候发生修改,JVM之后会再次编译.</li></ul><p><strong>小结:观察代码如何被编译的最好方法是开启PrintCompilation;PrintCompilation开启后所输出的信息可用来确认编译是否和预期一样.</strong></p><h2 id="高级调优"><a href="#高级调优" class="headerlink" title="高级调优"></a>高级调优</h2><h3 id="编译线程"><a href="#编译线程" class="headerlink" title="编译线程"></a>编译线程</h3><p>当方法(或循环)适合编译时,就会进入到编译队列.队列由一个或者多个后台线程处理.<br>编译队列并不严格遵守先进先出原则:调用计数次数多的方法有更高的优先级.<br>当使用client编译器时,JVM会开启一个编译线程,使用server编译器时,则会开启两个这样的线程.当启用分层编译时,JVM默认开启多个client和server线程,线程数根据一个复杂的等式而定,包括目标平台CPU数取双对数后的数值.</p><p>编译器的线程数可以通过-XX:CICompilerCount=N标志来设置,这是JVM处理队列的线程总数;对分层编译而言,至少三分之一(至少一个)将用来处理client编译器队列,其余的线程(至少一个)用来处理server编译器队列.<br>另一个编译线程设定参数为-XX:+BackgroundCompilation标志,默认为true,编译队列的处理是异步执行,设置为false,当一个方法适合编译时,执行方法的代码会一直等待到它确实被编译之后才执行,用-Xbatch可以禁用后台编译.<br><strong>小结:放置在编译队列中的方法的编译会被异步执行;队列不是严格按照先进先出;队列中的热点方法会在其他方法之前编译,这是编译输出日志的ID为乱序的另一个原因.</strong></p><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>编译器所做的最重要的优化就是方法内联,遵循面向对象设计的良好代码通常都会包括一些需要通过getter(setter)访问的属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">return</span> x;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.x=x;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问属性的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p=<span class="keyword">new</span> Point();</span><br><span class="line">p.setX(p.getX()*<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p=<span class="keyword">new</span> Point();</span><br><span class="line">p.x=p.x*<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>内联是默认开启的可通过-XX:-Inline关闭,然而它对性能影响巨大,不幸的是,基本没法看JVM是如何内联(如果你从源码编译JVM,可以用-XX:+PrintInlining生成带调试信息的版本,这个参数会提供所有关于编译器如何进行内联决策的信息).</p><p>方法是否内联取决于它有多热以及它的大小,JVM依据内部计算来判断方法是否热点,是否是热点并不直接与任何调优参数相关,如果方法因调用频繁而可以内联,那么只有它的字节码小于325字节时(或-XX:MaxFreqInlineSize(FreqInlineSize)=N所设定的值)才会内联,否则,只有方法很小时,即小于35字节(或者-XX:MaxInlineSize=N所设定的值)时才会内联.</p><p><strong>小结:内联是编译器所能做的最有利的优化,特别是对属性封装良好的面向对象的代码来说;几乎用不着调节内联参数,且提倡这样做的建议往往忽略了常规内联与频繁调用内联之间的关系,当考察内联效应时,确保考虑这两种情况.</strong></p><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>JVM默认开启逃匿分析（-XX:+DoEscapeAnalysis,默认为true)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/$ java -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep DoEscapeAnalysis</span><br><span class="line">     bool DoEscapeAnalysis                         = true                                   &#123;C2 product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure><p>server编译器将会执行一些非常激进的优化措施,比如去掉不必要的同步锁，将没必要保存到内存的值，保存到寄存器，不需要分配的对象，仅追踪其部分字段，此类优化非常复杂。逃逸分析默认开启，极少情况下它会出错，在此类情况下关闭它会变得更快或更稳定。如果你发现这种行为，最好的应对方法就是简化相关代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span></span>&#123;</span><br><span class="line">     <span class="keyword">private</span> BigInteger factorial;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">          <span class="keyword">this</span>.n=n;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> BigInteger <span class="title">getFactorial</span><span class="params">()</span></span>&#123;</span><br><span class="line">          <span class="keyword">if</span>(factorial == <span class="keyword">null</span>)&#123;</span><br><span class="line">               <span class="comment">//没必要在内存中保留n，可以在寄存器这种保留该值</span></span><br><span class="line">               factorial = <span class="number">0</span>;<span class="comment">//计算n的阶乘，此处省略</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> factorial;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sample code</span></span><br><span class="line">List&lt;BigInteger&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">     <span class="comment">//实际上没必要分配factorial对象，只需要追踪其部分字段</span></span><br><span class="line">     Factorial factorial=<span class="keyword">new</span> Factorial(i);</span><br><span class="line">     <span class="comment">//此处getFactorial方法的同步锁库没必要获取，可能被优化掉</span></span><br><span class="line">     list.add(factorial.getFactorial())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>小结：逃逸分析是编译器做得最复杂的优化。此类优化常常会导致微基准测试失败；逃逸分析常常会给不正确的同步代码引入Bug</strong></p><h2 id="逆优化"><a href="#逆优化" class="headerlink" title="逆优化"></a>逆优化</h2><p>有两种逆优化的场景,代码状态分别为:</p><ul><li>made no entrant(代码被丢弃)</li><li>made zombie(产生僵尸代码)</li></ul><h3 id="代码被丢弃"><a href="#代码被丢弃" class="headerlink" title="代码被丢弃"></a>代码被丢弃</h3><p>导致代码被丢弃的原因共两种：</p><ul><li>逆优化陷阱。</li><li>分层编译。</li></ul><h4 id="逆优化陷阱"><a href="#逆优化陷阱" class="headerlink" title="逆优化陷阱"></a>逆优化陷阱</h4><p>考虑如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IService service;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">request</span><span class="params">(String log)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(log!=<span class="keyword">null</span> &amp;&amp; log.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">            service=A();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            service=B();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> service.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果开始有大量的请求log不为空，此时service实际时A类型，然后它将内联代码，进行优化，后续只有大量log为空的请求，之前编译器根据service类型做的假设将不成立了，之前的优化也失效了，产生逆优化陷阱(deoptimization trap),如果有跟多log不为空的请求，JVM会中止此部分代码编译，而开始新的编译。<br><strong>注意：OSR编译过的构造函数和标准编译过的方法都被标记成made no entrant，过一会，它们又被标记为made zombie.</strong><br>逆优化听起来不好，但是逆优化之后，如果代码再次被调用，又会重新编译，逆优化，除了进入陷阱的短暂时间，对于其他方面没有太大的影响。</p><h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>在分层编译中，代码首先由client编译器编译，然后由server编译器编译，当server编译器编译好代码后，JVM必须替换client编译器编译的代码，这些代码将被标记为废弃。这种“逆优化”实际使得代码运行更快。</p><h3 id="逆优化僵尸代码"><a href="#逆优化僵尸代码" class="headerlink" title="逆优化僵尸代码"></a>逆优化僵尸代码</h3><p>编译器日志显示产生了僵尸代码，即JVM已经回收了之前被丢弃的代码，<br>在上面的例子中，当log为空时A类编译的代码就被丢弃了，但是A类的对象未被回收，最终A类的对象全部被GC回收，回收后编译器就会注意到，这个类就适合标记为僵尸代码了。</p><p>从性能的角度来看这是好事，编译代码保存在固定大小的代码缓存中，如果发现僵尸代码，意味着有问题的代码可以从代码缓存中移除，腾出空间给其他被编译的代码</p><p>不足之处：如果代码被僵尸化后被再次加载并且重新编译，JVM需要重新编译和重新优化代码。但这种情况对应用的性能没有太大的影响。</p><p>小结:逆优化使得编译器可以回到之前版本的编译代码；先前的优化不再有效时，才会发生代码逆优化；代码逆优化，会对性能产生小而短暂的影响，新编译的代码会尽快地再次热身；分层编译时，之前被client编译器编译而现在由server编译器优化，就会发生逆优化。</p><h2 id="分层编译级别"><a href="#分层编译级别" class="headerlink" title="分层编译级别"></a>分层编译级别</h2><p>当使用分层编译时，编译日志中会输出代码所编译的级别。一共两种编译器，再加上解释器，client编译器有3种编辑级别，总计5种编译级别：</p><ul><li>0: 解释代码</li><li>1: 简单c1编译代码</li><li>2: 受限的c1编译代码</li><li>3: 完全c1编译代码</li><li>4: c2编译代码</li></ul><p>典型的编译路径 级别3 -&gt; 级别4；多数方法第一次被编译成级别3，当方法运行足够频繁，它会被编译成级别4.最常见的情况是： client编译器从获取了代码如何使用的信息进行优化时才开始编译。</p><p>如果server编译器队列满了，会从server队列中取出方法，以级别2进行编译，这个级别上，client编译器使用方法调用计数器和回边计数器（但不需要分析性能），编译更快，而方法在client编译器收集分析信息后被编译成级别3，最终server编译器队列不太忙时被编译成级别4.</p><p>如果client编译器队列全忙，原本排程在级别3编译的方法就既可以等待级别3编译，也适合进行级别4的编译。在这种情况下，方法编译会很快转到级别2，然后由级别2转到级别4。</p><p>那些不重要的方法可以从级别2或者级别3编译，但随后会因为它们的重要性没那么高而转为级别1。另外如果server编译器处于某些原因无法编译代码，也会转为级别1。</p><p>当然，代码在逆编译时会转为级别0-&gt;级别3-&gt;级别4编译时，性能可以达到最优。如果方法经常被编译成级别2并且还有多余的cpu周期，那么可以考虑增大编译器的线程数，从而减少server编译器队列的长度，如果没有额外的cpu周期，那么你只能减少应用的大小。</p><p><strong>小结：分层编译可以在两种编译器和5种级别之间进行；不建议人为更改级别;</strong></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>final关键字不会影响性能,即便曾经会，但也是太久以前了。</p><ol><li>不用担心小方法，它们很容易被内联。</li><li>需要编译的代码在编译队列中，队列中代码越多，程序达到最佳性能的时间越久。</li><li>代码缓存虽然可以调整，但它仍然是有限资源。</li><li>代码越简单，优化越多。分析反馈和逃逸分析使得代码更快，但复杂的循环结构和大方法限制它的有效性。</li><li>审视编译器做什么很重要。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc?redirectedfrom=MSDN">已提交内存与保留内存</a></li><li><a href="https://github.com/tanqidong1992/compilation-test">检测编译过程实验</a></li></ol>]]></content>
    
    
    <summary type="html">JVM编译器调优</summary>
    
    
    
    
    <category term="Java" scheme="http://tanqidong1992.github.io/tags/Java/"/>
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="JVM" scheme="http://tanqidong1992.github.io/tags/JVM/"/>
    
    <category term="性能调优" scheme="http://tanqidong1992.github.io/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/"/>
    
  </entry>
  
  <entry>
    <title>GraalVM安装与Native-Image体验</title>
    <link href="http://tanqidong1992.github.io/2020/10/12/2020/10/12/GraalVM%E5%AE%89%E8%A3%85/"/>
    <id>http://tanqidong1992.github.io/2020/10/12/2020/10/12/GraalVM%E5%AE%89%E8%A3%85/</id>
    <published>2020-10-12T15:11:47.000Z</published>
    <updated>2021-10-12T07:34:24.570Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GraalVM安装与Native-Image体验"><a href="#GraalVM安装与Native-Image体验" class="headerlink" title="GraalVM安装与Native-Image体验"></a>GraalVM安装与Native-Image体验</h1><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><p>Linux Mint 20 64bit</p><h2 id="GraalVM安装"><a href="#GraalVM安装" class="headerlink" title="GraalVM安装"></a>GraalVM安装</h2><h3 id="下载安装文件"><a href="#下载安装文件" class="headerlink" title="下载安装文件"></a>下载安装文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-20.2.0/graalvm-ce-java11-linux-amd64-20.2.0.tar.gz</span><br><span class="line">wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-20.2.0/llvm-toolchain-installable-java11-linux-amd64-20.2.0.jar</span><br><span class="line">wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-20.2.0/native-image-installable-svm-java11-linux-amd64-20.2.0.jar</span><br><span class="line">wget https://github.com/graalvm/graalvm-ce-builds/releases/download/vm-20.2.0/wasm-installable-svm-java11-linux-amd64-20.2.0.jar</span><br></pre></td></tr></table></figure><h3 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h3><h4 id="解压graal到安装位置"><a href="#解压graal到安装位置" class="headerlink" title="解压graal到安装位置"></a>解压graal到安装位置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xzf graalvm-ce-java11-linux-amd64-20.2.0.tar.gz -C $&#123;安装位置&#125;</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>系统环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sudo vim /et/profile</span></span><br><span class="line">export JAVA_HOME=$&#123;安装位置&#125;/graalvm-ce-java11-linux-amd64-20.2.0</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><p>用户环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">sudo vim ~/.bashrc</span></span><br><span class="line">export JAVA_HOME=$&#123;安装位置&#125;/graalvm-ce-java11-linux-amd64-20.2.0</span><br><span class="line">export PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;PATH&#125;</span><br></pre></td></tr></table></figure><h4 id="安装组件"><a href="#安装组件" class="headerlink" title="安装组件"></a>安装组件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gu -L install llvm-toolchain-installable-java11-linux-amd64-20.2.0.jar</span><br><span class="line">gu -L install native-image-installable-svm-java11-linux-amd64-20.2.0.jar</span><br><span class="line">gu -L install wasm-installable-svm-java11-linux-amd64-20.2.0.jar </span><br></pre></td></tr></table></figure><h4 id="运行gu-list可以看到已安装组件"><a href="#运行gu-list可以看到已安装组件" class="headerlink" title="运行gu list可以看到已安装组件"></a>运行gu list可以看到已安装组件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/data/me/blog-test$ gu list</span><br><span class="line">ComponentId              Version             Component name      Origin </span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">js                       20.2.0              Graal.js            </span><br><span class="line">graalvm                  20.2.0              GraalVM Core        </span><br><span class="line">llvm-toolchain           20.2.0              LLVM.org toolchain  </span><br><span class="line">native-image             20.2.0              Native Image        </span><br><span class="line">wasm                     20.2.0              GraalWasm   </span><br></pre></td></tr></table></figure><h3 id="Native-Image体验"><a href="#Native-Image体验" class="headerlink" title="Native-Image体验"></a>Native-Image体验</h3><h4 id="创建Maven工程"><a href="#创建Maven工程" class="headerlink" title="创建Maven工程"></a>创建Maven工程</h4><p>POM文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat pom.xml</span></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">&lt;groupId&gt;com.tqd.test&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;cli-test&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">&lt;name&gt;cli-test&lt;/name&gt;</span><br><span class="line">&lt;url&gt;http://maven.apache.org&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">&lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;info.picocli&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;picocli&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.18.14&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;info.picocli&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;picocli-codegen&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;com.hngd.tool&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;service-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;0.1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;jreDirectory&gt;/app/linux/jdk-11.0.8+10&lt;/jreDirectory&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;executions&gt;</span><br><span class="line">&lt;execution&gt;</span><br><span class="line">&lt;id&gt;package&lt;/id&gt;</span><br><span class="line">&lt;goals&gt;</span><br><span class="line">&lt;goal&gt;service-package&lt;/goal&gt;</span><br><span class="line">&lt;/goals&gt;</span><br><span class="line">&lt;/execution&gt;</span><br><span class="line">&lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">&lt;!-- annotationProcessorPaths requires maven-compiler-plugin version </span><br><span class="line">3.5 or higher --&gt;</span><br><span class="line">&lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;annotationProcessorPaths&gt;</span><br><span class="line">&lt;path&gt;</span><br><span class="line">&lt;groupId&gt;info.picocli&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;picocli-codegen&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.5.1&lt;/version&gt;</span><br><span class="line">&lt;/path&gt;</span><br><span class="line">&lt;/annotationProcessorPaths&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>Java文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat src/main/java/com/tqd/<span class="built_in">test</span>/App.java</span></span><br><span class="line">package com.tqd.test;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import picocli.CommandLine;</span><br><span class="line">import picocli.CommandLine.Parameters;</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main( String[] args )&#123;</span><br><span class="line">    Cli cli=new Cli();</span><br><span class="line">    new CommandLine(cli).parseArgs(args);</span><br><span class="line">        System.out.printf( &quot;Hello %s!\n&quot;,cli.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    @Data</span><br><span class="line">    public static class Cli&#123;</span><br><span class="line">    </span><br><span class="line">    @Parameters(paramLabel = &quot;name&quot;,description = &quot;the name of you&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构建脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">cat build-native-image.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">scriptFilePath=$(readlink -f &quot;$0&quot;)</span><br><span class="line">APP_BASE_DIR=$(dirname $&#123;scriptFilePath&#125;)</span><br><span class="line">CMD_LINE_ARGS=$@</span><br><span class="line"></span><br><span class="line">native-image \</span><br><span class="line">-classpath $&#123;APP_BASE_DIR&#125;/libs/picocli-4.5.1.jar:$&#123;APP_BASE_DIR&#125;/libs/picocli-codegen-4.5.1.jar:$&#123;APP_BASE_DIR&#125;/cli-test-0.0.1-SNAPSHOT.jar com.tqd.test.App hello</span><br></pre></td></tr></table></figure><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn package</span><br><span class="line">cp build-native-image.sh target/cli-test</span><br><span class="line">./build-native-image.sh</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./hello ttt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出: Hello ttt!</span></span><br><span class="line">docker run --rm -ti -v $(pwd)/hello:/hello ubuntu /hello ttt</span><br><span class="line"><span class="meta">#</span><span class="bash">输出: Hello ttt!</span></span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>构建native image时，如果jar中没有配置文件，那么构建出来的native image运行是需要Java运行时。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.graalvm.org/">Graalvm</a></li><li><a href="https://github.com/oracle/graal/blob/master/substratevm/Configuration.md">Graalvm Configuration</a></li><li><a href="https://picocli.info/">picocli</a></li><li><a href="https://github.com/remkop/picocli/tree/master/picocli-codegen#maven">picocli-codegen</a></li></ol>]]></content>
    
    
    <summary type="html">GraalVM安装与Native-Image体验</summary>
    
    
    
    
    <category term="Java" scheme="http://tanqidong1992.github.io/tags/Java/"/>
    
    <category term="GraalVM" scheme="http://tanqidong1992.github.io/tags/GraalVM/"/>
    
    <category term="NativeImage" scheme="http://tanqidong1992.github.io/tags/NativeImage/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优概述</title>
    <link href="http://tanqidong1992.github.io/2020/08/10/2020/08/10/JVM%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/"/>
    <id>http://tanqidong1992.github.io/2020/08/10/2020/08/10/JVM%E8%B0%83%E4%BC%98%E6%A6%82%E8%BF%B0/</id>
    <published>2020-08-10T15:11:47.000Z</published>
    <updated>2021-10-12T07:34:24.403Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM调优概述"><a href="#JVM调优概述" class="headerlink" title="JVM调优概述"></a>JVM调优概述</h1><h2 id="JVM调优标志"><a href="#JVM调优标志" class="headerlink" title="JVM调优标志"></a>JVM调优标志</h2><p>除极少数外，JVM主要接受两类调优标志：布尔标志，附带参数标志；</p><ul><li>布尔参数的语法为-XX:+FlagName表示开启，-XX:-FlagName表示关闭。</li><li>附带参数的语法为-XX:FlagName=something,将FlagName的值设置为something。</li></ul><p>每个标志都有它的默认值，我们可以执行以下命令查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal</span><br></pre></td></tr></table></figure><p>这些标志在Client以及Server类虚拟机上具有不同的默认值，现在讨论这个已经没有意义了，从JDK 9开始Oracle不再提供32位的JDK下载了。<br>备注：在Microsoft Windows上运行的任意32位JVM（无论cpu的核心数）以及单cpu的（不论是什么操作系统）运行的32位，都是Client类虚拟机。所有其他机器(包括64位虚拟机)都被认为是Server类虚拟机。</p><h2 id="全面的性能调优"><a href="#全面的性能调优" class="headerlink" title="全面的性能调优"></a>全面的性能调优</h2><h3 id="编写更好的算法"><a href="#编写更好的算法" class="headerlink" title="编写更好的算法"></a>编写更好的算法</h3><p>不言而喻.</p><h3 id="编写更少的代码"><a href="#编写更少的代码" class="headerlink" title="编写更少的代码"></a>编写更少的代码</h3><ul><li>要编译的代码越多，等待程序启动所消耗的时间越长。</li><li>要创建的对象越多，垃圾收集的工作量越大。</li><li>要分配的对象越多，GC的周期越长。</li><li>要从磁盘装载到JVM的类越多，程序启动所花费的时间越长。</li><li>要执行的代码越多，机器硬件缓存的效率越低。</li><li>执行的代码越多，花费的时间越长。</li></ul><h4 id="无法取胜的战争"><a href="#无法取胜的战争" class="headerlink" title="无法取胜的战争"></a>无法取胜的战争</h4><p>所有应用程序的性能随着时间,即新版本的发布而降低.但由于硬件的改善使得新程序的运行速度可以接受，所以不会有人注意到性能上的差异。</p><p>随着新特性的添加和新要求的采纳，程序会越来越大，越来越慢.这种现象我们总结为“积少成多”原则。随着功能的增加，性能测试很快就会检测到资源瓶颈。而性能调优小组可以修正主要的性能衰减。</p><h3 id="过早优化"><a href="#过早优化" class="headerlink" title="过早优化"></a>过早优化</h3><p>我们不能把大量的时间都耗费在那些小的性能改进上。最终我们应该编写清晰，直接，易读和易理解的代码，不能为了性能而过早的编写复杂的程序结构（算法和设计带来的）。那些真正的优化最好留到最后，等到性能分析表明这些措施有巨大收益的时候才进行。<br>备注：过早优化不包括已知的对性能不好的代码结构。</p><h3 id="其他：数据库很有可能是瓶颈"><a href="#其他：数据库很有可能是瓶颈" class="headerlink" title="其他：数据库很有可能是瓶颈"></a>其他：数据库很有可能是瓶颈</h3><p>如果我们开发的是独立运行的Java程序，性能就只与应用本身相关。一旦添加了外部资源（例如数据库），那么这两者的性能都很重要。在分布式环境中，比如Java EE服务器，负载均衡器，数据库，Java应用服务器的性能问题可能只是其中的很小一部分。</p><p>对于整个系统，我们需要采用结构化的方法针对系统的所有方面分析性能。CPU使用率，I/O延迟，系统整体的吞吐量都必须测量和分析。只有到那时，我们才能确定是那个组件导致了性能瓶颈。</p><h4 id="不只JVM有BUG和性能问题"><a href="#不只JVM有BUG和性能问题" class="headerlink" title="不只JVM有BUG和性能问题"></a>不只JVM有BUG和性能问题</h4><ul><li>运行环境中的任何部分都可能会引起性能问题，包括测试框架。</li><li>不要忽略初步分析，如果数据库是瓶颈，那么无论如何优化访问数据库的Java程序，都无助于整体性能，实际上可能适得其反。作为一般性原则，系统负载越大，系统性能越糟糕。如果更改Java应用使得它更有效，这只会增加已经过载的数据库的负载 ，整体性能实际反而会下降。导致的风险是，可能会得出错误的结论，即认为不应该改进JVM。</li></ul><p>增加系统某个组件的负载导致整个系统性能变慢，这一原则不仅适用于数据库.CPU密集型应用，或者越来越多的线程试图获取已经有线程等待的锁，还有一些其他的场景都适用这一原则</p><h3 id="常见的优化"><a href="#常见的优化" class="headerlink" title="常见的优化"></a>常见的优化</h3><p>一般而言，常用的用例场景才是性能优化真正应该关注的重点.</p><ul><li>借助性能分析来优化代码，重点关注性能分析中最耗时的操作。</li><li>利用奥卡姆剃刀原则诊断性能问题，性能问题最有可能的原因应该是最容易解释的：新代码比机器配置更可能引入性能问题，机器配置比JVM或者操作系统的bug更容易引入性能问题。</li><li>为应用中最常用的操作编写简单的算法。</li></ul><h2 id="总而言之"><a href="#总而言之" class="headerlink" title="总而言之"></a>总而言之</h2><p>多数情况下，JVM只占整体性能的一小部分。你需要对Java所在系统的环境进行整体系统调优，数据库和其他后台运行系统的性能的重要性不亚于JVM。此外，JVM与系统其他部分的交互对系统的影响也同样重要。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html">Oracale JDK下载地址汇总</a></li></ol>]]></content>
    
    
    <summary type="html">JVM调优概述</summary>
    
    
    
    
    <category term="Java" scheme="http://tanqidong1992.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="http://tanqidong1992.github.io/tags/JVM/"/>
    
    <category term="性能优化" scheme="http://tanqidong1992.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Spring与Mybatis是如何获取参数名称</title>
    <link href="http://tanqidong1992.github.io/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/"/>
    <id>http://tanqidong1992.github.io/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/</id>
    <published>2020-08-01T06:11:47.000Z</published>
    <updated>2021-10-12T07:34:24.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近遇到Mybatis Mapper接口类中成员函数不加@Param注解修饰,导致程序运行出错(xml文件中#{parameterName}引用出错),但Spring Controller层的成员函数却工作正常.今日有暇.遂分析之.</p><h2 id="Mybatis分析"><a href="#Mybatis分析" class="headerlink" title="Mybatis分析"></a>Mybatis分析</h2><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>定位到Mybatis Mapper类成员函数参数名称解析类<br>org.apache.ibatis.reflection.ParamNameResolver</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.useActualParamName = config.isUseActualParamName();</span><br><span class="line">  <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">  <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">  <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">  <span class="comment">// get names from @Param annotations</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">      <span class="comment">// skip special parameters</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String name = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">        hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">        name = ((Param) annotation).value();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// @Param was not specified.</span></span><br><span class="line">      <span class="keyword">if</span> (useActualParamName) &#123;</span><br><span class="line">        name = getActualParamName(method, paramIndex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// use the parameter index as the name (&quot;0&quot;, &quot;1&quot;, ...)</span></span><br><span class="line">        <span class="comment">// gcode issue #71</span></span><br><span class="line">        name = String.valueOf(map.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    map.put(paramIndex, name);</span><br><span class="line">  &#125;</span><br><span class="line">  names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以清楚的看到如果没有找到@Param注解,那么就会调用getActualParamName方法获取参数实际的名称(<strong>备注:配置项useActualParamName默认是true</strong>).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getActualParamName</span><span class="params">(Method method, <span class="keyword">int</span> paramIndex)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ParamNameUtil.getParamNames(method).get(paramIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看方法org.apache.ibatis.reflection.ParamNameUtil.getParamNames(Method)的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamNameUtil</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParamNames</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getParameterNames(method);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParamNames</span><span class="params">(Constructor&lt;?&gt; constructor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getParameterNames(constructor);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParameterNames</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(executable.getParameters()).map(Parameter::getName).collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ParamNameUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以确定,参数名称来自java.lang.reflect.Parameter.getName()的返回,根据这个函数的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the name of the parameter.  If the parameter&#x27;s name is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #isNamePresent() present&#125;, then this method returns</span></span><br><span class="line"><span class="comment"> * the name provided by the class file. Otherwise, this method</span></span><br><span class="line"><span class="comment"> * synthesizes a name of the form argN, where N is the index of</span></span><br><span class="line"><span class="comment"> * the parameter in the descriptor of the method which declares</span></span><br><span class="line"><span class="comment"> * the parameter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The name of the parameter, either provided by the class</span></span><br><span class="line"><span class="comment"> *         file or synthesized if the class file does not provide</span></span><br><span class="line"><span class="comment"> *         a name.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>如果class文件中没有提供参数名字,那么返回的将是arg0,arg1…argN,如果class文件中含有参数名字,那么可以直接返回参数的名字<br>在将参数命名化是通过调用了以下函数来实现的.<br>org.apache.ibatis.reflection.ParamNameResolver.getNamedParams(Object[])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * &lt;p&gt;</span></span><br><span class="line"><span class="comment">  * A single non-special parameter is returned without a name.</span></span><br><span class="line"><span class="comment">  * Multiple parameters are named using the naming rule.</span></span><br><span class="line"><span class="comment">  * In addition to the default names, this method also adds the generic names (param1, param2,</span></span><br><span class="line"><span class="comment">  * ...).</span></span><br><span class="line"><span class="comment">  * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">  *          the args</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the named params</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">     Object value = args[names.firstKey()];</span><br><span class="line">     <span class="keyword">return</span> wrapToMapIfCollection(value, useActualParamName ? names.get(<span class="number">0</span>) : <span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">     <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">       param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">       <span class="comment">// add generic param names (param1, param2, ...)</span></span><br><span class="line">       <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + (i + <span class="number">1</span>);</span><br><span class="line">       <span class="comment">// ensure not to overwrite parameter named with @Param</span></span><br><span class="line">       <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">         param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">       &#125;</span><br><span class="line">       i++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> param;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Wrap to a &#123;<span class="doctag">@link</span> ParamMap&#125; if object is &#123;<span class="doctag">@link</span> Collection&#125; or array.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> object a parameter object</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> actualParamName an actual parameter name</span></span><br><span class="line"><span class="comment">  *                        (If specify a name, set an object to &#123;<span class="doctag">@link</span> ParamMap&#125; with specified name)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> a &#123;<span class="doctag">@link</span> ParamMap&#125;</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@since</span> 3.5.5</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">wrapToMapIfCollection</span><span class="params">(Object object, String actualParamName)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">     ParamMap&lt;Object&gt; map = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;collection&quot;</span>, object);</span><br><span class="line">     <span class="keyword">if</span> (object <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">       map.put(<span class="string">&quot;list&quot;</span>, object);</span><br><span class="line">     &#125;</span><br><span class="line">     Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object != <span class="keyword">null</span> &amp;&amp; object.getClass().isArray()) &#123;</span><br><span class="line">     ParamMap&lt;Object&gt; map = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">     map.put(<span class="string">&quot;array&quot;</span>, object);</span><br><span class="line">     Optional.ofNullable(actualParamName).ifPresent(name -&gt; map.put(name, object));</span><br><span class="line">     <span class="keyword">return</span> map;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> object;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以看出如果成员函数只有一个参数并且没有被@Param注解修饰,那么就没有命名的必要了,如果有多个参数,那么会将参数命名为前面获取的参数名称以及一个paramN的别名.<br>我们再看参数注入的函数:com.baomidou.mybatisplus.core.MybatisDefaultParameterHandler.setParameters(PreparedStatement)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParameters</span><span class="params">(PreparedStatement ps)</span> </span>&#123;</span><br><span class="line">       ErrorContext.instance().activity(<span class="string">&quot;setting parameters&quot;</span>).object(mappedStatement.getParameterMap().getId());</span><br><span class="line">       List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">       <span class="keyword">if</span> (parameterMappings != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">               ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">               <span class="keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                   Object value;</span><br><span class="line">                   String propertyName = parameterMapping.getProperty();</span><br><span class="line">                   <span class="keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123; <span class="comment">// issue #448 ask first for additional params</span></span><br><span class="line">                       value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parameterObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       value = <span class="keyword">null</span>;</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                       value = parameterObject;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">                       value = metaObject.getValue(propertyName);</span><br><span class="line">                   &#125;</span><br><span class="line">                   TypeHandler typeHandler = parameterMapping.getTypeHandler();</span><br><span class="line">                   JdbcType jdbcType = parameterMapping.getJdbcType();</span><br><span class="line">                   <span class="keyword">if</span> (value == <span class="keyword">null</span> &amp;&amp; jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       jdbcType = configuration.getJdbcTypeForNull();</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">try</span> &#123;</span><br><span class="line">                       typeHandler.setParameter(ps, i + <span class="number">1</span>, value, jdbcType);</span><br><span class="line">                   &#125; <span class="keyword">catch</span> (TypeException | SQLException e) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">&quot;Could not set parameters for mapping: &quot;</span> + parameterMapping + <span class="string">&quot;. Cause: &quot;</span> + e, e);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>对于单个参数,基本类型会进入以下这个条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">    value = parameterObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于单个参数,typeHandlerRegistry无法解析的复杂类型会进入最后一个条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    MetaObject metaObject = configuration.newMetaObject(parameterObject);</span><br><span class="line">    value = metaObject.getValue(propertyName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看org.apache.ibatis.reflection.MetaObject.getValue(String)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>基本可以看出单个复杂类型的参数可以根据field名称引用参数的原因了.<br><strong>备注:如果是多个复杂类型,那么最外面是一个Map.</strong><br>综上所述我们得出以下结论</p><ol><li>如果Mapper类的成员函数,只有单个参数并且没有@Param注解修饰的情况下:</li></ol><ul><li><p>如果参数的类型是基本类型或者自定义处理类型(typeHandlerRegistry),那么参数会直接注入到statement.</p></li><li><p>如果是参数的类型是复杂类型并且没有自定义处理器,可以用参数的成员变量名称来引用参数的成员变量.</p></li></ul><ol start="2"><li>如果Mapper类的成员函数,有多个参数并且没有@Param注解修饰的情况下:</li></ol><ul><li><p>如果编译参数加了-parameters,我们可以通过参数名字,或者 param1,param2…paramN的形式来引用相应位置的参数.</p></li><li><p>如果编译参数未加-parameter,我们可以用通过arg0,arg1…argN或者 param1,param2…paramN+1的方式引用相应位置的参数.</p></li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>Mybatsi的Mapper接口参数名称获取途径(优先级从上到下递减)</p><ul><li>@Param注解</li><li>Java标准反射API(具体名称取决于parameter编译参数是否开启)</li></ul><p>当然Mybatis为Mapper类的接口参数提供默认的别名param1,param2..paramN,对于单个集合或者数组类型的参数提供list,map,array作为名称.</p><h2 id="SpringMVC分析"><a href="#SpringMVC分析" class="headerlink" title="SpringMVC分析"></a>SpringMVC分析</h2><h3 id="源码以及调试分析"><a href="#源码以及调试分析" class="headerlink" title="源码以及调试分析"></a>源码以及调试分析</h3><p>我们编写简单的测试程序,<br>Hello.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="meta">@GetMapping(&quot;/sum&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sum</span><span class="params">(Integer a,Integer b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;The sum of a and b is&quot;</span>+(a+b);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloInterface.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloInterface</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们定位到获取参数名称的代码,加上断点开始调试<br>org.springframework.core.MethodParameter.getParameterName()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameterName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.parameterIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">ParameterNameDiscoverer discoverer = <span class="keyword">this</span>.parameterNameDiscoverer;</span><br><span class="line"><span class="keyword">if</span> (discoverer != <span class="keyword">null</span>) &#123;</span><br><span class="line">String[] parameterNames = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.executable <span class="keyword">instanceof</span> Method) &#123;</span><br><span class="line">parameterNames = discoverer.getParameterNames((Method) <span class="keyword">this</span>.executable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.executable <span class="keyword">instanceof</span> Constructor) &#123;</span><br><span class="line">parameterNames = discoverer.getParameterNames((Constructor&lt;?&gt;) <span class="keyword">this</span>.executable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (parameterNames != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.parameterName = parameterNames[<span class="keyword">this</span>.parameterIndex];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.parameterNameDiscoverer = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.parameterName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>org.springframework.core.PrioritizedParameterNameDiscoverer.getParameterNames</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> String[] getParameterNames(Method method) &#123;</span><br><span class="line"><span class="keyword">for</span> (ParameterNameDiscoverer pnd : <span class="keyword">this</span>.parameterNameDiscoverers) &#123;</span><br><span class="line">String[] result = pnd.getParameterNames(method);</span><br><span class="line"><span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过调试发现,一共有两个参数名称发现器StandardReflectionParameterNameDiscoverer,LocalVariableTableParameterNameDiscoverer,根据类命名不难得出,一个是通过标准的Java反射API获取参数名称 ,另一个是根据局部变量表获取参数名称.<br><img src="/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/springmvc-parameter-name-descovery.png"></p><ol><li>通过标准的Java反射API获取参数名称,至少需要Java 8+,这个途径需要启用-parameters编译参数.</li><li>通过局部变量表获取参数名称.这个需要读取class文件分析出局部变量表,这个途径需要启用</li></ol><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><h4 id="编译参数"><a href="#编译参数" class="headerlink" title="编译参数"></a>编译参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">javac --help</span><br><span class="line">-g                           生成所有调试信息</span><br><span class="line">-g:&#123;lines,vars,source&#125;       只生成某些调试信息</span><br><span class="line">-parameters                  生成元数据以用于方法参数的反射</span><br></pre></td></tr></table></figure><p>在Maven工程中,我们开启-g,-parameters参数后反编译代码可以看到参数名称,局部变量列表</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">debug</span>&gt;</span>true<span class="tag">&lt;/<span class="name">debug</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parameters</span>&gt;</span>true<span class="tag">&lt;/<span class="name">parameters</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">``````powershell</span><br><span class="line">PS W:\study\spring-learn\argument-name-resolver-test\target\classes\com\tqd\learn&gt; javap -v .\Hello.class</span><br><span class="line">Classfile /W:/study/spring-learn/argument-name-resolver-test/target/classes/com/tqd/learn/Hello.class</span><br><span class="line">  Last modified 2020年8月1日; size 955 bytes</span><br><span class="line">  MD5 checksum b8b6968ae7560c4c1ea300dd345e6f6b</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class com.tqd.learn.Hello</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #9                          // com/tqd/learn/Hello</span><br><span class="line">  super_class: #10                        // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 2</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #10.#31        // java/lang/Object.&quot;<span class="tag">&lt;<span class="name">init</span>&gt;</span>&quot;:()V</span><br><span class="line">   #2 = Class              #32            // java/lang/StringBuilder</span><br><span class="line">   #3 = Methodref          #2.#31         // java/lang/StringBuilder.&quot;<span class="tag">&lt;<span class="name">init</span>&gt;</span>&quot;:()V</span><br><span class="line">   #4 = String             #33            // The sum of a and b is</span><br><span class="line">   #5 = Methodref          #2.#34         // java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">   #6 = Methodref          #35.#36        // java/lang/Integer.intValue:()I</span><br><span class="line">   #7 = Methodref          #2.#37         // java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">   #8 = Methodref          #2.#38         // java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">   #9 = Class              #39            // com/tqd/learn/Hello</span><br><span class="line">  #10 = Class              #40            // java/lang/Object</span><br><span class="line">  #11 = Utf8               <span class="tag">&lt;<span class="name">init</span>&gt;</span></span><br><span class="line">  #12 = Utf8               ()V</span><br><span class="line">  #13 = Utf8               Code</span><br><span class="line">  #14 = Utf8               LineNumberTable</span><br><span class="line">  #15 = Utf8               LocalVariableTable</span><br><span class="line">  #16 = Utf8               this</span><br><span class="line">  #17 = Utf8               Lcom/tqd/learn/Hello;</span><br><span class="line">  #18 = Utf8               sum</span><br><span class="line">  #19 = Utf8               (Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/String;</span><br><span class="line">  #20 = Utf8               a</span><br><span class="line">  #21 = Utf8               Ljava/lang/Integer;</span><br><span class="line">  #22 = Utf8               b</span><br><span class="line">  #23 = Utf8               MethodParameters</span><br><span class="line">  #24 = Utf8               RuntimeVisibleAnnotations</span><br><span class="line">  #25 = Utf8               Lorg/springframework/web/bind/annotation/GetMapping;</span><br><span class="line">  #26 = Utf8               value</span><br><span class="line">  #27 = Utf8               /sum</span><br><span class="line">  #28 = Utf8               SourceFile</span><br><span class="line">  #29 = Utf8               Hello.java</span><br><span class="line">  #30 = Utf8               Lorg/springframework/web/bind/annotation/RestController;</span><br><span class="line">  #31 = NameAndType        #11:#12        // &quot;<span class="tag">&lt;<span class="name">init</span>&gt;</span>&quot;:()V</span><br><span class="line">  #32 = Utf8               java/lang/StringBuilder</span><br><span class="line">  #33 = Utf8               The sum of a and b is</span><br><span class="line">  #34 = NameAndType        #41:#42        // append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #35 = Class              #43            // java/lang/Integer</span><br><span class="line">  #36 = NameAndType        #44:#45        // intValue:()I</span><br><span class="line">  #37 = NameAndType        #41:#46        // append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">  #38 = NameAndType        #47:#48        // toString:()Ljava/lang/String;</span><br><span class="line">  #39 = Utf8               com/tqd/learn/Hello</span><br><span class="line">  #40 = Utf8               java/lang/Object</span><br><span class="line">  #41 = Utf8               append</span><br><span class="line">  #42 = Utf8               (Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">  #43 = Utf8               java/lang/Integer</span><br><span class="line">  #44 = Utf8               intValue</span><br><span class="line">  #45 = Utf8               ()I</span><br><span class="line">  #46 = Utf8               (I)Ljava/lang/StringBuilder;</span><br><span class="line">  #47 = Utf8               toString</span><br><span class="line">  #48 = Utf8               ()Ljava/lang/String;</span><br><span class="line">&#123;</span><br><span class="line">  public com.tqd.learn.Hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;<span class="tag">&lt;<span class="name">init</span>&gt;</span>&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/tqd/learn/Hello;</span><br><span class="line">  public java.lang.String sum(java.lang.Integer, java.lang.Integer);</span><br><span class="line">    descriptor: (Ljava/lang/Integer;Ljava/lang/Integer;)Ljava/lang/String;</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=3</span><br><span class="line">         0: new           #2                  // class java/lang/StringBuilder</span><br><span class="line">         3: dup</span><br><span class="line">         4: invokespecial #3                  // Method java/lang/StringBuilder.&quot;<span class="tag">&lt;<span class="name">init</span>&gt;</span>&quot;:()V</span><br><span class="line">         7: ldc           #4                  // String The sum of a and b is</span><br><span class="line">         9: invokevirtual #5                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">        12: aload_1</span><br><span class="line">        13: invokevirtual #6                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">        16: aload_2</span><br><span class="line">        17: invokevirtual #6                  // Method java/lang/Integer.intValue:()I</span><br><span class="line">        20: iadd</span><br><span class="line">        21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">        24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">        27: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      28     0  this   Lcom/tqd/learn/Hello;</span><br><span class="line">            0      28     1     a   Ljava/lang/Integer;</span><br><span class="line">            0      28     2     b   Ljava/lang/Integer;</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      a</span><br><span class="line">      b</span><br><span class="line">    RuntimeVisibleAnnotations:</span><br><span class="line">      0: #25(#26=[s#27])</span><br><span class="line">        org.springframework.web.bind.annotation.GetMapping(</span><br><span class="line">          value=[&quot;/sum&quot;]</span><br><span class="line">        )</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br><span class="line">RuntimeVisibleAnnotations:</span><br><span class="line">  0: #30()</span><br><span class="line">    org.springframework.web.bind.annotation.RestController</span><br><span class="line">PS W:\study\spring-learn\argument-name-resolver-test\target\classes\com\tqd\learn&gt; javap -v .\HelloInterface.class</span><br><span class="line">Classfile /W:/study/spring-learn/argument-name-resolver-test/target/classes/com/tqd/learn/HelloInterface.class</span><br><span class="line">  Last modified 2020年8月1日; size 187 bytes</span><br><span class="line">  MD5 checksum d3818444e73741cd2525e3edff9c767e</span><br><span class="line">  Compiled from &quot;HelloInterface.java&quot;</span><br><span class="line">public interface com.tqd.learn.HelloInterface</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0601) ACC_PUBLIC, ACC_INTERFACE, ACC_ABSTRACT</span><br><span class="line">  this_class: #1                          // com/tqd/learn/HelloInterface</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 1, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Class              #10            // com/tqd/learn/HelloInterface</span><br><span class="line">   #2 = Class              #11            // java/lang/Object</span><br><span class="line">   #3 = Utf8               sum</span><br><span class="line">   #4 = Utf8               (II)I</span><br><span class="line">   #5 = Utf8               MethodParameters</span><br><span class="line">   #6 = Utf8               a</span><br><span class="line">   #7 = Utf8               b</span><br><span class="line">   #8 = Utf8               SourceFile</span><br><span class="line">   #9 = Utf8               HelloInterface.java</span><br><span class="line">  #10 = Utf8               com/tqd/learn/HelloInterface</span><br><span class="line">  #11 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public abstract int sum(int, int);</span><br><span class="line">    descriptor: (II)I</span><br><span class="line">    flags: (0x0401) ACC_PUBLIC, ACC_ABSTRACT</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      a</span><br><span class="line">      b</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;HelloInterface.java&quot;</span><br></pre></td></tr></table></figure><p>Eclipse,Maven默认启用了-g编译参数,但是没有启用-parameters编译参数<br><img src="/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/eclipse-compiler-config.png"><br><img src="/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/maven-compiler-debug.png"><br><img src="/2020/08/01/2020/08/01/Spring%E4%B8%8EMybatis%E5%A6%82%E4%BD%95%E8%A7%A3%E6%9E%90%E5%8F%82%E6%95%B0%E5%90%8D%E7%A7%B0/maven-compiler-parameter.png"></p><h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>SpringMVC Controller接口函数的参数名称获取途径(优先级从上到下递减)</p><ul><li><p>注解(例如@RequestParam)</p></li><li><p>Java反射API(如果-parameter编译参数开启)</p></li><li><p>局部变量表(如果-g编译参数开启)</p></li></ul><h2 id="Mybatis与SpringMVC差异化的原因"><a href="#Mybatis与SpringMVC差异化的原因" class="headerlink" title="Mybatis与SpringMVC差异化的原因"></a>Mybatis与SpringMVC差异化的原因</h2><ul><li>获取参数名称途径不同.<br>  首先Mybatis是基于Java标准反射API获取参数名称以及默认参数名称,而Spring是基于Java标准反射API以及局部变量列表获取参数名称.默认情况下Maven以及Eclipse都未启用-parameters编译参数.这个时候Mybatis的实现妥协了Parameter::getName</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getParameterNames</span><span class="params">(Executable executable)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Arrays.stream(executable.getParameters()).map(Parameter::getName).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Spring</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.springframework.core.StandardReflectionParameterNameDiscoverer.getParameterNames(Parameter[])</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> String[] getParameterNames(Parameter[] parameters) &#123;</span><br><span class="line">String[] parameterNames = <span class="keyword">new</span> String[parameters.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameters.length; i++) &#123;</span><br><span class="line">Parameter param = parameters[i];</span><br><span class="line"><span class="keyword">if</span> (!param.isNamePresent()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">parameterNames[i] = param.getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parameterNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然Spring在未通过反射API获取参数名称的情况下,会尝试通过局部变量表去获取变量的名称.如果局部变量表中的参数名称信息不存在,那么Spring将无法正常工作.</p><ul><li><p>Mybatis的Mapper是个接口类,没有具体实现,不存在局部变量表,只能通过标准的反射API获取参数名称.</p></li><li><p>Maven默认启用了-g编译参数,而未启用-parameters编译参数.</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然Mybatis与SpringMVC获取函数参数名称有一些差异,但是基本都是先通过注解,然后再通过其他手段获取到函数的参数名称.这些其他手段都依赖于外部的编译配置.我们为了编写出健壮的程序,还是用注解把参数的名称写上吧.</p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="http://maven.apache.org/plugins/maven-compiler-plugin/compile-mojo.html">maven-compiler-plugin</a></li><li>局部变量表<br> 局部 变 量表（ Local Variable Table） 是一 组 变量 值 存储 空间， 用于 存放 方法 参数 和 方法 内部 定义 的 局部 变量。 在 Java 程序 编译 为 Class 文件 时， 就在 方法 的 Code 属性 的 max_ locals 数据项 中 确 定了 该 方法 所需 要 分配 的 局部 变 量表 的 最大 容量。<br> 在 方法 执行 时， 虚拟 机 是 使用 局部 变量 表 完成 参 数值 到 参数 变量 列表 的 传递 过程 的， 如果 执 行的 是 实例 方法（ 非 static 的 方法）， 那 局部 变量 表中 第 0 位 索引 的 Slot 默认 是 用于 传递 方法 所属 对象 实例 的 引用， 在 方法 中 可以 通过 关键字” this” 来访 问到 这个 隐含 的 参数。 其余 参数 则 按照 参数 表 顺序 排列， 占用 从 1 开始 的 局部 变量 Slot， 参数 表 分配 完毕 后， 再 根据 方法 体内 部 定义 的 变量 顺序 和 作用域 分配 其余 的 Slot。<br> 周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版） (原创精品系列) (Kindle 位置 4216-4219). 机械工业出版社. Kindle 版本.</li></ol>]]></content>
    
    
    <summary type="html">Spring Controller类接口参数名称,Mybatis Mapper接口类,参数名称的获取</summary>
    
    
    
    
    <category term="Java" scheme="http://tanqidong1992.github.io/tags/Java/"/>
    
    <category term="Mybatis" scheme="http://tanqidong1992.github.io/tags/Mybatis/"/>
    
    <category term="SpringMVC" scheme="http://tanqidong1992.github.io/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>Spring Framework概述</title>
    <link href="http://tanqidong1992.github.io/2020/07/07/2020/07/SpringFramework%E5%A4%A7%E7%BA%B2%E5%AD%A6%E4%B9%A0/"/>
    <id>http://tanqidong1992.github.io/2020/07/07/2020/07/SpringFramework%E5%A4%A7%E7%BA%B2%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-07T12:29:47.000Z</published>
    <updated>2021-10-12T07:34:24.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知不觉自己用Spring框架已近五年了,前期有过对Spring的一些学习,但都不是系统的.最近经常跟一些面试者聊,有时候自己很心虚,一些知识点阐述的不够自信,近期打算好好地梳理一下过去的知识.</p><h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>Spring使得创建企业级Java应用变得更加容易,它提供了在企业环境中使用Java语言,你所需要的一切,包括Groovy,Kotlin语言支持,创建各种架构应用的灵活性.</p><p>从Spring Framework 5开始, Spring最小需要JDK 8+ (Java SE 8+) 并为JDK 11提供开箱即用支持. 建议Java SE 8 update 60作为最低的补丁版本.</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring一词在不同的语境中有不同的含义.它可以用来表示Spring Framework这个框架,随着时间的过去,一些其他的项目(基于Spring Framework)不断产生,Spring更多时候表示整个Spring家族项目集合.</p><p>Spring Framework已经被模块化了,应用可以选择自己需要的模块.这些模块的核心为核心容器模块,它包括了配置模型,依赖注入机制.Spring Framework还为其他的应用架构提供了一些基础功能支持,比如消息,事务性数据和持久性,Web(The Servlet-based Spring MVC Web Framework,The Spring WebFlux reactive web framework)</p><p>Spring Framework Jars支持Java9模块(Jigsaw)路径部署.对于启用了Jigsaw的应用程序,Spring Framework 5的Jar的模块名称命名规则为:artifact中的’-‘替换为’.’,例如spring-context的模块名称为spring.context.</p><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>由于Java EE规范的复杂,Spring自2003年诞生.Spring实际上是Java EE的补充.他并没有拥抱整个Java EE平台的规范,而是有选择地实现其中一些单独地规范,如下:</p><ul><li>Servlet API (<a href="https://jcp.org/en/jsr/detail?id=340">JSR 340</a>)</li><li>WebSocket API (<a href="https://www.jcp.org/en/jsr/detail?id=356">JSR 356</a>)</li><li>Concurrency Utilities (<a href="https://www.jcp.org/en/jsr/detail?id=236">JSR 236</a>)</li><li>JSON Binding API (<a href="https://jcp.org/en/jsr/detail?id=367">JSR 367</a>)</li><li>Bean Validation (<a href="https://jcp.org/en/jsr/detail?id=303">JSR 303</a>)</li><li>JPA (<a href="https://jcp.org/en/jsr/detail?id=338">JSR 338</a>)</li><li>JMS (<a href="https://jcp.org/en/jsr/detail?id=914">JSR 914</a>)</li><li>as well as JTA/JCA setups for transaction coordination, if necessary.<br>  除了上述之外,Spring也支持Dependency Injection (<a href="https://www.jcp.org/en/jsr/detail?id=330">JSR 330</a>) 和Common Annotations (<a href="https://jcp.org/en/jsr/detail?id=250">JSR 250</a>) 规范,供开发者选择,以替换Spring Framework提供地特定地机制.</li></ul><p>Spring Framework 5.0最小支持Java EE 7,同时也为Java EE 8提供了开箱即用的便利.这使得Spring完全支持Tomcat 8 and 9, WebSphere 9, JBoss EAP 7.</p><p>随着时间的过去,Java EE在软件开发的角色已经发生变革了.过去,基于Java EE或Spring的应用程序被创建需要部署到一个应用服务器中.而如今,在Spring Boot的帮助下,应用程序在Devops,云友好的方式下被创建.内置Servlet容器,微小的改动.从Spring Framework 5开始,一个基于WebFlux的应用甚至可以不直接使用Servlet API以及可以在不基于Servlet容器的服务上运行(比如Netty).</p><p>Spring将继续创新改革,除了Spring Framework外,更多的项目被创建,比如Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch.</p><h2 id="设计哲学"><a href="#设计哲学" class="headerlink" title="设计哲学"></a>设计哲学</h2><ul><li>在(应用的)每一层都提供选择,Spring让你的设计可以尽可能地延后.比如你可以不改动代码(修改配置)的情况下更换持久层的实现.</li><li>容纳不同的观点.Spring不固执己见.它支持不同场景应用的广泛需求.</li><li>保持强大的向后兼容性.Spring的发展经过了精心的管理,在版本之间几乎没有破坏性的更改.Spring小心的挑选JDk版本以及第三方库,以促进基于Spring的应用程序或者库的可维护性.</li><li>关心API设计.Spring团队通入大量的思想和时间来制作直观的API,这些API可以跨越多个版本,常年使用.</li><li>为代码质量设定高标准.Spring Framework非常强调有意义的,当前的.准确的javadoc.它是极少数可以宣称代码结构干净,包之间没有循环依赖关系的项目之一。</li></ul><h2 id="原文地址"><a href="#原文地址" class="headerlink" title="原文地址"></a>原文地址</h2><p><a href="https://docs.spring.io/spring/docs/5.2.7.RELEASE/spring-framework-reference/overview.html#overview">Spring Framework Reference Overview</a></p>]]></content>
    
    
    <summary type="html">Spring核心模块Spring Framework的概述</summary>
    
    
    
    
    <category term="Java" scheme="http://tanqidong1992.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="http://tanqidong1992.github.io/tags/Spring/"/>
    
    <category term="阅读笔记" scheme="http://tanqidong1992.github.io/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="翻译" scheme="http://tanqidong1992.github.io/tags/%E7%BF%BB%E8%AF%91/"/>
    
    <category term="知识梳理" scheme="http://tanqidong1992.github.io/tags/%E7%9F%A5%E8%AF%86%E6%A2%B3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>代码提交流程</title>
    <link href="http://tanqidong1992.github.io/2020/05/21/2020/05/21/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/"/>
    <id>http://tanqidong1992.github.io/2020/05/21/2020/05/21/%E4%BB%A3%E7%A0%81%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E/</id>
    <published>2020-05-21T15:29:47.000Z</published>
    <updated>2021-10-12T10:53:53.993Z</updated>
    
    <content type="html"><![CDATA[<h3 id="提要"><a href="#提要" class="headerlink" title="提要"></a>提要</h3><ul><li>代码仓库分为开发分支(master)，发布分支(release)，特性分支(feature-xxx),修复分支(hotfix-xxx)</li><li>所有的代码仓库,除了开发分支,发布分支外,其他分支在合并后都会被删除.</li></ul><h3 id="克隆仓库"><a href="#克隆仓库" class="headerlink" title="克隆仓库"></a>克隆仓库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone  http://192.168.0.141:8081/DefaultCollection/Test/XXX</span><br></pre></td></tr></table></figure><h3 id="开发新的功能"><a href="#开发新的功能" class="headerlink" title="开发新的功能"></a>开发新的功能</h3><ol><li>新建特性分支</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">   #</span><span class="bash">先更新远程仓库的数据</span></span><br><span class="line">   git fetch </span><br><span class="line">   git checkout -b feature-xxx origin/master </span><br><span class="line">   ```2. 开发</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   echo &quot;new source&quot; &gt;&gt; Xxx.java</span><br><span class="line">   git add *</span><br><span class="line">   git commit -m &quot;实现了feature-xxx&quot;</span><br><span class="line">   ```3. 准备发起Pull Request</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   git fetch</span><br><span class="line"><span class="meta">   #</span><span class="bash">如果master分支有更新的话</span></span><br><span class="line">   git rebase origin/master </span><br><span class="line">   git push origin feature-xxx:feature-xxx</span><br><span class="line">   ```4. 发起Pull Request</span><br><span class="line">    前往TFS新建Pull Request页面，选择将feature-xxx合并到master分支。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 修复已有Bug</span></span></span><br><span class="line"></span><br><span class="line">1. 新增修复分支hotfix-xxx</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   git fetch</span><br><span class="line"><span class="meta">   #</span><span class="bash">如果是开发分支上的bug，此处为origin/master，发布分支上的bug，此处为origin/release，过去版本上的bug，此处为相应版本的tag</span></span><br><span class="line">   git checkout -b hotfix-xxx origin/master </span><br><span class="line">   ```2. 修复</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   echo &quot;modified source&quot; &gt;&gt; Xxx.java</span><br><span class="line">   git commit -a -m &quot;修复了hotfix-xxx&quot;</span><br><span class="line">   ```3. 准备发起Pull Request</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">   git fetch</span><br><span class="line"><span class="meta">   #</span><span class="bash">如果是开发分支上的bug，此处为origin/master，发布分支上的bug，此处为origin/release，过去版本的bug不需要此操作，</span></span><br><span class="line">   git rebase origin/master </span><br><span class="line">   git push origin hotfix-xxx:hotfix-xxx</span><br><span class="line">   ```4. 发起Pull Request</span><br><span class="line">    前往TFS新建Pull Request页面，选择将hotfix-xxx合并到相应分支。</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">## 撤销已推送到TFS提交</span></span></span><br><span class="line"></span><br><span class="line">1. 确定已撤销提交的commit id</span><br><span class="line"></span><br><span class="line">```powershell</span><br><span class="line">W:\test\git-test&gt;git log --pretty=oneline</span><br><span class="line">95e8b97709eb9c509dea40541b7809709a7d44ae add line 2</span><br><span class="line">56d647a32a250e003625f73010ac02345439305c add line 1</span><br><span class="line">ea08289025e7c0782c71894bb69ccaefd406f43b add a.txt</span><br><span class="line">```2. 执行git revert命令</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">git revert 95e8b97709eb9c509dea40541b7809709a7d44ae</span><br><span class="line">```3. 推送到TFS</span><br><span class="line"></span><br><span class="line">```shell</span><br><span class="line">git push origin &lt;local branch name&gt;:&lt;remote branch name&gt;</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="http://192.168.0.141:8081/DefaultCollection/HNVMNS9000/_wiki/wikis/HNVMNS9000.wiki?wikiVersion=GBwikiMaster&pagePath=/TFS%E7%9B%B8%E5%85%B3/%E5%A6%82%E4%BD%95%E5%8F%91%E8%B5%B7%E4%B8%80%E4%B8%AAPull%20Request">如何在TFS中发起Pull Request</a></li></ol>]]></content>
    
    
    <summary type="html">代码提交流程</summary>
    
    
    
    
    <category term="Git" scheme="http://tanqidong1992.github.io/tags/Git/"/>
    
    <category term="团队协作" scheme="http://tanqidong1992.github.io/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"/>
    
    <category term="实践" scheme="http://tanqidong1992.github.io/tags/%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>Y9000X(Ubuntu 18.04系统)安装Wi-Fi驱动</title>
    <link href="http://tanqidong1992.github.io/2019/11/19/2019/11/Y9000X-Ubuntu%E7%B3%BB%E7%BB%9F-%E5%AE%89%E8%A3%85WIFI%E9%A9%B1%E5%8A%A8/"/>
    <id>http://tanqidong1992.github.io/2019/11/19/2019/11/Y9000X-Ubuntu%E7%B3%BB%E7%BB%9F-%E5%AE%89%E8%A3%85WIFI%E9%A9%B1%E5%8A%A8/</id>
    <published>2019-11-18T16:12:44.000Z</published>
    <updated>2021-10-12T07:34:24.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-确认无线网卡型号"><a href="#1-确认无线网卡型号" class="headerlink" title="1 确认无线网卡型号"></a>1 确认无线网卡型号</h2><p>在Windows操作系统-&gt;计算机管理-&gt;设备管理器-&gt;网络适配器下,可以看到网络适配器的型号为:Intel(R) Wi-Fi 6 AX200 160MHz</p><h2 id="2-去Intel官网查看Linux对这个型号网卡的支持情况"><a href="#2-去Intel官网查看Linux对这个型号网卡的支持情况" class="headerlink" title="2 去Intel官网查看Linux对这个型号网卡的支持情况"></a>2 去Intel官网查看Linux对这个型号网卡的支持情况</h2><p>前往网址<a href="https://www.intel.com/content/www/us/en/support/articles/000005511/network-and-io/wireless-networking.html">Linux* Support for Intel® Wireless Adapters</a>,可以看到以下信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Device                    KernelsFirmware</span><br><span class="line">Intel® Wi-Fi 6 AX200 160MHz5.1+iwlwifi-cc-46.3cfab8da.0.tgz</span><br></pre></td></tr></table></figure><p>这个固件需要Linux内核版本为5.1及以上.</p><h2 id="3-升级操作系统内核"><a href="#3-升级操作系统内核" class="headerlink" title="3 升级操作系统内核"></a>3 升级操作系统内核</h2><p>查看当前操作系统内核版本,如果当前系统使用内核版本大于等于5.1,则不需要执行内核升级操作.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uname -sr</span><br></pre></td></tr></table></figure><p>前往<a href="https://kernel.ubuntu.com/~kernel-ppa/mainline/">ubuntu kernel</a>下载内核安装包,使用dpkg命令安装内核安装包(版本大于等于5.1即可),</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-headers-5.3.11-050311_5.3.11-050311.201911121635_all.deb</span><br><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-image-unsigned-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb</span><br><span class="line">wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v5.3.11/linux-modules-5.3.11-050311-generic_5.3.11-050311.201911121635_amd64.deb</span><br><span class="line">sudo dpkg -i linux*.deb</span><br></pre></td></tr></table></figure><h2 id="4-下载并安装网络适配器固件"><a href="#4-下载并安装网络适配器固件" class="headerlink" title="4 下载并安装网络适配器固件"></a>4 下载并安装网络适配器固件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://wireless.wiki.kernel.org/_media/en/users/drivers/iwlwifi/iwlwifi-cc-46.3cfab8da.0.tgz</span><br><span class="line">tar -xf iwlwifi-cc-46.3cfab8da.0.tgz</span><br><span class="line">cd iwlwifi-cc-46.3cfab8da.0/</span><br><span class="line">cp * /lib/firmware</span><br></pre></td></tr></table></figure><h2 id="5-最后"><a href="#5-最后" class="headerlink" title="5 最后"></a>5 最后</h2><p>指定新的内核,启动系统.</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li>如果重启后出现以下错误</li></ol><pre><code class="shell">   error: XXX has invalid signature   error: you need to load the kernel first   ```去BIOS设置,将Secure Boot关闭.</code></pre>]]></content>
    
    
    <summary type="html">记录下Ubuntu 18.04(Y9000X)安装Wi-Fi驱动步骤</summary>
    
    
    
    
    <category term="Ubuntu" scheme="http://tanqidong1992.github.io/tags/Ubuntu/"/>
    
    <category term="Y9000X" scheme="http://tanqidong1992.github.io/tags/Y9000X/"/>
    
    <category term="WIFI Driver" scheme="http://tanqidong1992.github.io/tags/WIFI-Driver/"/>
    
  </entry>
  
</feed>
