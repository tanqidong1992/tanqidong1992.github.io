<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css" integrity="sha256-jTIdiMuX/e3DGJUGwl3pKSxuc6YOuqtJYkM0bGQESA4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"tanqidong1992.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.10.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="JVM编译器调优">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM编译器调优">
<meta property="og:url" content="http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/index.html">
<meta property="og:site_name" content="芷兰旧梦">
<meta property="og:description" content="JVM编译器调优">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-11-18T15:11:47.000Z">
<meta property="article:modified_time" content="2023-02-13T13:30:14.010Z">
<meta property="article:author" content="芷兰旧梦">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="阅读笔记">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="性能调优">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/","path":"2020/11/18/2020/11/07/JVM编译器调优/","title":"JVM编译器调优"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JVM编译器调优 | 芷兰旧梦</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="芷兰旧梦" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">芷兰旧梦</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">偶尔记一些东西</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98"><span class="nav-number">1.</span> <span class="nav-text">JVM编译器调优</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#JIT%E7%BC%96%E8%AF%91%E5%99%A8"><span class="nav-number">1.1.</span> <span class="nav-text">JIT编译器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.2.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%AD%E7%82%B9%E7%BC%96%E8%AF%91"><span class="nav-number">1.2.1.</span> <span class="nav-text">热点编译</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">1.2.2.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E5%85%A5%E9%97%A8"><span class="nav-number">1.3.</span> <span class="nav-text">调优入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">编译器类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E6%A0%87%E5%BF%97"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">编译器标志</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E5%90%AF%E5%8A%A8"><span class="nav-number">1.3.2.</span> <span class="nav-text">优化启动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E6%89%B9%E5%A4%84%E7%90%86"><span class="nav-number">1.3.3.</span> <span class="nav-text">优化批处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E9%95%BF%E6%97%B6%E9%97%B4%E8%BF%90%E8%A1%8C%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">1.3.4.</span> <span class="nav-text">优化长时间运行的应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E5%92%8CJIT%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E7%89%88%E6%9C%AC"><span class="nav-number">1.4.</span> <span class="nav-text">Java和JIT编译器的版本</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%80%E5%85%B1%E6%9C%89%E4%B8%89%E4%B8%AA%E7%89%88%E6%9C%AC"><span class="nav-number">1.4.1.</span> <span class="nav-text">编译器一共有三个版本</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E9%80%89%E6%8B%A932%E4%BD%8D%E6%88%96%E8%80%8564%E4%BD%8D"><span class="nav-number">1.4.2.</span> <span class="nav-text">虚拟选择32位或者64位</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E7%BA%A7%E8%B0%83%E4%BC%98"><span class="nav-number">1.5.</span> <span class="nav-text">编译器中级调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E4%BC%98%E4%BB%A3%E7%A0%81%E7%BC%93%E5%AD%98"><span class="nav-number">1.5.1.</span> <span class="nav-text">调优代码缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%98%88%E5%80%BC"><span class="nav-number">1.5.2.</span> <span class="nav-text">编译阈值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%B5%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">检测编译过程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PrintCompilation%E6%89%93%E5%8D%B0"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">PrintCompilation打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#jstat%E6%89%93%E5%8D%B0%E7%BC%96%E8%AF%91%E6%97%A5%E5%BF%97"><span class="nav-number">1.5.3.2.</span> <span class="nav-text">jstat打印编译日志</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E4%BC%98"><span class="nav-number">1.6.</span> <span class="nav-text">高级调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E7%BA%BF%E7%A8%8B"><span class="nav-number">1.6.1.</span> <span class="nav-text">编译线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94"><span class="nav-number">1.6.2.</span> <span class="nav-text">内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90"><span class="nav-number">1.6.3.</span> <span class="nav-text">逃逸分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%86%E4%BC%98%E5%8C%96"><span class="nav-number">1.7.</span> <span class="nav-text">逆优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E8%A2%AB%E4%B8%A2%E5%BC%83"><span class="nav-number">1.7.1.</span> <span class="nav-text">代码被丢弃</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%86%E4%BC%98%E5%8C%96%E9%99%B7%E9%98%B1"><span class="nav-number">1.7.1.1.</span> <span class="nav-text">逆优化陷阱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="nav-number">1.7.1.2.</span> <span class="nav-text">分层编译</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%86%E4%BC%98%E5%8C%96%E5%83%B5%E5%B0%B8%E4%BB%A3%E7%A0%81"><span class="nav-number">1.7.2.</span> <span class="nav-text">逆优化僵尸代码</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91%E7%BA%A7%E5%88%AB"><span class="nav-number">1.8.</span> <span class="nav-text">分层编译级别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="nav-number">1.9.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">1.10.</span> <span class="nav-text">参考</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">芷兰旧梦</p>
  <div class="site-description" itemprop="description">只是为了好玩</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">55</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/tanqidong1992" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;tanqidong1992" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>


  <div class="links-of-blogroll site-overview-item animated">
    <div class="links-of-blogroll-title"><i class="fa fa-globe fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://forrestsu.github.io/" title="https:&#x2F;&#x2F;forrestsu.github.io&#x2F;" rel="noopener" target="_blank">程序员的冷浪漫</a>
        </li>
    </ul>
  </div>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://tanqidong1992.github.io/2020/11/18/2020/11/07/JVM%E7%BC%96%E8%AF%91%E5%99%A8%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="芷兰旧梦">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="芷兰旧梦">
      <meta itemprop="description" content="只是为了好玩">
    </span>
    
    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JVM编译器调优 | 芷兰旧梦">
      <meta itemprop="description" content="JVM编译器调优">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM编译器调优
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-11-18 23:11:47" itemprop="dateCreated datePublished" datetime="2020-11-18T23:11:47+08:00">2020-11-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2023-02-13 21:30:14" itemprop="dateModified" datetime="2023-02-13T21:30:14+08:00">2023-02-13</time>
    </span>

  
</div>

            <div class="post-description">JVM编译器调优</div>
        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h1 id="JVM编译器调优"><a href="#JVM编译器调优" class="headerlink" title="JVM编译器调优"></a>JVM编译器调优</h1><h2 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h2><p>即时（Just-In-Time，JIT）编译器是Java虚拟机的核心。对JVM的性能影响最大的莫过于编译器，而选择编译器是运行Java程序的首要选择之一。幸运的是在绝大多数情况下，我们只需要对编译器做一些基本的调优。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>计算机的CPU只能执行相对较少的特定的指令，这些指令称为汇编码或者二进制码，因此CPU执行的所有程序都必须翻译成这种指令。</p>
<ul>
<li>有像C++，Fortran这样的语言被称为编译型语言，因为它们的程序都已二进制形式交付,并且这种二进制中的汇编码是针对特定CPU的,只要是兼容的CPU，都可以执行相同的二进制代码</li>
<li>还有像PHP，Perl这样的解释型语言，只要机器上有相应的解释器，相同的程序可以在任何CPU上执行.</li>
</ul>
<p>每种类型的编程语言都各有长处和不足，解释型的编程语言具有良好的可移植性，相同的代码可以在任何有适当解释器的机器上运行，但它执行起来可能就慢，因为每次执行前都必须要先解释。</p>
<p>Java试图走一条中间路线，Java应用会被编译成一种理想化的汇编语言，然后该汇编语言可以用Java执行，这使得Java成为一门平台独立的解释型语言。</p>
<p>Java程序运行的是理想化的二进制代码，所以它能在代码执行时将其编译成平台特定的二进制代码，由于这个编译是在程序执行时进行的，因此称为”即时编译“（JIT）。</p>
<h3 id="热点编译"><a href="#热点编译" class="headerlink" title="热点编译"></a>热点编译</h3><p>对程序而言，通常只有一部分代码被经常执行，而应用的性能就取决于这些代码执行有多快，这些关键代码段被称为应用的热点，代码执行的越多就被认为是越热。<br>因此JVM执行代码时只会编译热点代码，一般是经常执行的方法或者多次执行的循环体，这样才有意义。JVM执行特定的方法或者循环越多，它就越了解这段代码，使得JVM可以在编译时，做更多的优化,例如编译器和主内存优化。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol>
<li>Java的设计结合了脚本语言的平台独立性和编译型语言的本地性能。</li>
<li>Java文件被翻译成中间语言（Java字节码），然后运行时被JVM进一步编译成汇编语言。</li>
<li>字节码编译成汇编语言的过程中有大量的优化，极大地改善了性能。</li>
</ol>
<h2 id="调优入门"><a href="#调优入门" class="headerlink" title="调优入门"></a>调优入门</h2><h3 id="编译器类型"><a href="#编译器类型" class="headerlink" title="编译器类型"></a>编译器类型</h3><p>有两种JIT编译器：</p>
<ul>
<li>client,也被成为C1</li>
<li>server，也被成为C2</li>
</ul>
<h4 id="编译器标志"><a href="#编译器标志" class="headerlink" title="编译器标志"></a>编译器标志</h4><ul>
<li>标准的编译器标志：<br>  -client,-server,-d64</li>
<li>分层编译<br>  -XX:+TieredCompilation<br>  备注：分层编译必须启用server编译器，如下启动参数意味着关闭分层编译</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -client -XX:+TieredCompilation other_args</span><br></pre></td></tr></table></figure>

<p>两种编译器的主要差别是：</p>
<ul>
<li>client编译器比server编译器开启编译的时机要早。意味着在代码执行的开始阶段client编译器比server编译器要快(因为client编译的代码相对server编译器而言要多)。</li>
<li>server编译器在编译代码时可以更好的优化，最终server编译器生成的代码要比client编译器生成的代码要快。</li>
</ul>
<p>从用户的角度来说，权衡的取舍在于程序要运行多久，程序的启动时间有多重要。</p>
<p>分层编译：前期采用client编译，随着代码变热，由server编译器重新编译，分层编译从Java7开始引入,7u4版本开始可以发挥较好性能，默认关闭(-XX:+TieredCompilation为false),server编译器在编译代码时可以更好的优化，最终server编译器生成的代码要比client编译器生成的代码要快。Java8开始,分层编译默认启用。</p>
<h3 id="优化启动"><a href="#优化启动" class="headerlink" title="优化启动"></a>优化启动</h3><ul>
<li>如果应用的启动时间是首要的性能考量,那么client编译器就是最佳的选择.</li>
<li>分层编译的启动时间非常接近于client编译器所获得的启动时间.</li>
</ul>
<h3 id="优化批处理"><a href="#优化批处理" class="headerlink" title="优化批处理"></a>优化批处理</h3><ul>
<li>对于计算量固定的任务来说,应该选择执行实际任务最快的编译器.</li>
<li>分层编译是批处理任务合理的默认选择.</li>
</ul>
<h3 id="优化长时间运行的应用"><a href="#优化长时间运行的应用" class="headerlink" title="优化长时间运行的应用"></a>优化长时间运行的应用</h3><ul>
<li>对于长时间运行的应用来说,应该一直使用server编译器,最好配合分层编译.</li>
</ul>
<h2 id="Java和JIT编译器的版本"><a href="#Java和JIT编译器的版本" class="headerlink" title="Java和JIT编译器的版本"></a>Java和JIT编译器的版本</h2><h3 id="编译器一共有三个版本"><a href="#编译器一共有三个版本" class="headerlink" title="编译器一共有三个版本"></a>编译器一共有三个版本</h3><ul>
<li>32位client(-client)</li>
<li>32位server(-server)</li>
<li>64位server(-d64)</li>
</ul>
<h3 id="虚拟选择32位或者64位"><a href="#虚拟选择32位或者64位" class="headerlink" title="虚拟选择32位或者64位"></a>虚拟选择32位或者64位</h3><p>如果是32位的操作系统必须使用32位的JVM,如果是64位的操作系统,你可以选择32位或者64位的JVM,如果堆小于3G,32位的Java会更快一些,因为JVM内部的指针只有32位,操作32位指针的代价要少于64位指针,而且32位指针占用的内存也少.虽然有普通对象指针压缩技术,但是64位JVM占用内存仍然大于32位的JVM,因为它所用的本地代码还是64位寻址.</p>
<p>32位JVM最大的不足是最多只能用4GB内存,有一个非常特殊的案例:因为32位JVM无法使用64位寄存器,所以大量使用long或者double变量的程序在32位JVM上就会比较慢.</p>
<p>在32位JVM运行的程序,只要与32位寻址空间吻合,无论机器是32位还是64位,都比在类似配置的64位JVM运行时快5%到%20.</p>
<p><strong>在Java8中,所有JVM中默认的编译器为server编译器,并默认开启分层编译.Java8是最后一个Oracle官方提供32位jdk下载的版本,从Jdk9开始,Oracle官网不再提供32bit Jdk下载</strong></p>
<h2 id="编译器中级调优"><a href="#编译器中级调优" class="headerlink" title="编译器中级调优"></a>编译器中级调优</h2><h3 id="调优代码缓存"><a href="#调优代码缓存" class="headerlink" title="调优代码缓存"></a>调优代码缓存</h3><p>JVM编译代码时,会在代码缓存中保留编译之后的汇编语言指令集,代码缓存的大小固定,一旦充满,JVM就无法编译更多代码了.<br>这个问题在使用client编译器和启动分层编译时很常见,使用常规的server编译器时,只有少量的类会被编译,不太可能充满代码缓存.<br>执行以下命令查看默认的代码缓存大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep CodeCacheSize</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uintx InitialCodeCacheSize                     = 2555904                                &#123;pd product&#125; &#123;default&#125;</span><br><span class="line">uintx ReservedCodeCacheSize                    = 251658240                              &#123;pd product&#125; &#123;ergonomic&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>-XX:InitialCodeCacheSize&#x3D;N 用于指定代码缓存的初始大小.</li>
<li>-XX:ReservedCodeCacheSize&#x3D;N 用户指定代码缓存的最大值.</li>
</ul>
<p>为了永远不超过空间而将代码缓存的最大值设得很大,这取决于目标机器有多少可用资源,例如代码缓存被设置为1GB,JVM会保留1GB的本地内存空间,虽然用的时候才会分配,但是它仍然会被保留,为了满足保留内存,你的机器必须有充足的虚拟内存.</p>
<p><strong>备注: 保留内存是分配地址空间,已提交内存是分配内存(只有访问时,才会将分配实际的物理内存页)</strong></p>
<p>代码缓存是一种有最大值的资源,它会影响JVM可运行的编译代码总量,分层编译很容易达到代码缓存默认配置的上限,使用分层编译时,应该监控代码缓存,必要时增加它的最大值.</p>
<h3 id="编译阈值"><a href="#编译阈值" class="headerlink" title="编译阈值"></a>编译阈值</h3><p>当代码执行的次数达到编译阈值后,编译器就可以获得足够的信息编译代码了.<br>编译时基于两种JVM计数器:</p>
<ul>
<li>方法计数器</li>
<li>方法中的循环回边计数器(回边实际可看作循环完成执行的次数)</li>
</ul>
<p>JVM执行某个方法时,会检查两种计数器总数,判断是否适合编译,如果合适,就进入编译队列,这种编译称为标准编译.</p>
<p>如果循环比较长,或者所包含程序逻辑永远不退出,这个情况下JVM不等方法调用就会编译循环,所以循环每完成一次,回边计数器会被增加并被检测,如果循环的回边计数器超过阈值,那么这个循环(不是整个方法)就可以被编译,这种编译称为栈上替换(On-StackReplacement,OSR).</p>
<p>标准编译由 -XX:CompileThreshold&#x3D;N 标志触发,client的默认值为1500,server默认值为10000.这个标志的值等于回边计数器加上方法计数器的总和.<br>运行以下命令查看默认值<br>Linux下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/mnt/c/Users/tqd$ java -client -XX:+PrintFlagsFinal --version | grep CompileThreshold</span><br><span class="line">intx CompileThreshold                         = 10000                                  &#123;pd product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure>

<p>Windows 下</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;CompileThreshold&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">intx CompileThreshold                         = <span class="number">1500</span>                                   &#123;pd product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure>

<p>OSR编译的阈值为 OSR trigger &#x3D; (CompileThreshold*(OnStackReplacePercentage - InterpreterProfilePercentage)&#x2F;100)</p>
<p>所有编译器中的 -XX:InterpreterProfilePercentage&#x3D;N 标志的默认值为33,client编译器中的-XX:OnStackReplacePercentage&#x3D;N的默认值为933<br>server编译器中的-XX:OnStackReplacePercentage的默认值为140;</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;OnStackReplacePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">intx OnStackReplacePercentage                 = <span class="number">933</span>                                    &#123;pd product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-server</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;OnStackReplacePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">intx OnStackReplacePercentage                 = <span class="number">140</span>                                    &#123;pd product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-server</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;InterpreterProfilePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Server VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">intx InterpreterProfilePercentage             = <span class="number">33</span>                                        &#123;product&#125; &#123;default&#125;</span><br><span class="line"><span class="built_in">PS</span> C:\Users\tqd&gt; java <span class="literal">-client</span> <span class="literal">-XX</span>:+PrintFlagsFinal <span class="literal">-version</span> | findStr <span class="string">&quot;InterpreterProfilePercentage&quot;</span></span><br><span class="line">openjdk version <span class="string">&quot;11.0.8&quot;</span> <span class="number">2020</span><span class="literal">-07-14</span></span><br><span class="line">OpenJDK Runtime Environment AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>)</span><br><span class="line">OpenJDK <span class="number">64</span><span class="literal">-Bit</span> Client VM AdoptOpenJDK (build <span class="number">11.0</span>.<span class="number">8</span>+<span class="number">10</span>, mixed mode)</span><br><span class="line">intx InterpreterProfilePercentage             = <span class="number">33</span>                                        &#123;product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure>

<p>client编译器与server编译器的性能有很大的差异,这些差异很大程度上取决于编译方法时所获得的信息.降低编译阈值,特别是对server编译器来说,可能会减少编译代码的优化.不过应用测试表明,事实上几乎没有差别,比如8000次和10000次调用差别微乎其微.</p>
<p>使用较低的配置主要原因如下</p>
<ul>
<li>节约一点应用热身的时间</li>
<li>使得某些原本可能不会被server编译器编译的方法得以编译</li>
</ul>
<p>每种计数器的值都会周期性减少(特别是JVM达到安全点时),计数器只是方法的最新热度的度量,执行不太频繁的代码永远不会编译,即便是永远运行的程序(相对于热,这些方法被称为温热).一般通过减少编译阀值来优化,这也是分层编译通常比单独的server编译器更快的原因之一.</p>
<p><strong>小结:当方法和执行循环达到某个阀值的时候,就会发生编译;改变阀值会导致代码提前或者推后编译;由于计数器会随时间而减少,以至于”温热”的方法可能永远都达不到编译的阈值(特别对于server编译器来说).</strong></p>
<h3 id="检测编译过程"><a href="#检测编译过程" class="headerlink" title="检测编译过程"></a>检测编译过程</h3><h4 id="PrintCompilation打印"><a href="#PrintCompilation打印" class="headerlink" title="PrintCompilation打印"></a>PrintCompilation打印</h4><p>启用标志: -XX:+PrintCompilation(默认为false)<br>开启PrintCompilation后,每编译一个方法就会打印一行被编译的内容信息,输出的信息在不同的Java发行版本有所不同,Java7中的标准化输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp compilation_id attributes (tiered_level) method_name size deopt</span><br></pre></td></tr></table></figure>
<ul>
<li>timestamp:编译时间戳,相对于JVM启动的时间.</li>
<li>compilation_id:内部任务Id,通常这个数字只是单调增长,使用server编译器会乱序输出(多个编译线程).</li>
<li>attributes: 是一组5个字符长的串,表示编译状态,如果给定编译被赋予特定属性,就会打印一下字符串,否则打印空格,5个字符属性串可以同时出现多个:</li>
<li>% :编译为OSR.</li>
<li>s :方法是同步的.</li>
<li>! :方法有异常处理器.</li>
<li>b :阻塞模式发生的编译.</li>
<li>n :为封装本地方法所发生的编译.<br>  备注:前三个可以自解释,阻塞标志(b)在当前版本的Java中默认用于不会打印,表明编译不会发生在后台.n标志表明JVM生成了一些编译代码以便于调用本地方法.</li>
<li>tiered_level: 完成编译的级别.如不启用分层编译,这个字段为空.</li>
<li>method_name: 被编译方法的名称.</li>
<li>size: 编译代码的大小,这是java字节码的大小,不是编译后的代码的大小</li>
<li>deopt: 表明发生某种逆优化,通常是”made not entrant”或者”made zombie”</li>
</ul>
<h4 id="jstat打印编译日志"><a href="#jstat打印编译日志" class="headerlink" title="jstat打印编译日志"></a>jstat打印编译日志</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jstat -compiler [jvm pid]</span><br><span class="line">jstat -compiler [jvm pid] [interval]</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">打印进程号为5003的编译日志</span></span><br><span class="line">jstat -compiler 5003</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">每1000ms打印一次</span></span><br><span class="line">jstat -printcompilation 5003 1000</span><br></pre></td></tr></table></figure>

<p>有时候有如下输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp compile_id COMPILE SKIPPED: reason</span><br></pre></td></tr></table></figure>

<p>这行信息表明编译的给定方法有误,出现这种情况的原因有以下两种:</p>
<ul>
<li>代码缓存满了,可以通过ReservedCodeCacheSize标志增加</li>
<li>编译的同时加载类:编译类的时候发生修改,JVM之后会再次编译.</li>
</ul>
<p><strong>小结:观察代码如何被编译的最好方法是开启PrintCompilation;PrintCompilation开启后所输出的信息可用来确认编译是否和预期一样.</strong></p>
<h2 id="高级调优"><a href="#高级调优" class="headerlink" title="高级调优"></a>高级调优</h2><h3 id="编译线程"><a href="#编译线程" class="headerlink" title="编译线程"></a>编译线程</h3><p>当方法(或循环)适合编译时,就会进入到编译队列.队列由一个或者多个后台线程处理.<br>编译队列并不严格遵守先进先出原则:调用计数次数多的方法有更高的优先级.<br>当使用client编译器时,JVM会开启一个编译线程,使用server编译器时,则会开启两个这样的线程.当启用分层编译时,JVM默认开启多个client和server线程,线程数根据一个复杂的等式而定,包括目标平台CPU数取双对数后的数值.</p>
<p>编译器的线程数可以通过-XX:CICompilerCount&#x3D;N标志来设置,这是JVM处理队列的线程总数;对分层编译而言,至少三分之一(至少一个)将用来处理client编译器队列,其余的线程(至少一个)用来处理server编译器队列.<br>另一个编译线程设定参数为-XX:+BackgroundCompilation标志,默认为true,编译队列的处理是异步执行,设置为false,当一个方法适合编译时,执行方法的代码会一直等待到它确实被编译之后才执行,用-Xbatch可以禁用后台编译.<br><strong>小结:放置在编译队列中的方法的编译会被异步执行;队列不是严格按照先进先出;队列中的热点方法会在其他方法之前编译,这是编译输出日志的ID为乱序的另一个原因.</strong></p>
<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><p>编译器所做的最重要的优化就是方法内联,遵循面向对象设计的良好代码通常都会包括一些需要通过getter(setter)访问的属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Point</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.x=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>访问属性的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p=<span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p.setX(p.getX()*<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>等同于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point p=<span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">p.x=p.x*<span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>内联是默认开启的可通过-XX:-Inline关闭,然而它对性能影响巨大,不幸的是,基本没法看JVM是如何内联(如果你从源码编译JVM,可以用-XX:+PrintInlining生成带调试信息的版本,这个参数会提供所有关于编译器如何进行内联决策的信息).</p>
<p>方法是否内联取决于它有多热以及它的大小,JVM依据内部计算来判断方法是否热点,是否是热点并不直接与任何调优参数相关,如果方法因调用频繁而可以内联,那么只有它的字节码小于325字节时(或-XX:MaxFreqInlineSize(FreqInlineSize)&#x3D;N所设定的值)才会内联,否则,只有方法很小时,即小于35字节(或者-XX:MaxInlineSize&#x3D;N所设定的值)时才会内联.</p>
<p><strong>小结:内联是编译器所能做的最有利的优化,特别是对属性封装良好的面向对象的代码来说;几乎用不着调节内联参数,且提倡这样做的建议往往忽略了常规内联与频繁调用内联之间的关系,当考察内联效应时,确保考虑这两种情况.</strong></p>
<h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>JVM默认开启逃匿分析（-XX:+DoEscapeAnalysis,默认为true)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tqd@tqd-pc:/$ java -XX:+PrintFlagsFinal -version 2&gt;&amp;1 | grep DoEscapeAnalysis</span><br><span class="line">bool DoEscapeAnalysis                         = true                                   &#123;C2 product&#125; &#123;default&#125;</span><br></pre></td></tr></table></figure>

<p>server编译器将会执行一些非常激进的优化措施,比如去掉不必要的同步锁，将没必要保存到内存的值，保存到寄存器，不需要分配的对象，仅追踪其部分字段，此类优化非常复杂。逃逸分析默认开启，极少情况下它会出错，在此类情况下关闭它会变得更快或更稳定。如果你发现这种行为，最好的应对方法就是简化相关代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Factorial</span>&#123;</span><br><span class="line"><span class="keyword">private</span> BigInteger factorial;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Factorial</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.n=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> BigInteger <span class="title function_">getFactorial</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(factorial == <span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//没必要在内存中保留n，可以在寄存器这种保留该值</span></span><br><span class="line">factorial = <span class="number">0</span>;<span class="comment">//计算n的阶乘，此处省略</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> factorial;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sample code</span></span><br><span class="line">List&lt;BigInteger&gt; list=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line"><span class="comment">//实际上没必要分配factorial对象，只需要追踪其部分字段</span></span><br><span class="line">Factorial factorial=<span class="keyword">new</span> <span class="title class_">Factorial</span>(i);</span><br><span class="line"><span class="comment">//此处getFactorial方法的同步锁库没必要获取，可能被优化掉</span></span><br><span class="line">list.add(factorial.getFactorial())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>小结：逃逸分析是编译器做得最复杂的优化。此类优化常常会导致微基准测试失败；逃逸分析常常会给不正确的同步代码引入Bug</strong></p>
<h2 id="逆优化"><a href="#逆优化" class="headerlink" title="逆优化"></a>逆优化</h2><p>有两种逆优化的场景,代码状态分别为:</p>
<ul>
<li>made no entrant(代码被丢弃)</li>
<li>made zombie(产生僵尸代码)</li>
</ul>
<h3 id="代码被丢弃"><a href="#代码被丢弃" class="headerlink" title="代码被丢弃"></a>代码被丢弃</h3><p>导致代码被丢弃的原因共两种：</p>
<ul>
<li>逆优化陷阱。</li>
<li>分层编译。</li>
</ul>
<h4 id="逆优化陷阱"><a href="#逆优化陷阱" class="headerlink" title="逆优化陷阱"></a>逆优化陷阱</h4><p>考虑如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hello</span>&#123;</span><br><span class="line"><span class="keyword">private</span> IService service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request</span><span class="params">(String log)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(log!=<span class="literal">null</span> &amp;&amp; log.equals(<span class="string">&quot;A&quot;</span>))&#123;</span><br><span class="line">service=A();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">service=B();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> service.doSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果开始有大量的请求log不为空，此时service实际时A类型，然后它将内联代码，进行优化，后续只有大量log为空的请求，之前编译器根据service类型做的假设将不成立了，之前的优化也失效了，产生逆优化陷阱(deoptimization trap),如果有跟多log不为空的请求，JVM会中止此部分代码编译，而开始新的编译。<br><strong>注意：OSR编译过的构造函数和标准编译过的方法都被标记成made no entrant，过一会，它们又被标记为made zombie.</strong><br>逆优化听起来不好，但是逆优化之后，如果代码再次被调用，又会重新编译，逆优化，除了进入陷阱的短暂时间，对于其他方面没有太大的影响。</p>
<h4 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h4><p>在分层编译中，代码首先由client编译器编译，然后由server编译器编译，当server编译器编译好代码后，JVM必须替换client编译器编译的代码，这些代码将被标记为废弃。这种“逆优化”实际使得代码运行更快。</p>
<h3 id="逆优化僵尸代码"><a href="#逆优化僵尸代码" class="headerlink" title="逆优化僵尸代码"></a>逆优化僵尸代码</h3><p>编译器日志显示产生了僵尸代码，即JVM已经回收了之前被丢弃的代码，<br>在上面的例子中，当log为空时A类编译的代码就被丢弃了，但是A类的对象未被回收，最终A类的对象全部被GC回收，回收后编译器就会注意到，这个类就适合标记为僵尸代码了。</p>
<p>从性能的角度来看这是好事，编译代码保存在固定大小的代码缓存中，如果发现僵尸代码，意味着有问题的代码可以从代码缓存中移除，腾出空间给其他被编译的代码</p>
<p>不足之处：如果代码被僵尸化后被再次加载并且重新编译，JVM需要重新编译和重新优化代码。但这种情况对应用的性能没有太大的影响。</p>
<p>小结:逆优化使得编译器可以回到之前版本的编译代码；先前的优化不再有效时，才会发生代码逆优化；代码逆优化，会对性能产生小而短暂的影响，新编译的代码会尽快地再次热身；分层编译时，之前被client编译器编译而现在由server编译器优化，就会发生逆优化。</p>
<h2 id="分层编译级别"><a href="#分层编译级别" class="headerlink" title="分层编译级别"></a>分层编译级别</h2><p>当使用分层编译时，编译日志中会输出代码所编译的级别。一共两种编译器，再加上解释器，client编译器有3种编辑级别，总计5种编译级别：</p>
<ul>
<li>0: 解释代码</li>
<li>1: 简单c1编译代码</li>
<li>2: 受限的c1编译代码</li>
<li>3: 完全c1编译代码</li>
<li>4: c2编译代码</li>
</ul>
<p>典型的编译路径 级别3 -&gt; 级别4；多数方法第一次被编译成级别3，当方法运行足够频繁，它会被编译成级别4.最常见的情况是： client编译器从获取了代码如何使用的信息进行优化时才开始编译。</p>
<p>如果server编译器队列满了，会从server队列中取出方法，以级别2进行编译，这个级别上，client编译器使用方法调用计数器和回边计数器（但不需要分析性能），编译更快，而方法在client编译器收集分析信息后被编译成级别3，最终server编译器队列不太忙时被编译成级别4.</p>
<p>如果client编译器队列全忙，原本排程在级别3编译的方法就既可以等待级别3编译，也适合进行级别4的编译。在这种情况下，方法编译会很快转到级别2，然后由级别2转到级别4。</p>
<p>那些不重要的方法可以从级别2或者级别3编译，但随后会因为它们的重要性没那么高而转为级别1。另外如果server编译器处于某些原因无法编译代码，也会转为级别1。</p>
<p>当然，代码在逆编译时会转为级别0-&gt;级别3-&gt;级别4编译时，性能可以达到最优。如果方法经常被编译成级别2并且还有多余的cpu周期，那么可以考虑增大编译器的线程数，从而减少server编译器队列的长度，如果没有额外的cpu周期，那么你只能减少应用的大小。</p>
<p><strong>小结：分层编译可以在两种编译器和5种级别之间进行；不建议人为更改级别;</strong></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>final关键字不会影响性能,即便曾经会，但也是太久以前了。</p>
<ol>
<li>不用担心小方法，它们很容易被内联。</li>
<li>需要编译的代码在编译队列中，队列中代码越多，程序达到最佳性能的时间越久。</li>
<li>代码缓存虽然可以调整，但它仍然是有限资源。</li>
<li>代码越简单，优化越多。分析反馈和逃逸分析使得代码更快，但复杂的循环结构和大方法限制它的有效性。</li>
<li>审视编译器做什么很重要。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc?redirectedfrom=MSDN">已提交内存与保留内存</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/tanqidong1992/compilation-test">检测编译过程实验</a></li>
</ol>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" rel="tag"># 阅读笔记</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
              <a href="/tags/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" rel="tag"># 性能调优</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2020/10/12/2020/10/12/GraalVM%E5%AE%89%E8%A3%85/" rel="prev" title="GraalVM安装与Native-Image体验">
                  <i class="fa fa-chevron-left"></i> GraalVM安装与Native-Image体验
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/12/12/2020/12/Shell%E5%8F%98%E9%87%8F/" rel="next" title="Shell变量">
                  Shell变量 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">芷兰旧梦</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
